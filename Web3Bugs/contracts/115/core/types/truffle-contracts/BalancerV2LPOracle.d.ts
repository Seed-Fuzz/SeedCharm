/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import {EventData, PastEventOptions} from "web3-eth-contract";

export interface BalancerV2LPOracleContract
  extends Truffle.Contract<BalancerV2LPOracleInstance> {
  "new"(
    _decimals: number | BN | string,
    _description: string,
    _vault: string,
    _poolId: string,
    _oracleA: string,
    _oracleB: string,
    meta?: Truffle.TransactionDetails
  ): Promise<BalancerV2LPOracleInstance>;
}

type AllEvents = never;

export interface BalancerV2LPOracleInstance extends Truffle.ContractInstance {
  BONE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  BPOW_PRECISION(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  EXIT_FEE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  INIT_POOL_SUPPLY(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MAX_BOUND_TOKENS(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MAX_BPOW_BASE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MAX_FEE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MAX_IN_RATIO(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MAX_OUT_RATIO(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MAX_TOTAL_WEIGHT(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MAX_WEIGHT(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MIN_BALANCE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MIN_BOUND_TOKENS(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MIN_BPOW_BASE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MIN_FEE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  MIN_WEIGHT(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  decimals(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  description(txDetails?: Truffle.TransactionDetails): Promise<string>;

  oracleA(txDetails?: Truffle.TransactionDetails): Promise<string>;

  oracleB(txDetails?: Truffle.TransactionDetails): Promise<string>;

  pool(txDetails?: Truffle.TransactionDetails): Promise<string>;

  poolId(txDetails?: Truffle.TransactionDetails): Promise<string>;

  vault(txDetails?: Truffle.TransactionDetails): Promise<string>;

  version(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  getRoundData(
    _roundId: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<{0: BN; 1: BN; 2: BN; 3: BN; 4: BN}>;

  /**
   * Note that answer and updatedAt may change between queries.
   * get data about the latest round. Consumers are encouraged to check that they're receiving fresh data by inspecting the updatedAt and answeredInRound return values. Note that different underlying implementations of AggregatorV3Interface have slightly different semantics for some of the return values. Consumers should determine what implementations they expect to receive data from and validate that they can properly handle return data from all of them.
   */
  latestRoundData(
    txDetails?: Truffle.TransactionDetails
  ): Promise<{0: BN; 1: BN; 2: BN; 3: BN; 4: BN}>;

  methods: {
    BONE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    BPOW_PRECISION(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    EXIT_FEE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    INIT_POOL_SUPPLY(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MAX_BOUND_TOKENS(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MAX_BPOW_BASE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MAX_FEE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MAX_IN_RATIO(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MAX_OUT_RATIO(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MAX_TOTAL_WEIGHT(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MAX_WEIGHT(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MIN_BALANCE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MIN_BOUND_TOKENS(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MIN_BPOW_BASE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MIN_FEE(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    MIN_WEIGHT(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    decimals(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    description(txDetails?: Truffle.TransactionDetails): Promise<string>;

    oracleA(txDetails?: Truffle.TransactionDetails): Promise<string>;

    oracleB(txDetails?: Truffle.TransactionDetails): Promise<string>;

    pool(txDetails?: Truffle.TransactionDetails): Promise<string>;

    poolId(txDetails?: Truffle.TransactionDetails): Promise<string>;

    vault(txDetails?: Truffle.TransactionDetails): Promise<string>;

    version(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    getRoundData(
      _roundId: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{0: BN; 1: BN; 2: BN; 3: BN; 4: BN}>;

    /**
     * Note that answer and updatedAt may change between queries.
     * get data about the latest round. Consumers are encouraged to check that they're receiving fresh data by inspecting the updatedAt and answeredInRound return values. Note that different underlying implementations of AggregatorV3Interface have slightly different semantics for some of the return values. Consumers should determine what implementations they expect to receive data from and validate that they can properly handle return data from all of them.
     */
    latestRoundData(
      txDetails?: Truffle.TransactionDetails
    ): Promise<{0: BN; 1: BN; 2: BN; 3: BN; 4: BN}>;
  };

  getPastEvents(event: string): Promise<EventData[]>;
  getPastEvents(
    event: string,
    options: PastEventOptions,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
  getPastEvents(event: string, options: PastEventOptions): Promise<EventData[]>;
  getPastEvents(
    event: string,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
}
