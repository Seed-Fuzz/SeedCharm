/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import {EventData, PastEventOptions} from "web3-eth-contract";

export interface MockChainlinkFeedContract
  extends Truffle.Contract<MockChainlinkFeedInstance> {
  "new"(
    _decimals: number | BN | string,
    _price: number | BN | string,
    _description: string,
    meta?: Truffle.TransactionDetails
  ): Promise<MockChainlinkFeedInstance>;
}

export interface OwnershipTransferred {
  name: "OwnershipTransferred";
  args: {
    previousOwner: string;
    newOwner: string;
    0: string;
    1: string;
  };
}

type AllEvents = OwnershipTransferred;

export interface MockChainlinkFeedInstance extends Truffle.ContractInstance {
  decimals(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  description(txDetails?: Truffle.TransactionDetails): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  owner(txDetails?: Truffle.TransactionDetails): Promise<string>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership: {
    (txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(txDetails?: Truffle.TransactionDetails): Promise<void>;
    sendTransaction(txDetails?: Truffle.TransactionDetails): Promise<string>;
    estimateGas(txDetails?: Truffle.TransactionDetails): Promise<number>;
  };

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership: {
    (newOwner: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      newOwner: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      newOwner: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      newOwner: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  version(txDetails?: Truffle.TransactionDetails): Promise<BN>;

  setLatestPrice: {
    (
      price: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      price: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<void>;
    sendTransaction(
      price: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      price: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Note that answer and updatedAt may change between queries.
   * get data about a round. Consumers are encouraged to check that they're receiving fresh data by inspecting the updatedAt and answeredInRound return values. Note that different underlying implementations of AggregatorV3Interface have slightly different semantics for some of the return values. Consumers should determine what implementations they expect to receive data from and validate that they can properly handle return data from all of them.
   * @param _roundId the requested round ID as presented through the proxy, this is made up of the aggregator's round ID with the phase ID encoded in the two highest order bytes
   */
  getRoundData(
    _roundId: number | BN | string,
    txDetails?: Truffle.TransactionDetails
  ): Promise<{0: BN; 1: BN; 2: BN; 3: BN; 4: BN}>;

  /**
   * Note that answer and updatedAt may change between queries.
   * get data about the latest round. Consumers are encouraged to check that they're receiving fresh data by inspecting the updatedAt and answeredInRound return values. Note that different underlying implementations of AggregatorV3Interface have slightly different semantics for some of the return values. Consumers should determine what implementations they expect to receive data from and validate that they can properly handle return data from all of them.
   */
  latestRoundData(
    txDetails?: Truffle.TransactionDetails
  ): Promise<{0: BN; 1: BN; 2: BN; 3: BN; 4: BN}>;

  methods: {
    decimals(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    description(txDetails?: Truffle.TransactionDetails): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(txDetails?: Truffle.TransactionDetails): Promise<string>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership: {
      (txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(txDetails?: Truffle.TransactionDetails): Promise<void>;
      sendTransaction(txDetails?: Truffle.TransactionDetails): Promise<string>;
      estimateGas(txDetails?: Truffle.TransactionDetails): Promise<number>;
    };

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership: {
      (newOwner: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        newOwner: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        newOwner: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        newOwner: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    version(txDetails?: Truffle.TransactionDetails): Promise<BN>;

    setLatestPrice: {
      (
        price: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        price: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<void>;
      sendTransaction(
        price: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        price: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Note that answer and updatedAt may change between queries.
     * get data about a round. Consumers are encouraged to check that they're receiving fresh data by inspecting the updatedAt and answeredInRound return values. Note that different underlying implementations of AggregatorV3Interface have slightly different semantics for some of the return values. Consumers should determine what implementations they expect to receive data from and validate that they can properly handle return data from all of them.
     * @param _roundId the requested round ID as presented through the proxy, this is made up of the aggregator's round ID with the phase ID encoded in the two highest order bytes
     */
    getRoundData(
      _roundId: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{0: BN; 1: BN; 2: BN; 3: BN; 4: BN}>;

    /**
     * Note that answer and updatedAt may change between queries.
     * get data about the latest round. Consumers are encouraged to check that they're receiving fresh data by inspecting the updatedAt and answeredInRound return values. Note that different underlying implementations of AggregatorV3Interface have slightly different semantics for some of the return values. Consumers should determine what implementations they expect to receive data from and validate that they can properly handle return data from all of them.
     */
    latestRoundData(
      txDetails?: Truffle.TransactionDetails
    ): Promise<{0: BN; 1: BN; 2: BN; 3: BN; 4: BN}>;
  };

  getPastEvents(event: string): Promise<EventData[]>;
  getPastEvents(
    event: string,
    options: PastEventOptions,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
  getPastEvents(event: string, options: PastEventOptions): Promise<EventData[]>;
  getPastEvents(
    event: string,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
}
