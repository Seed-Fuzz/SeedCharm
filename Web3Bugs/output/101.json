{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/101/sublime-v1",
    "external_functions": [
        [
            "LenderPool",
            "IERC1155ReceiverUpgradeable",
            "ISavingsAccount",
            "IVerification",
            "IPooledCreditLine",
            "IYield"
        ],
        [
            "PooledCreditLine",
            "ILimitsManager",
            "IPriceOracle",
            "IStrategyRegistry",
            "IVerification",
            "ILenderPool",
            "ISavingsAccount",
            "IYield",
            "IERC20"
        ],
        [
            "TwitterVerifier",
            "IVerification"
        ]
    ],
    "new_contract": "contract PooledCreditLine is ReentrancyGuardUpgradeable, OwnableUpgradeable, IPooledCreditLine {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    //-------------------------------- Constants start --------------------------------//\n\n    /*\n     * @notice number of seconds in an year\n     */\n    uint256 internal constant YEAR_IN_SECONDS = 365 days;\n\n    /*\n     * @notice Factor to multiply variables to maintain precision\n     */\n    uint256 public constant SCALING_FACTOR = 1e18;\n\n    /**\n     * @notice address of lender pool contract\n     */\n    ILenderPool public immutable LENDER_POOL;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    ISavingsAccount public immutable SAVINGS_ACCOUNT;\n\n    /**\n     * @notice stores the address of price oracle contract\n     **/\n    IPriceOracle public immutable PRICE_ORACLE;\n\n    /**\n     * @notice stores the address of limits manager\n     **/\n    ILimitsManager public immutable LIMITS_MANAGER;\n\n    /**\n     * @notice stores the address of strategy registry contract\n     **/\n    IStrategyRegistry public immutable STRATEGY_REGISTRY;\n\n    /**\n     * @notice address that the borrower for pooled credit line should be verified with\n     **/\n    IVerification public immutable VERIFICATION;\n\n    /**\n     * @notice maximum protocol fee fraction allowed, it is multiplied by SCALING_FACTOR\n     */\n    uint256 public immutable MAXIMUM_PROTOCOL_FEE_FRACTION;\n\n    //-------------------------------- Constants end --------------------------------//\n\n    //-------------------------------- Global vars starts --------------------------------//\n    /**\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by SCALING_FACTOR\n     **/\n    uint256 public protocolFeeFraction;\n\n    /**\n     * @notice address where protocol fee is collected\n     **/\n    address public protocolFeeCollector;\n\n    //-------------------------------- Global vars end --------------------------------//\n\n    //-------------------------------- CreditLine state starts --------------------------------//\n\n    /**\n     * @notice counter that tracks the number of pooled credit lines created\n     * @dev used to create unique identifier for pooled credit lines\n     **/\n    uint256 public pooledCreditLineCounter;\n\n    /**\n     * @notice stores the collateral shares in a pooled credit line per collateral strategy\n     * @dev id => collateralShares\n     **/\n    mapping(uint256 => uint256) public depositedCollateralInShares;\n\n    /**\n     * @notice stores the variables to maintain a pooled credit line\n     **/\n    mapping(uint256 => PooledCreditLineVariables) public pooledCreditLineVariables;\n\n    /**\n     * @notice stores the constants related to a pooled credit line\n     **/\n    mapping(uint256 => PooledCreditLineConstants) public pooledCreditLineConstants;\n\n    //-------------------------------- CreditLine State ends --------------------------------//\n\n    //-------------------------------- Modifiers starts --------------------------------//\n\n    /**\n     * @dev checks if called by pooled credit Line Borrower\n     * @param _id identifier for the pooled credit line\n     **/\n    modifier onlyCreditLineBorrower(uint256 _id) {\n        require(pooledCreditLineConstants[_id].borrower == msg.sender, 'PCL:OCLB1');\n        _;\n    }\n\n    /**\n     * @dev checks if called by credit Line Lender Pool\n     **/\n    modifier onlyLenderPool() {\n        require(address(LENDER_POOL) == msg.sender, 'PCL:OLP1');\n        _;\n    }\n\n    //-------------------------------- Modifiers end --------------------------------//\n\n    //-------------------------------- Events start --------------------------------//\n\n    //--------------------------- Global variable update events start ---------------------------//\n\n    /**\n     * @notice emitted when fee that protocol charges for pooled credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     */\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /**\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    //--------------------------- Global variable update events end ---------------------------//\n\n    //--------------------------- CreditLine state events start ---------------------------//\n\n    /**\n     * @notice emitted when a collateral is deposited into pooled credit line\n     * @param id identifier for the pooled credit line\n     * @param shares amount of shares of collateral deposited\n     */\n    event CollateralSharesDeposited(uint256 indexed id, uint256 shares);\n\n    /**\n     * @notice emitted when collateral is withdrawn from pooled credit line\n     * @param id identifier for the pooled credit line\n     * @param shares amount of shares of collateral withdrawn\n     */\n    event CollateralSharesWithdrawn(uint256 indexed id, uint256 shares);\n\n    /**\n     * @notice emitted when a request for new pooled credit line is placed\n     * @param id identifier for the pooled credit line\n     * @param borrower address of the borrower for credit line\n     * @param borrowerVerifier address of the verifier with which borrower is verified\n     */\n    event PooledCreditLineRequested(uint256 indexed id, address indexed borrower, address indexed borrowerVerifier);\n\n    /**\n     * @notice emitted when a pooled credit line is liquidated\n     * @param id identifier for the pooled credit line\n     * @param shares amount of shares of collateral used for liquidation\n     */\n    event PooledCreditLineLiquidated(uint256 indexed id, uint256 shares);\n\n    /**\n     * @notice emitted when tokens are borrowed from pooled credit line\n     * @param id identifier for the pooled credit line\n     * @param borrowShares amount of shares of tokens borrowed\n     */\n    event BorrowedFromPooledCreditLine(uint256 indexed id, uint256 borrowShares);\n\n    /**\n     * @notice Emitted when pooled credit line is accepted\n     * @param id identifier for the pooled credit line\n     * @param amount total amount of tokens lent to pooled credit line\n     */\n    event PooledCreditLineAccepted(uint256 indexed id, uint256 amount);\n\n    /**\n     * @notice emitted when the pooled credit line is partially repaid\n     * @param id identifier for the pooled credit line\n     * @param repayer address of the repayer\n     * @param repayAmount amount repaid\n     */\n    event PartialPooledCreditLineRepaid(uint256 indexed id, address indexed repayer, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the pooled credit line is completely repaid\n     * @param id identifier for the pooled credit line\n     * @param repayer address of the repayer\n     * @param repayAmount amount repaid\n     */\n    event CompletePooledCreditLineRepaid(uint256 indexed id, address indexed repayer, uint256 repayAmount);\n\n    /**\n     * @notice emitted when the pooled credit line is closed by the borrower\n     * @param id identifier for the pooled credit line\n     */\n    event PooledCreditLineClosed(uint256 indexed id);\n\n    /**\n     * @notice emitted when the pooled credit line is cancelled while in REQUESTED state\n     * @param id identifier for the pooled credit line\n     * @param reason identifier which specifies the reason for which PCL was cancelled\n     */\n    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);\n\n    /**\n     * @notice emitted when the pooled credit line is terminated by owner\n     * @param id identifier for the pooled credit line\n     */\n    event PooledCreditLineTerminated(uint256 indexed id);\n\n    //--------------------------- CreditLine state events end ---------------------------//\n\n    //-------------------------------- Events end --------------------------------//\n\n    //-------------------------------- Global var update code start --------------------------------//\n\n    /**\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFeeFraction fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFeeFraction) external onlyOwner {\n        require(protocolFeeFraction != _protocolFeeFraction, 'PCL:UPFF1');\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFeeFraction) private {\n        require(_protocolFeeFraction <= MAXIMUM_PROTOCOL_FEE_FRACTION, 'PCL:IUPFF1');\n        protocolFeeFraction = _protocolFeeFraction;\n        emit ProtocolFeeFractionUpdated(_protocolFeeFraction);\n    }\n\n    /**\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        require(protocolFeeCollector != _protocolFeeCollector, 'PCL:UPFC1');\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) private {\n        require(_protocolFeeCollector != address(0), 'PCL:IUPFC1');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    //-------------------------------- Global var update code end --------------------------------//\n\n    //-------------------------------- Initialize code start --------------------------------//\n\n    /**\n     * @notice constructor to initialize immutables\n     * @param _lenderPool address of lenderPool contract\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _verification address of the verification contract\n     * @param _limitsManager address of the _limitsManager contract\n     * @param _maximumProtocolFeeFraction the maximum protocol fee fraction allowed\n     */\n    constructor(\n        address _lenderPool,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _verification,\n        address _limitsManager,\n        uint256 _maximumProtocolFeeFraction\n    ) {\n        require(_lenderPool != address(0), 'PCL:CON1');\n        require(_priceOracle != address(0), 'PCL:CON2');\n        require(_savingsAccount != address(0), 'PCL:CON3');\n        require(_strategyRegistry != address(0), 'PCL:CON4');\n        require(_verification != address(0), 'PCL:CON5');\n        require(_limitsManager != address(0), 'PCL:CON6');\n        LENDER_POOL = ILenderPool(_lenderPool);\n        PRICE_ORACLE = IPriceOracle(_priceOracle);\n        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);\n        STRATEGY_REGISTRY = IStrategyRegistry(_strategyRegistry);\n        VERIFICATION = IVerification(_verification);\n        LIMITS_MANAGER = ILimitsManager(_limitsManager);\n        MAXIMUM_PROTOCOL_FEE_FRACTION = _maximumProtocolFeeFraction;\n    }\n\n    /**\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol (multiplied by SCALING_FACTOR)\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     */\n    function initialize(\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    //-------------------------------- Initialize code end --------------------------------//\n\n    //-------------------------------- CreditLine creation code start --------------------------------//\n\n    /**\n     * @notice used to request a pooled credit line by a borrower\n     * @param _request Credit line creation request\n     * @return identifier for the pooled credit line\n     */\n    function request(Request calldata _request) external nonReentrant returns (uint256) {\n        require(VERIFICATION.isUser(msg.sender, _request.borrowerVerifier), 'PCL:R1');\n        require(_request.borrowAsset != _request.collateralAsset, 'PCL:R2');\n        require(PRICE_ORACLE.doesFeedExist(_request.borrowAsset, _request.collateralAsset), 'PCL:R3');\n        require(_request.borrowAsset != address(0) && _request.collateralAsset != address(0), 'PCL:R4');\n        require(STRATEGY_REGISTRY.registry(_request.borrowAssetStrategy) != 0, 'PCL:R5');\n        require(STRATEGY_REGISTRY.registry(_request.collateralAssetStrategy) != 0, 'PCL:R6');\n        LIMITS_MANAGER.limitBorrowedInUSDC(_request.borrowAsset, _request.borrowLimit, _request.minBorrowAmount);\n        require(LIMITS_MANAGER.isWithinLimits(_request.borrowRate, LIMITS_MANAGER.getBorrowRateLimits()), 'PCL:R7');\n        // collateral ratio = 0 is a special case which is allowed\n        if (_request.collateralRatio != 0) {\n            require(LIMITS_MANAGER.isWithinLimits(_request.collateralRatio, LIMITS_MANAGER.getIdealCollateralRatioLimits()), 'PCL:R8');\n        }\n        require(LIMITS_MANAGER.isWithinLimits(_request.collectionPeriod, LIMITS_MANAGER.getCollectionPeriodLimits()), 'PCL:R9');\n        require(LIMITS_MANAGER.isWithinLimits(_request.duration, LIMITS_MANAGER.getDurationLimits()), 'PCL:R10');\n        require(LIMITS_MANAGER.isWithinLimits(_request.defaultGracePeriod, LIMITS_MANAGER.getDefaultGracePeriodLimits()), 'PCL:R11');\n        require(LIMITS_MANAGER.isWithinLimits(_request.gracePenaltyRate, LIMITS_MANAGER.getGracePenaltyRateLimits()), 'PCL:R12');\n\n        require(VERIFICATION.verifiers(_request.lenderVerifier), 'PCL:R13');\n\n        uint256 _id = _createRequest(_request);\n\n        _notifyRequest(\n            _id,\n            _request.lenderVerifier,\n            _request.borrowAsset,\n            _request.borrowAssetStrategy,\n            _request.borrowLimit,\n            _request.minBorrowAmount,\n            _request.collectionPeriod,\n            _request.areTokensTransferable\n        );\n        emit PooledCreditLineRequested(_id, msg.sender, _request.borrowerVerifier);\n        return _id;\n    }\n\n    function _createRequest(Request calldata _request) private returns (uint256) {\n        uint256 _id = ++pooledCreditLineCounter;\n        pooledCreditLineVariables[_id].status = PooledCreditLineStatus.REQUESTED;\n\n        PooledCreditLineConstants storage _clc = pooledCreditLineConstants[_id];\n        _clc.borrower = msg.sender;\n        _clc.borrowLimit = _request.borrowLimit;\n        _clc.idealCollateralRatio = _request.collateralRatio;\n        _clc.borrowRate = _request.borrowRate;\n        _clc.borrowAsset = _request.borrowAsset;\n        _clc.collateralAsset = _request.collateralAsset;\n        _clc.collateralAssetStrategy = _request.collateralAssetStrategy;\n        uint256 _endsAt = block.timestamp.add(_request.collectionPeriod).add(_request.duration);\n        _clc.startsAt = block.timestamp.add(_request.collectionPeriod);\n        _clc.endsAt = _endsAt;\n        _clc.defaultsAt = _endsAt.add(_request.defaultGracePeriod);\n        _clc.gracePenaltyRate = _request.gracePenaltyRate;\n        _clc.borrowAssetStrategy = _request.borrowAssetStrategy;\n        return _id;\n    }\n\n    /*\n     * @notice callback method for LenderPool contract to set the PCL variables\n     */\n    function _notifyRequest(\n        uint256 _id,\n        address _lenderVerifier,\n        address _borrowAsset,\n        address _borrowAssetStrategy,\n        uint256 _borrowLimit,\n        uint256 _minBorrowedAmount,\n        uint256 _collectionPeriod,\n        bool _areTokensTransferable\n    ) private {\n        LENDER_POOL.create(\n            _id,\n            _lenderVerifier,\n            _borrowAsset,\n            _borrowAssetStrategy,\n            _borrowLimit,\n            _minBorrowedAmount,\n            _collectionPeriod,\n            _areTokensTransferable\n        );\n    }\n\n    /**\n     * @notice used to accept a pooled credit line\n     * @dev callback from lender pool contract\n     * @param _id identifier for the pooled credit line\n     * @param _amount Borrow Limit\n     * @param _by user who accepted the PCL\n     */\n    function accept(\n        uint256 _id,\n        uint256 _amount,\n        address _by\n    ) external override nonReentrant onlyLenderPool {\n        require(pooledCreditLineVariables[_id].status == PooledCreditLineStatus.REQUESTED, 'PCL:A1');\n        require(_by == pooledCreditLineConstants[_id].borrower, 'PCL:A2');\n        pooledCreditLineVariables[_id].status = PooledCreditLineStatus.ACTIVE;\n        pooledCreditLineConstants[_id].borrowLimit = SafeCast.toUint128(_amount);\n        emit PooledCreditLineAccepted(_id, _amount);\n    }\n\n    //-------------------------------- CreditLine creation code end --------------------------------//\n\n    //-------------------------------- Collateral management start --------------------------------//\n\n    /**\n     * @notice used to deposit collateral into the pooled credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract\n     * @param _id identifier for the pooled credit line\n     * @param _amount amount of collateral being deposited\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount\n                                  otherwise direct from collateral token contract\n     */\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external nonReentrant {\n        require(_amount != 0, 'PCL:DC1');\n        PooledCreditLineStatus _status = getStatusAndUpdate(_id);\n        require(_status == PooledCreditLineStatus.ACTIVE || _status == PooledCreditLineStatus.EXPIRED, 'PCL:DC2');\n        address _collateralAsset = pooledCreditLineConstants[_id].collateralAsset;\n        address _strategy = pooledCreditLineConstants[_id].collateralAssetStrategy;\n        uint256 _sharesDeposited;\n\n        if (_fromSavingsAccount) {\n            _sharesDeposited = SAVINGS_ACCOUNT.transferFrom(_collateralAsset, _strategy, msg.sender, address(this), _amount);\n        } else {\n            IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n            IERC20(_collateralAsset).safeApprove(_strategy, _amount);\n\n            _sharesDeposited = SAVINGS_ACCOUNT.deposit(_collateralAsset, _strategy, address(this), _amount);\n        }\n        depositedCollateralInShares[_id] = depositedCollateralInShares[_id].add(_sharesDeposited);\n\n        emit CollateralSharesDeposited(_id, _sharesDeposited);\n    }\n\n    /**\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the pooled credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred to savingsAccount, else to borrower address directly\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount <= _withdrawableCollateral, 'PCL:WC1');\n        require(_amount != 0, 'PCL:WC2');\n        (, uint256 _amountInShares) = _transferCollateral(_id, pooledCreditLineConstants[_id].collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralSharesWithdrawn(_id, _amountInShares);\n    }\n\n    /**\n     * @notice used to withdraw all the permissible collateral as per the current collateralRatio\n     * @dev if the withdrawable collateral amount is non-zero the transaction will pass\n     * @param _id identifier for the pooled credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount\n                                otherwise direct from collateral token contract\n     */\n\n    function withdrawAllCollateral(uint256 _id, bool _toSavingsAccount) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _collateralWithdrawn = _withdrawAllCollateral(_id, _toSavingsAccount);\n        require(_collateralWithdrawn != 0, 'PCL:WAC1');\n    }\n\n    function _withdrawAllCollateral(uint256 _id, bool _toSavingsAccount) private returns (uint256 _collateralWithdrawn) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        if (_withdrawableCollateral == 0) {\n            return 0;\n        }\n        (, uint256 _amountInShares) = _transferCollateral(\n            _id,\n            pooledCreditLineConstants[_id].collateralAsset,\n            _withdrawableCollateral,\n            _toSavingsAccount\n        );\n        emit CollateralSharesWithdrawn(_id, _amountInShares);\n        return _withdrawableCollateral;\n    }\n\n    /**\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the pooled credit line\n     * @return total collateral withdrawable by borrower\n     */\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        PooledCreditLineStatus _status = getStatusAndUpdate(_id);\n        if (\n            _status == PooledCreditLineStatus.EXPIRED ||\n            _status == PooledCreditLineStatus.CANCELLED ||\n            _status == PooledCreditLineStatus.REQUESTED\n        ) {\n            return 0;\n        }\n\n        uint256 _totalCollateral = calculateTotalCollateralTokens(_id);\n\n        if (_status == PooledCreditLineStatus.LIQUIDATED || _status == PooledCreditLineStatus.CLOSED) {\n            return _totalCollateral;\n        }\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(\n            pooledCreditLineConstants[_id].collateralAsset,\n            pooledCreditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n        uint256 _collateralRatio = pooledCreditLineConstants[_id].idealCollateralRatio;\n\n        // _collateralNeeded is the number of collateral tokens needed to maintain the _collateralRatio\n        uint256 _collateralNeeded = _currentDebt.mul(_collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(SCALING_FACTOR);\n\n        if (_collateralNeeded >= _totalCollateral) {\n            return 0;\n        }\n        return _totalCollateral.sub(_collateralNeeded);\n    }\n\n    /*\n    * @notice this method transfers the collateral tokens to the msg.sender and reduces the depositedCollateralInShares\n    *         value to maintain the amount of collateral tokens deposited in the PCL\n    * @param _id the id of the pcl\n    * @param _asset the collateral asset\n    * @param _amountInTokens the amount to be transferred\n    * @param _toSavingsAccount if the true the amount if transferred to the savings account of the msg.sender\n             else the tokens are directly transferred.\n    */\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) private returns (uint256, uint256) {\n        address _strategy = pooledCreditLineConstants[_id].collateralAssetStrategy;\n        uint256 _amountInShares = IYield(_strategy).getSharesForTokens(_amountInTokens, _asset);\n        uint256 _amountReceived;\n        if (_amountInShares == 0) return (0, 0);\n\n        depositedCollateralInShares[_id] = depositedCollateralInShares[_id].sub(_amountInShares, 'PCL:ITC1');\n\n        if (_toSavingsAccount) {\n            _amountReceived = SAVINGS_ACCOUNT.transferShares(_asset, _strategy, msg.sender, _amountInShares);\n        } else {\n            _amountReceived = SAVINGS_ACCOUNT.withdrawShares(_asset, _strategy, msg.sender, _amountInShares, false);\n        }\n\n        return (_amountReceived, _amountInShares);\n    }\n\n    /**\n     * @notice used to calculate the total collateral tokens held in the pcl savings account\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _id identifier for the pooled credit line\n     * @return _amount total collateral tokens deposited into the pooled credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256) {\n        address _strategy = pooledCreditLineConstants[_id].collateralAssetStrategy;\n        require(_strategy != address(0), 'PCL:CTCT1');\n        address _collateralAsset = pooledCreditLineConstants[_id].collateralAsset;\n\n        uint256 _collateralShares = depositedCollateralInShares[_id];\n        uint256 _collateral = IYield(_strategy).getTokensForShares(_collateralShares, _collateralAsset);\n\n        return _collateral;\n    }\n\n    /*\n    * @notice this method returns the number of collateral tokens the borrower has to deposit to be able\n              to borrow the given _borrowTokenAmount. the return value is calculated based on the idealCollateralRatio\n    */\n    function getRequiredCollateral(uint256 _id, uint256 _borrowTokenAmount) external view returns (uint256) {\n        address _collateralAsset = pooledCreditLineConstants[_id].collateralAsset;\n        address _borrowAsset = pooledCreditLineConstants[_id].borrowAsset;\n\n        uint256 _collateral = _equivalentCollateral(_collateralAsset, _borrowAsset, _borrowTokenAmount);\n\n        return _collateral.mul(pooledCreditLineConstants[_id].idealCollateralRatio).div(SCALING_FACTOR);\n    }\n\n    //-------------------------------- Collateral management end --------------------------------//\n\n    //-------------------------------- Borrow code start --------------------------------//\n\n    /**\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is\n            min(amount of borrow asset left in the pcl, amount that is borrowable based on ideal collateral ratio)\n     * @param _id identifier for the pooled credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external nonReentrant onlyCreditLineBorrower(_id) {\n        _borrow(_id, _amount);\n    }\n\n    function _borrow(uint256 _id, uint256 _amount) private {\n        require(_amount != 0, 'PCL:IB1');\n        require(block.timestamp >= pooledCreditLineConstants[_id].startsAt, 'PCL:IB2');\n        // calculateBorrowableAmount is 0, hence statement reverts for all states except ACTIVE\n        require(_amount <= calculateBorrowableAmount(_id), 'PCL:IB3');\n\n        address _borrowAsset = pooledCreditLineConstants[_id].borrowAsset;\n\n        uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n\n        uint256 _sharesWithdrawn = _withdrawBorrowAmount(_borrowAsset, pooledCreditLineConstants[_id].borrowAssetStrategy, _amount);\n        LENDER_POOL.borrowed(_id, _sharesWithdrawn);\n        uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n\n        uint256 _borrowedAmount = _balanceAfter.sub(_balanceBefore);\n        _updateStateOnPrincipalChange(_id, pooledCreditLineVariables[_id].principal.add(_borrowedAmount));\n\n        // protocol fee is collected everytime amount if borrowed\n        uint256 _protocolFee = _borrowedAmount.mul(protocolFeeFraction).div(SCALING_FACTOR);\n        _borrowedAmount = _borrowedAmount.sub(_protocolFee);\n\n        IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n        IERC20(_borrowAsset).safeTransfer(msg.sender, _borrowedAmount);\n        emit BorrowedFromPooledCreditLine(_id, _sharesWithdrawn);\n    }\n\n    /**\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the pooled credit line\n     * @return amount that can be borrowed from the pooled credit line\n     */\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        PooledCreditLineStatus _status = getStatusAndUpdate(_id);\n        if (_status != PooledCreditLineStatus.ACTIVE) {\n            return 0;\n        }\n        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(\n            pooledCreditLineConstants[_id].collateralAsset,\n            pooledCreditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateral = calculateTotalCollateralTokens(_id);\n\n        // current debt includes the principal amount + unpaid interest\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralRatio = pooledCreditLineConstants[_id].idealCollateralRatio;\n        uint256 _maxPossible = type(uint256).max;\n        if (_collateralRatio != 0) {\n            // _maxPossible is the amount of borrow tokens which can be borrowed based on the _collateralRatio\n            _maxPossible = _totalCollateral.mul(_ratioOfPrices).div(_collateralRatio).mul(SCALING_FACTOR).div(10**_decimals);\n        }\n\n        uint256 _borrowLimit = pooledCreditLineConstants[_id].borrowLimit;\n        uint256 _principal = pooledCreditLineVariables[_id].principal;\n\n        // if the _maxPossible amount is less than the _currentDebt this means that current collateral ratio is less\n        // then the idealCollateralRatio. This PCL can be liquidated now and the borrower has to deposit more collateral\n        // to save it from liquidation\n        if (_maxPossible <= _currentDebt) return 0;\n\n        // using direct subtraction for _maxPossible because we have a check above for it being greater than _currentDebt\n        return Math.min(_borrowLimit.sub(_principal), _maxPossible - _currentDebt);\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        address _strategy,\n        uint256 _amountInTokens\n    ) private returns (uint256) {\n        uint256 _shares = IYield(_strategy).getSharesForTokens(_amountInTokens, _asset);\n        require(_shares != 0, 'PCL:IWBA1');\n        SAVINGS_ACCOUNT.withdrawFrom(_asset, _strategy, address(LENDER_POOL), address(this), _amountInTokens, false);\n        return _shares;\n    }\n\n    //-------------------------------- Borrow code end --------------------------------//\n\n    //-------------------------------- Repayments code start --------------------------------//\n\n    /**\n     * @notice used to repay interest and principal to pooled credit line. Interest has to be repaid before\n               repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the pooled credit line\n     * @param _amount amount being repaid\n     */\n    function repay(uint256 _id, uint256 _amount) external nonReentrant {\n        require(_amount != 0, 'PCL:REP1');\n        PooledCreditLineStatus currentStatus = getStatusAndUpdate(_id);\n        require(currentStatus == PooledCreditLineStatus.ACTIVE || currentStatus == PooledCreditLineStatus.EXPIRED, 'PCL:REP2');\n\n        uint256 _currentPrincipal = pooledCreditLineVariables[_id].principal;\n        uint256 _totalInterestAccrued = calculateInterestAccrued(_id);\n        uint256 _interestToPay = _totalInterestAccrued.sub(pooledCreditLineVariables[_id].totalInterestRepaid);\n        uint256 _currentDebt = (_currentPrincipal).add(_interestToPay);\n\n        require(_currentDebt != 0, 'PCL:REP3');\n\n        // in case the interest to pay is 0 (expect when interest rate is 0) no repayment can happen\n        // this is because it can be then possible to borrow small amounts for short period of time\n        // then pay it back with 0 interest. to be safe we allow repayment when there is some _interestToPay\n        // this condition also stops flash loans\n        if (pooledCreditLineConstants[_id].borrowRate != 0) {\n            require(_interestToPay != 0, 'PCL:REP4');\n        }\n\n        if (_amount >= _currentDebt) {\n            _amount = _currentDebt;\n            emit CompletePooledCreditLineRepaid(_id, msg.sender, _amount);\n        } else {\n            emit PartialPooledCreditLineRepaid(_id, msg.sender, _amount);\n        }\n\n        uint256 _principalPaid;\n        if (_amount > _interestToPay) {\n            _principalPaid = _amount.sub(_interestToPay);\n            pooledCreditLineVariables[_id].principal = _currentPrincipal.sub(_principalPaid);\n            pooledCreditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            pooledCreditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            pooledCreditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n        } else {\n            pooledCreditLineVariables[_id].totalInterestRepaid = pooledCreditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        uint256 _interestPaid = _amount.sub(_principalPaid);\n        uint256 _repaidInterestShares = IYield(pooledCreditLineConstants[_id].borrowAssetStrategy).getSharesForTokens(\n            _interestPaid,\n            pooledCreditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _repaidShares = _repay(_id, _amount);\n        LENDER_POOL.repaid(_id, _repaidShares, _repaidInterestShares);\n\n        if ((pooledCreditLineVariables[_id].principal == 0) && (currentStatus == PooledCreditLineStatus.EXPIRED)) {\n            pooledCreditLineVariables[_id].status = PooledCreditLineStatus.CLOSED;\n            emit PooledCreditLineClosed(_id);\n        }\n    }\n\n    function _repay(uint256 _id, uint256 _amount) private returns (uint256) {\n        address _strategy = pooledCreditLineConstants[_id].borrowAssetStrategy;\n        address _borrowAsset = pooledCreditLineConstants[_id].borrowAsset;\n        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(_borrowAsset).safeApprove(_strategy, _amount);\n        uint256 _sharesReceived = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(LENDER_POOL), _amount);\n        return _sharesReceived;\n    }\n\n    /**\n     * @dev Used to calculate the total interest accrued in the pcl since start till now\n     * @param _id identifier for the pooled credit line\n     * @return total interest accrued in the pcl since start till now\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = pooledCreditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _endTime = pooledCreditLineConstants[_id].endsAt;\n        uint256 _penaltyRate = pooledCreditLineConstants[_id].gracePenaltyRate;\n        uint256 _principal = pooledCreditLineVariables[_id].principal;\n        uint256 _borrowRate = pooledCreditLineConstants[_id].borrowRate;\n        uint256 _penaltyInterestScaled;\n        if (_lastPrincipalUpdateTime <= _endTime && block.timestamp > _endTime) {\n            // this condition means that _lastPrincipalUpdateTime is older than the end time of the PCL\n            // so the penalty rate is applicable only on the time from the end time till now.\n            _penaltyInterestScaled = _calculateInterestScaled(_principal, _penaltyRate, block.timestamp.sub(_endTime));\n        } else if (_lastPrincipalUpdateTime > _endTime) {\n            // this condition means that the _lastPrincipalUpdateTime is beyond end time of the PCL\n            // so the penalty interest can be applied from _lastPrincipalUpdateTime till now.\n            _penaltyInterestScaled = _calculateInterestScaled(_principal, _penaltyRate, block.timestamp.sub(_lastPrincipalUpdateTime));\n        }\n        uint256 _interestAccruedScaled = _calculateInterestScaled(_principal, _borrowRate, _timeElapsed);\n        _interestAccruedScaled = _interestAccruedScaled.add(_penaltyInterestScaled);\n        // scale down interestAccured and take ceiling for the interest as it ensures that borrower can't repay frequently to skip interest\n        uint256 _interestAccrued = _divAndCeil(_interestAccruedScaled, SCALING_FACTOR);\n        return _interestAccrued.add(pooledCreditLineVariables[_id].interestAccruedTillLastPrincipalUpdate);\n    }\n\n    /**\n     * @dev Used to calculate current debt of borrower against a pooled credit line.\n     * @param _id identifier for the pooled credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (pooledCreditLineVariables[_id].principal).add(_interestAccrued).sub(\n            pooledCreditLineVariables[_id].totalInterestRepaid\n        );\n        return _currentDebt;\n    }\n\n    //-------------------------------- Repayments code end --------------------------------//\n\n    //-------------------------------- Liquidation code start --------------------------------//\n\n    /**\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev this is a callback from the LenderPool.liquidate\n            the collateral is directly transferred to lenderPool for lenders to withdraw\n     * @param _id identifier for the pooled credit line\n     * @return collateral asset received, amount of collateral asset received\n     */\n    function liquidate(uint256 _id) external override nonReentrant onlyLenderPool returns (address, uint256) {\n        PooledCreditLineStatus currentStatus = getStatusAndUpdate(_id);\n        require(pooledCreditLineVariables[_id].principal != 0, 'PCL:L1');\n        require(currentStatus == PooledCreditLineStatus.ACTIVE || currentStatus == PooledCreditLineStatus.EXPIRED, 'PCL:L2');\n\n        address _collateralAsset = pooledCreditLineConstants[_id].collateralAsset;\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio < pooledCreditLineConstants[_id].idealCollateralRatio ||\n                block.timestamp >= pooledCreditLineConstants[_id].defaultsAt,\n            'PCL:L3'\n        );\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n        address _borrowAsset = pooledCreditLineConstants[_id].borrowAsset;\n        uint256 _collateralToLiquidate = _equivalentCollateral(_collateralAsset, _borrowAsset, _currentDebt);\n        uint256 _totalCollateral = calculateTotalCollateralTokens(_id);\n        if (_collateralToLiquidate > _totalCollateral) {\n            _collateralToLiquidate = _totalCollateral;\n        }\n\n        pooledCreditLineVariables[_id].status = PooledCreditLineStatus.LIQUIDATED;\n\n        uint256 _collateralReceived;\n        uint256 _collateralInShares;\n        if (_collateralToLiquidate != 0) {\n            (_collateralReceived, _collateralInShares) = _transferCollateral(_id, _collateralAsset, _collateralToLiquidate, false);\n        }\n\n        emit PooledCreditLineLiquidated(_id, _collateralInShares);\n\n        return (_collateralAsset, _collateralReceived);\n    }\n\n    /**\n     * @notice used to calculate collateral tokens equivalent to _borrowTokenAmount\n     * @param _id identifier for the pooled credit line\n     * @param _borrowTokenAmount amount of borrow tokens for which equivalent collateral is calculated\n     * @return collateral tokens equivalent to _borrowTokenAmount\n     */\n    function getEquivalentCollateralTokens(uint256 _id, uint256 _borrowTokenAmount) external view returns (uint256) {\n        address _collateralAsset = pooledCreditLineConstants[_id].collateralAsset;\n        require(_collateralAsset != address(0), 'PCL:CTTL1');\n        address _borrowAsset = pooledCreditLineConstants[_id].borrowAsset;\n\n        return _equivalentCollateral(_collateralAsset, _borrowAsset, _borrowTokenAmount);\n    }\n\n    //-------------------------------- Liquidation code end --------------------------------//\n\n    //-------------------------------- close/cancel code start --------------------------------//\n\n    /**\n     * @notice used to close pooled credit line. only callable by the borrower\n     * @dev this will also withdraw all the collateral and transfer it to the borrower\n     * @param _id identifier for the pooled credit line\n     */\n    function close(uint256 _id) external nonReentrant onlyCreditLineBorrower(_id) {\n        PooledCreditLineStatus _status = pooledCreditLineVariables[_id].status;\n        require(_status == PooledCreditLineStatus.ACTIVE || _status == PooledCreditLineStatus.EXPIRED, 'PCL:C1');\n        require(pooledCreditLineVariables[_id].principal == 0, 'PCL:C2');\n        pooledCreditLineVariables[_id].status = PooledCreditLineStatus.CLOSED;\n        _withdrawAllCollateral(_id, false);\n        emit PooledCreditLineClosed(_id);\n    }\n\n    /**\n     * @notice used to cancel a pooled credit line request. only callable by the borrower\n     * @dev only callable by the borrower in REQUESTED state\n     * @param _id identifier for the pooled credit line\n     */\n    function cancelRequest(uint256 _id) external nonReentrant onlyCreditLineBorrower(_id) {\n        require(pooledCreditLineVariables[_id].status == PooledCreditLineStatus.REQUESTED, 'PCL:CR1');\n        require(block.timestamp < pooledCreditLineConstants[_id].startsAt, 'PCL:CR2');\n        LENDER_POOL.requestCancelled(_id);\n        _cancelRequest(_id, CancellationStatus.BORROWER_BEFORE_START);\n    }\n\n    /**\n     * @notice Function invoked when pooled credit line cancelled because of low collection\n     * @dev only LenderPool can invoke\n     * @param _id identifier for the pooled credit line\n     */\n    function cancelRequestOnLowCollection(uint256 _id) external override nonReentrant onlyLenderPool {\n        _cancelRequest(_id, CancellationStatus.LENDER_LOW_COLLECTION);\n    }\n\n    /**\n     * @notice Function invoked when pooled credit line cancelled because it wasn't started even after end time\n     * @dev only LenderPool can invoke\n     * @param _id identifier for the pooled credit line\n     */\n    function cancelRequestOnRequestedStateAtEnd(uint256 _id) external override nonReentrant onlyLenderPool {\n        _cancelRequest(_id, CancellationStatus.LENDER_NOT_STARTED_AT_END);\n    }\n\n    function _cancelRequest(uint256 _id, CancellationStatus _reason) private {\n        delete pooledCreditLineVariables[_id];\n        delete pooledCreditLineConstants[_id];\n        pooledCreditLineVariables[_id].status = PooledCreditLineStatus.CANCELLED;\n        emit PooledCreditLineCancelled(_id, _reason);\n    }\n\n    /**\n     * @notice Function invoked when pooled credit line is terminated by admin\n     * @dev only owner can invoke\n     * @param _id identifier for the pooled credit line\n     */\n    function terminate(uint256 _id) external nonReentrant onlyOwner {\n        // This function reverts in `NOT_CREATED` or `CANCELLED` state and hence can't terminate\n        uint256 _allCollateral = calculateTotalCollateralTokens(_id);\n        // transfers all the collateral held to the owner\n        if (_allCollateral != 0) {\n            _transferCollateral(_id, pooledCreditLineConstants[_id].collateralAsset, _allCollateral, false);\n        }\n        // callback to lender poll which transfers all the assets held in lender pool to the admin\n        LENDER_POOL.terminate(_id, msg.sender);\n        delete pooledCreditLineVariables[_id];\n        delete pooledCreditLineConstants[_id];\n        emit PooledCreditLineTerminated(_id);\n    }\n\n    //-------------------------------- close/cancel code end --------------------------------//\n\n    //-------------------------------- Utilities code start --------------------------------//\n\n    /**\n     * @notice used to update(if required) and get the status of pooled credit line\n     * @dev keeps track of status of the PCL\n     * @param _id identifier for the pooled credit line\n     * @return status of pooled credit line\n     */\n    function getStatusAndUpdate(uint256 _id) public override returns (PooledCreditLineStatus) {\n        PooledCreditLineStatus currentStatus = pooledCreditLineVariables[_id].status;\n        if (currentStatus == PooledCreditLineStatus.ACTIVE && pooledCreditLineConstants[_id].endsAt <= block.timestamp) {\n            if (pooledCreditLineVariables[_id].principal != 0) {\n                currentStatus = PooledCreditLineStatus.EXPIRED;\n            } else {\n                currentStatus = PooledCreditLineStatus.CLOSED;\n            }\n            pooledCreditLineVariables[_id].status = currentStatus;\n        }\n        return currentStatus;\n    }\n\n    /**\n     * @notice Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which pooled Credit Line is approved\n     * @param _timeElapsed time in seconds to calculate interest for\n     * @return interest per second scaled by SCALING_FACTOR for the given parameters\n     */\n    function _calculateInterestScaled(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) private pure returns (uint256) {\n        return (_principal.mul(_borrowRate).mul(_timeElapsed).div(YEAR_IN_SECONDS));\n    }\n\n    /*\n     * @notice used to update the pcl variables on borrowing\n     */\n    function _updateStateOnPrincipalChange(uint256 _id, uint256 _updatedPrincipal) private {\n        uint256 _totalInterestAccrued = calculateInterestAccrued(_id);\n        pooledCreditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n        pooledCreditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n        pooledCreditLineVariables[_id].principal = _updatedPrincipal;\n    }\n\n    /**\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the pooled credit line\n     * @return collateral ratio multiplied by SCALING_FACTOR to retain precision\n     */\n    function calculateCurrentCollateralRatio(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(\n            pooledCreditLineConstants[_id].collateralAsset,\n            pooledCreditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n        uint256 _currentCollateralRatio = type(uint256).max;\n        if (_currentDebt != 0) {\n            _currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(_currentDebt).mul(SCALING_FACTOR).div(\n                10**_decimals\n            );\n        }\n\n        return _currentCollateralRatio;\n    }\n\n    function _equivalentCollateral(\n        address _collateralAsset,\n        address _borrowAsset,\n        uint256 _borrowTokenAmount\n    ) private view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(_collateralAsset, _borrowAsset);\n        uint256 _collateralTokenAmount = (_borrowTokenAmount.mul(10**_decimals).div(_ratioOfPrices));\n\n        return _collateralTokenAmount;\n    }\n\n    function _divAndCeil(uint256 _num, uint256 _denom) private pure returns (uint256) {\n        uint256 _divResult = _num.div(_denom);\n        if (_divResult * _denom != _num) {\n            _divResult++;\n        }\n        return _divResult;\n    }\n\n    //-------------------------------- Utilities code end --------------------------------//\n\n    //-------------------------------- getters start --------------------------------//\n\n    /**\n     * @notice used to get the principal borrowed in a pooled credit line\n     * @param _id identifier for the pooled credit line\n     * @return Returns principal for the given pooled credit line\n     */\n    function getPrincipal(uint256 _id) external view override returns (uint256) {\n        return pooledCreditLineVariables[_id].principal;\n    }\n\n    /**\n     * @notice used to get the borrower address in a pooled credit line\n     * @param _id identifier for the pooled credit line\n     * @return Returns borrower address for the given pooled credit line\n     */\n    function getBorrowerAddress(uint256 _id) external view override returns (address) {\n        return pooledCreditLineConstants[_id].borrower;\n    }\n\n    /**\n     * @notice used to get the endAt time in a pooled credit line\n     * @param _id identifier for the pooled credit line\n     * @return Returns ends at time for the given pooled credit line\n     */\n    function getEndsAt(uint256 _id) external view override returns (uint256) {\n        return pooledCreditLineConstants[_id].endsAt;\n    }\n\n    //-------------------------------- getters end --------------------------------//\n}\ncontract TwitterVerifier is Initializable, IVerifier, OwnableUpgradeable, EIP712Upgradeable {\n    //-------------------------------- Constants start --------------------------------/\n\n    /**\n     * @notice stores the verification contract instance\n     */\n    IVerification public immutable VERIFICATION;\n\n    //-------------------------------- Constants end --------------------------------/\n\n    /**\n     * @notice Structure for the user data\n     */\n    struct UserStructData {\n        string twitterId;\n        string tweetId;\n    }\n\n    /**\n     * @notice stores the user metadata against their address\n     */\n    mapping(address => UserStructData) public userData;\n    /**\n     * @notice stores the user address against twitterId\n     */\n    mapping(string => address) public twitterIdMap;\n    /**\n     * @notice stores the user address against tweetId\n     */\n    mapping(string => address) public usedTweetIds;\n    // Stores the hash of the digest against the address of user who used it\n    mapping(bytes32 => address) private usedDigests;\n    /**\n     * @notice stores the signer address\n     */\n    address public signerAddress;\n    /**\n     * @notice time for which signature by signer is valid\n     */\n    uint256 public signValidity;\n\n    /**\n     * @notice emitted when Signer address is updated\n     * @param signerAddress address of the updated verification contract\n     */\n    event SignerUpdated(address indexed signerAddress);\n    /**\n     * @notice emitted when time for which sig is valid is updated\n     * @param signValidity time to which validity of sign is updated\n     */\n    event SignValidityUpdated(uint256 signValidity);\n\n    /**\n     * @notice constructor\n     * @dev initializes the immutables\n     * @param _verification Verification contract address\n     **/\n    constructor(address _verification) {\n        require(_verification != address(0), 'C1');\n        VERIFICATION = IVerification(_verification);\n    }\n\n    /// @notice Initializes the variables of the contract\n    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy\n    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid\n    /// @param _signerAddress Address of the signer bot verifying users and signing off-chain messages\n    /// @param _signValidity time for which signature is valid\n    /// @param _name name of the verifier (used in domain seperator)\n    /// @param _version version of the verifier (used in domain seperator)\n    function initialize(\n        address _admin,\n        address _signerAddress,\n        uint256 _signValidity,\n        string memory _name,\n        string memory _version\n    ) external initializer {\n        super.__Ownable_init();\n        super.transferOwnership(_admin);\n        _updateSignerAddress(_signerAddress);\n        _updateSignValidity(_signValidity);\n        __EIP712_init(_name, _version);\n    }\n\n    /**\n     * @notice used to register user\n     * @dev Users register themselves using message signed by the admin\n     * @param _v int v\n     * @param _r part signed message hash\n     * @param _s part signed message hash\n     * @param _timestamp timestamp for the signed message\n     * @param _twitterId metadata related to user :  here \"twitterId\"\n     * @param _tweetId metadata related to user :  here \"tweetId\"\n     * @param _isMasterLinked should master address be linked to itself\n     */\n\n    function registerSelf(\n        bool _isMasterLinked,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        string memory _twitterId,\n        string memory _tweetId,\n        uint256 _timestamp\n    ) external {\n        require(bytes(userData[msg.sender].twitterId).length == 0, 'TV:RS1');\n        require(twitterIdMap[_twitterId] == address(0), 'TV:RS2');\n        require(bytes(_twitterId).length != 0, 'TV:RS9');\n        require(bytes(_tweetId).length != 0, 'TV:RS8');\n        require(usedTweetIds[_tweetId] == address(0), 'TV:RS3');\n        require(block.timestamp < _timestamp + signValidity, 'TV:RS4');\n\n        bytes32 digest = keccak256(\n            abi.encode(\n                keccak256('set(string twitterId,string tweetId,address userAddr,uint256 timestamp)'),\n                keccak256(bytes(_twitterId)),\n                keccak256(bytes(_tweetId)),\n                msg.sender,\n                _timestamp\n            )\n        );\n        require(usedDigests[digest] == address(0), 'TV:RS5');\n\n        bytes32 hash = _hashTypedDataV4(digest);\n        address signer = ECDSA.recover(hash, _v, _r, _s);\n\n        require(signer != address(0), 'TV:RS6');\n        require(signer == signerAddress, 'TV:RS7');\n\n        VERIFICATION.registerMasterAddress(msg.sender, _isMasterLinked);\n        userData[msg.sender] = UserStructData(_twitterId, _tweetId);\n        twitterIdMap[_twitterId] = msg.sender;\n        usedTweetIds[_tweetId] = msg.sender;\n        usedDigests[digest] = msg.sender;\n        emit UserRegistered(msg.sender, _isMasterLinked, string(abi.encode(_twitterId, _tweetId)));\n    }\n\n    /**\n     * @notice used to unregister self\n     * @dev users themselves can unregister themself\n     */\n    function unregisterSelf() external {\n        _unregisterUser(msg.sender);\n    }\n\n    /**\n     * @notice used to unregister user\n     * @dev owners can unregister users\n     */\n    function unregisterUser(address _user) external onlyOwner {\n        _unregisterUser(_user);\n    }\n\n    function _unregisterUser(address _user) private {\n        string memory _userdata = userData[_user].twitterId;\n        require(bytes(_userdata).length != 0, 'TV:IUU1');\n        delete twitterIdMap[_userdata];\n        delete userData[_user];\n        VERIFICATION.unregisterMasterAddress(_user, address(this));\n        emit UserUnregistered(_user);\n    }\n\n    /**\n     * @notice used to update signer address\n     * @dev only owner can update\n     * @param _signerAddress address of the verification contract\n     */\n    function updateSignerAddress(address _signerAddress) external onlyOwner {\n        _updateSignerAddress(_signerAddress);\n    }\n\n    function _updateSignerAddress(address _signerAddress) private {\n        require(_signerAddress != signerAddress, 'TV:IUSA1');\n        require(_signerAddress != address(0), 'TV:IUSA2');\n        signerAddress = _signerAddress;\n        emit SignerUpdated(_signerAddress);\n    }\n\n    /**\n     * @notice used to update time for which sign is valid\n     * @dev only owner can update\n     * @param _signValidity time for which sign will be valid\n     */\n    function updateSignValidity(uint256 _signValidity) external onlyOwner {\n        _updateSignValidity(_signValidity);\n    }\n\n    function _updateSignValidity(uint256 _signValidity) private {\n        require(_signValidity != signValidity, 'TV:IUSV1');\n        require(_signValidity != 0, 'TV:IUSV2');\n        signValidity = _signValidity;\n        emit SignValidityUpdated(_signValidity);\n    }\n\n    /**\n     * @notice blacklist a digest\n     * @dev only owner can update\n     * @param _hash digest hash to be blacklisted\n     */\n    function blackListDigest(bytes32 _hash) external onlyOwner {\n        usedDigests[_hash] = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n    }\n}\ncontract LenderPool is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IPooledCreditLineEnums, ILenderPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    //-------------------------------- Constants start --------------------------------//\n\n    /**\n     * @notice address of savings account\n     */\n    ISavingsAccount public immutable SAVINGS_ACCOUNT;\n    /**\n     * @notice address of pooled credit line\n     */\n    IPooledCreditLine public immutable POOLED_CREDIT_LINE;\n    /**\n     * @notice address of verification module\n     */\n    IVerification public immutable VERIFICATION;\n    /*\n     * @notice Factor with which certain variables/constants are multiplied to maintain precision\n     */\n    uint256 constant SCALING_FACTOR = 1e18;\n\n    //-------------------------------- Constants end --------------------------------//\n\n    //-------------------------------- State variables start --------------------------------//\n\n    /**\n     * @notice Struct that stores the interest withdrawn by the lender of a specific credit line\n     * @param borrowerInterestSharesWithdrawn interest paid by borrower in shares, withdrawn by lender\n     * @param yieldInterestWithdrawnShares interest from yield strategy withdrawn by lender\n     */\n    struct LenderInfo {\n        uint256 borrowerInterestSharesWithdrawn;\n        uint256 yieldInterestWithdrawnShares;\n    }\n\n    /**\n     * @notice Struct that stores the constants of a pooled credit line\n     * @param startTime Timestamp at which pooled credit line starts\n     * @param borrowAsset address of token that is being lent by lenders & borrowed by borrower\n     * @param collateralAsset address of token that is used as collateral deposited by the borrower\n     * @param borrowLimit max tokens that was requested by borrower\n     * @param minBorrowAmount min tokens that was requested by borrower\n     * @param lenderVerifier address of verifier with which lenders should be verified to lend\n     * @param borrowAssetStrategy address of strategy to deposit lent tokens to in savings account\n     * @param areTokensTransferable boolean that represents if pool tokens for pooled credit line are transferable\n     */\n    struct LenderPoolConstants {\n        uint256 startTime;\n        address borrowAsset;\n        address collateralAsset;\n        uint256 borrowLimit;\n        uint256 minBorrowAmount;\n        address lenderVerifier;\n        address borrowAssetStrategy;\n        bool areTokensTransferable;\n    }\n\n    /**\n     * @notice Struct that stores the variables of a pooled credit line\n     * @param lenders mapping that stores lender specific info for the pooled credit line\n     * @param sharesHeld total shares of borrow token held by the pooled credit line\n              sharesHeld is set when the pcl is started and is equal to the shares equivalent to borrowLimit\n              when any amount is borrowed sharedHeld is reduced and when interest is withdrawn sharesHeld is reduced\n              when any amount is repaid sharedHeld is increased.\n              if any liquidity is withdrawn by the lender after liquidation or closing of the pcl, sharesHeld is\n              not changed.\n     * @param borrowerInterestShares total interest in shares repaid by borrower\n     * @param borrowerInterestSharesWithdrawn shares withdrawn from borrowerInterestShares\n     * @param yieldInterestWithdrawnShares total yield interest in shares withdrawn by all lenders together\n     * @param collateralHeld total collateral tokens held by pooled credit line in case of liquidation\n     */\n    struct LenderPoolVariables {\n        mapping(address => LenderInfo) lenders;\n        uint256 sharesHeld;\n        uint256 borrowerInterestShares;\n        uint256 borrowerInterestSharesWithdrawn;\n        uint256 yieldInterestWithdrawnShares;\n        uint256 collateralHeld;\n    }\n\n    /**\n     * @notice Mapping that stores constants for pooledCreditLine against it's id\n     */\n    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;\n    /**\n     * @notice Mapping that stores variables for pooledCreditLine against it's id\n     */\n    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;\n    /**\n     * @notice Mapping that stores total pooledCreditLine token supply against the creditLineId\n     * @dev Since ERC1155 tokens don't support the totalSupply function it is maintained here\n     */\n    mapping(uint256 => uint256) public totalSupply;\n\n    //-------------------------------- State variables end --------------------------------//\n\n    //-------------------------------- Modifiers start --------------------------------//\n\n    /**\n     * @notice Modifier that allows only pooled credit line to call a function\n     */\n    modifier onlyPooledCreditLine() {\n        require(msg.sender == address(POOLED_CREDIT_LINE), 'LP:OPCL1');\n        _;\n    }\n\n    //-------------------------------- Modifiers end --------------------------------//\n\n    //-------------------------------- Events start --------------------------------//\n\n    //--------------------------- LenderPool events start ---------------------------//\n\n    /**\n     * @notice Emitted when lender deposits tokens for pooled credit line\n     * @param id identifier for the pooled credit line\n     * @param user address of the user\n     * @param amount amount of tokens lent by user\n     */\n    event Lend(uint256 indexed id, address indexed user, uint256 amount);\n    /**\n     * @notice Emitted when liquidity provided by lender is withdrawn when pool is not cancelled\n     * @param id identifier for the pooled credit line\n     * @param user address of the lender\n     * @param shares amount of shares of liquidity provided initially by lender withdrawn\n     */\n    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);\n    /**\n     * @notice Emitted when liquidity provided by lender is withdrawn as pool is cancelled\n     * @param id identifier for the pooled credit line\n     * @param user address of the lender\n     * @param amount amount of tokens lent by the user which is withdrawn on pooled credit line cancellation\n     */\n    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);\n    /**\n     * @notice Emitted when interest by yield or/and borrower is withdrawn\n     * @param id identifier for the pooled credit line\n     * @param user address of the lender\n     * @param shares shares withdrawn by lender from interest accrued by yield as well as supplied by borrower\n     */\n    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);\n    /**\n     * @notice Emitted when a lender withdraws their share of liquidation\n     * @param id identifier for the pooled credit line\n     * @param user address of the lender\n     * @param collateralShare share of collateral withdrawn by lender from liquidation\n     */\n    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);\n    /**\n     * @notice Emitted when a pooled credit line is liquidated by a lender\n     * @param id identifier for the pooled credit line\n     * @param collateralLiquidated amount of collateral that is received after liquidation\n     */\n    event Liquidated(uint256 indexed id, uint256 collateralLiquidated);\n\n    //--------------------------- LenderPool events end ---------------------------//\n\n    //-------------------------------- Events end --------------------------------//\n\n    //-------------------------------- Init start --------------------------------//\n\n    /**\n     * @notice constructor to initialize immutable global variables\n     * @param _pooledCreditLine address of pooled credit line contract\n     * @param _savingsAccount address of savings account contract\n     * @param _verification address of verification contract\n     */\n    constructor(\n        address _pooledCreditLine,\n        address _savingsAccount,\n        address _verification\n    ) {\n        require(_pooledCreditLine != address(0), 'LP:C1');\n        require(_savingsAccount != address(0), 'LP:C2');\n        require(_verification != address(0), 'LP:C3');\n        POOLED_CREDIT_LINE = IPooledCreditLine(_pooledCreditLine);\n        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);\n        VERIFICATION = IVerification(_verification);\n    }\n\n    /**\n     * @notice initializes the contract in context of proxy\n     */\n    function initialize() external initializer {\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        __ERC1155_init('URI');\n    }\n\n    //-------------------------------- Init end --------------------------------//\n\n    //-------------------------------- PCL creation start --------------------------------//\n\n    /**\n     * @notice function invoked when creating pooled credit line\n     * @dev only pooled credit line can call the create function\n     * @param _id identifier for the pooled credit line\n     * @param _lenderVerifier address of verifier with which lenders should be verified to lend\n     * @param _borrowAsset address of token that is being lent by lenders & borrowed by borrower\n     * @param _borrowAssetStrategy address of strategy to deposit lent tokens to savings account\n     * @param _borrowLimit max tokens that was requested by borrower\n     * @param _minBorrowAmount min tokens that was requested by borrower\n     * @param _collectionPeriod time for which tokens can be lent to pooled credit lines\n     * @param _areTokensTransferable boolean that represents if pool tokens for credit line are transferable\n     */\n    function create(\n        uint256 _id,\n        address _lenderVerifier,\n        address _borrowAsset,\n        address _borrowAssetStrategy,\n        uint256 _borrowLimit,\n        uint256 _minBorrowAmount,\n        uint256 _collectionPeriod,\n        bool _areTokensTransferable\n    ) external override nonReentrant onlyPooledCreditLine {\n        pooledCLConstants[_id].startTime = block.timestamp.add(_collectionPeriod);\n        pooledCLConstants[_id].borrowAsset = _borrowAsset;\n        pooledCLConstants[_id].borrowLimit = _borrowLimit;\n        pooledCLConstants[_id].minBorrowAmount = _minBorrowAmount;\n        pooledCLConstants[_id].lenderVerifier = _lenderVerifier;\n        pooledCLConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;\n        pooledCLConstants[_id].areTokensTransferable = _areTokensTransferable;\n\n        uint256 allowance = SAVINGS_ACCOUNT.allowance(address(this), _borrowAsset, address(POOLED_CREDIT_LINE));\n        if (allowance != type(uint256).max) {\n            SAVINGS_ACCOUNT.approve(_borrowAsset, address(POOLED_CREDIT_LINE), type(uint256).max);\n        }\n    }\n\n    //-------------------------------- PCL creation end --------------------------------//\n\n    //-------------------------------- Lend & accept start --------------------------------//\n\n    /**\n     * @notice Function used by lenders to lend to pooled credit line\n     * @dev lent amount is deposited to savings account only once borrow limit is reached or if start is called\n     * @param _id identifier for the pooled credit line\n     * @param _amount amount of borrow tokens to lend\n     */\n    function lend(uint256 _id, uint256 _amount) external nonReentrant {\n        require(_amount != 0, 'LP:L1');\n        require(VERIFICATION.isUser(msg.sender, pooledCLConstants[_id].lenderVerifier), 'LP:L2');\n        require(block.timestamp < pooledCLConstants[_id].startTime, 'LP:L3');\n\n        uint256 _totalLent = totalSupply[_id];\n        uint256 _maxLent = pooledCLConstants[_id].borrowLimit;\n        require(_maxLent > _totalLent, 'LP:L4');\n\n        uint256 _amountToLend = _amount;\n        if (_totalLent.add(_amount) > _maxLent) {\n            _amountToLend = _maxLent.sub(_totalLent);\n        }\n        address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n\n        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amountToLend);\n        _mint(msg.sender, _id, _amountToLend, '');\n\n        emit Lend(_id, msg.sender, _amountToLend);\n    }\n\n    /**\n     * @notice function used to start the pooled credit line once the start time is reached\n     * @dev this function needs to be called by the borrower\n     * @param _id identifier for the pooled credit line\n     */\n    function start(uint256 _id) external override nonReentrant {\n        uint256 _startTime = pooledCLConstants[_id].startTime;\n        require(_startTime != 0, 'LP:S1');\n        // PCL can be started once the collection period is over\n        require(block.timestamp >= _startTime, 'LP:S2');\n        // PCL cannot be started once it has ended\n        // PCL remains in the REQUESTED stage if it is not started\n        // check _withdrawLiquidity method to see how these cases are handled\n        require(block.timestamp < POOLED_CREDIT_LINE.getEndsAt(_id), 'LP:S3');\n\n        uint256 _totalLent = totalSupply[_id];\n        require(_totalLent >= pooledCLConstants[_id].minBorrowAmount, 'LP:S4');\n\n        _accept(_id, _totalLent);\n    }\n\n    function _accept(uint256 _id, uint256 _amount) private {\n        address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n        IERC20(_borrowAsset).safeApprove(_strategy, _amount);\n        pooledCLVariables[_id].sharesHeld = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount);\n\n        // If msg.sender is not borrower, then tx is rejected\n        POOLED_CREDIT_LINE.accept(_id, _amount, msg.sender);\n\n        pooledCLConstants[_id].borrowLimit = _amount;\n        delete pooledCLConstants[_id].startTime;\n        delete pooledCLConstants[_id].minBorrowAmount;\n    }\n\n    //-------------------------------- Lend & accept end --------------------------------//\n\n    //-------------------------------- callbacks start --------------------------------//\n\n    /**\n     * @notice Function invoked on borrow from the pooled credit line\n     * @dev only pooledCreditLineContract can invoke\n     * @param _id identifier for the pooled credit line\n     * @param _sharesBorrowed amount of shares borrowed\n     */\n    function borrowed(uint256 _id, uint256 _sharesBorrowed) external override nonReentrant onlyPooledCreditLine {\n        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_sharesBorrowed);\n    }\n\n    /**\n     * @notice Function invoked when repayment is done to pooled credit line\n     * @dev only pooledCreditLineContract can invoke\n     * @param _id identifier for the pooled credit line\n     * @param _sharesRepaid shares repaid\n     * @param _interestShares interest in shares repaid\n     */\n    function repaid(\n        uint256 _id,\n        uint256 _sharesRepaid,\n        uint256 _interestShares\n    ) external override nonReentrant onlyPooledCreditLine {\n        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.add(_sharesRepaid);\n        pooledCLVariables[_id].borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares.add(_interestShares);\n    }\n\n    /**\n     * @notice Function invoked when pooled credit line is cancelled\n     * @dev only pooledCreditLineContract can invoke\n     * @param _id identifier for the pooled credit line\n     */\n    function requestCancelled(uint256 _id) external override onlyPooledCreditLine {\n        // We want *function lend* to fail, so that lenders do not keep on lending even after the CL is cancelled.\n        delete pooledCLConstants[_id].startTime;\n\n        // After this, we cannot delete *pooledCLConstants[_id]*, else we risk getting stuck with some of the lenders'\n        // liquidity inside of this contract. Therefore, after this, the user must themselves call *withdrawLiquidity*\n    }\n\n    /**\n     * @notice Function invoked when pooled credit line is terminated by admin\n     * @dev only pooledCreditLineContract can invoke\n     * @param _id identifier for the pooled credit line\n     * @param _to address to which all the borrow tokens are transferred\n     */\n    function terminate(uint256 _id, address _to) external override nonReentrant onlyPooledCreditLine {\n        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n        address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n        // this is the maximum amount which can be borrowed from the PCL\n        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n        // the borrower has not borrowed this much amount yet\n        // for eg: _borrowedLimit is 1000 DAI and the amount borrowed is 90 DAI\n        // also _notBorrowed == _borrowedLimit when the PCL has not started\n        uint256 _notBorrowed = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n        uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);\n        uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;\n        if (_sharesHeld != 0) {\n            uint256 _totalInterestInShares = _sharesHeld.sub(_notBorrowedInShares);\n            // the amount of _borrowAsset deposited by lenders against the PCL is equal to totalSupply[_id]\n            // when the PCL is active totalSupply[_id] == _borrowedLimit\n            // but _borrowLimit is some cases can be different than totalSupply[_id]\n            // for eg: before the PCL has started the borrowLimit asked by borrower is 1000 DAI\n            // but the lenders have only deposited 900 DAI till now so totalSupply[_id] is 900 DAI\n            // another eg is when the PCL has already been liquidated and some lenders have withdrawn the funds\n            // in this case too _borrowedLimit is greater than the totalSupply[_id]\n            // we multiply _notBorrowedInShares with the ratio of totalSupply[_id]/_borrowLimit\n            // this is done to get the _actualNotBorrowedInShares which might be less than the\n            // _notBorrowedInShares because of totalSupply[_id] being less than _borrowedLimit\n            uint256 _actualNotBorrowedInShares = _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens);\n            // shareWithdrawable = _actualNotBorrowedInShares + _totalInterestInShares\n            // _totalInterestInShares is not adjusted for change in totalSupply[_id] because\n            // no withdrawal of the principal fund deposited in the PCL can happen when it is active\n            // interest withdrawn from the PCL has already been deducted from sharesHeld\n            // interest (borrow + yield) come into the picture only after the PCL was activated in its lifetime\n            // borrowInterest is accrued only when PCL is active\n            // yield interest is accrued funds are deposited in the _strategy contract and is intrinsic to the shares\n            // any change in the totalSupply[_id] on does affect the interest shares in the PCL\n            uint256 _totalBorrowAsset = _actualNotBorrowedInShares.add(_totalInterestInShares);\n            if (_totalBorrowAsset != 0) {\n                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _totalBorrowAsset, false);\n            }\n        }\n\n        uint256 _collateralHeld = pooledCLVariables[_id].collateralHeld;\n        if (_collateralHeld != 0) {\n            // transferring the collateral that is transferred to Lender pool to distribute among lenders as part of liquidation\n            IERC20(pooledCLConstants[_id].collateralAsset).safeTransfer(_to, _collateralHeld);\n        }\n        delete pooledCLConstants[_id];\n        delete pooledCLVariables[_id];\n    }\n\n    //-------------------------------- callbacks end --------------------------------//\n\n    //-------------------------------- Interest start --------------------------------//\n\n    /**\n     * @notice Function used to withdraw interest repaid by the borrower and\n               the yield interest generated by the borrow assets deposited in the strategy\n     * @dev Tokens lent are locked till end of Pooled Credit line. \n            Any interest paid by borrower can be withdrawn by lenders proportional to\n            their token balances for that pooled credit line. Partial withdrawal of\n            interest is not allowed. Whenever they call the `withdrawInterest` function\n            they will get the entire amount of interest that is owed to them by that time\n     * @param _id identifier for the pooled credit line\n     */\n    function withdrawInterest(uint256 _id) external nonReentrant {\n        uint256 _interestSharesWithdrawn = _withdrawInterest(_id, msg.sender);\n        require(_interestSharesWithdrawn != 0, 'LP:WI1');\n    }\n\n    function _withdrawInterest(uint256 _id, address _lender) private returns (uint256 _interestSharesWithdrawn) {\n        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n        address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n        // this checks if the constants are not deleted\n        require(_strategy != address(0), 'LP:IWI1');\n\n        uint256 _interestSharesToWithdraw = _updateInterestSharesToWithdraw(_id, _lender, _strategy, _borrowAsset);\n\n        if (_interestSharesToWithdraw != 0) {\n            pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);\n            SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _lender, _interestSharesToWithdraw, false);\n            emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);\n        }\n\n        return _interestSharesToWithdraw;\n    }\n\n    /*\n     * @dev this function updates the interest shares withdrawn by the lender.\n            interest shares are of 2 types\n            - borrowerInterestSharesWithdrawn: this is the interest paid by the borrower and withdrawn by the lender\n            - yieldInterestWithdrawnShares: this is the interest accrued from the yield strategy and withdrawn by the lender\n     */\n    function _updateInterestSharesToWithdraw(\n        uint256 _id,\n        address _lender,\n        address _strategy,\n        address _borrowAsset\n    ) private returns (uint256) {\n        uint256 _lenderBalance = balanceOf(_lender, _id);\n        if (_lenderBalance == 0) {\n            return 0;\n        }\n\n        uint256 _borrowLimit = pooledCLConstants[_id].borrowLimit;\n        (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) = _calculateLenderInterest(\n            _id,\n            _lender,\n            _strategy,\n            _borrowAsset,\n            _lenderBalance,\n            _borrowLimit\n        );\n\n        if (_borrowerInterestSharesForLender != 0) {\n            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn = pooledCLVariables[_id]\n                .lenders[_lender]\n                .borrowerInterestSharesWithdrawn\n                .add(_borrowerInterestSharesForLender);\n            pooledCLVariables[_id].borrowerInterestSharesWithdrawn = pooledCLVariables[_id].borrowerInterestSharesWithdrawn.add(\n                _borrowerInterestSharesForLender\n            );\n        }\n\n        if (_yieldInterestSharesForLender != 0) {\n            pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares = pooledCLVariables[_id]\n                .lenders[_lender]\n                .yieldInterestWithdrawnShares\n                .add(_yieldInterestSharesForLender);\n            pooledCLVariables[_id].yieldInterestWithdrawnShares = pooledCLVariables[_id].yieldInterestWithdrawnShares.add(\n                _yieldInterestSharesForLender\n            );\n        }\n\n        return _yieldInterestSharesForLender.add(_borrowerInterestSharesForLender);\n    }\n\n    /**\n     * @notice Function used to get interest withdrawable by a lender in pooled credit line.\n               the interest this function returns is a sum of borrowerInterest + yieldInterest\n               borrower interest is the interest paid by the borrower\n               yield interest is the interest generated by the yield strategy\n     * @dev it is a view function as far as the Pooled credit lines are concerned and doesn't \n            make any state changes except for getSharesForTokens and getTokensForShares in yield\n     * @param _lender address of lender for whom interest is withdrawn\n     */\n    function getLenderInterestWithdrawable(uint256 _id, address _lender) external returns (uint256) {\n        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n        address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n        // get borrower repayments and yield interest shares\n        (uint256 _borrowerInterestShares, uint256 _yieldInterestShares) = _calculateLenderInterest(\n            _id,\n            _lender,\n            _strategy,\n            _borrowAsset,\n            balanceOf(_lender, _id),\n            pooledCLConstants[_id].borrowLimit\n        );\n        // convert total interest shares into tokens and return\n        return IYield(_strategy).getTokensForShares(_borrowerInterestShares.add(_yieldInterestShares), _borrowAsset);\n    }\n\n    function _calculateLenderInterest(\n        uint256 _id,\n        address _lender,\n        address _strategy,\n        address _borrowAsset,\n        uint256 _lenderBalance,\n        uint256 _borrowLimit\n    ) private returns (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) {\n        uint256 _totalInterestWithdrawableInShares;\n        {\n            uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;\n            // _sharesHeld is set in the _accept method\n            // _sharesHeld == 0 is in these PCL stages: not created, requested, cancelled and terminated\n            if (_sharesHeld == 0) {\n                return (0, 0);\n            }\n            uint256 _notBorrowed = _borrowLimit.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n            uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);\n            _totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);\n        }\n        uint256 _borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares;\n        _borrowerInterestSharesForLender = (_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(\n            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn\n        );\n\n        {\n            uint256 _borrowerInterestWithdrawableInShares = _borrowerInterestShares.sub(\n                pooledCLVariables[_id].borrowerInterestSharesWithdrawn\n            );\n            // _notBorrowed is converted to _notBorrowedInShares using the current exchange rate\n            // The difference in _sharesHeld and (_notBorrowedInShares + shares withdrawn)\n            // is the _totalYieldInterest\n            _yieldInterestSharesForLender = 0;\n            if (_totalInterestWithdrawableInShares > _borrowerInterestWithdrawableInShares) {\n                uint256 _totalYieldInterestShares = _totalInterestWithdrawableInShares.sub(_borrowerInterestWithdrawableInShares).add(\n                    pooledCLVariables[_id].yieldInterestWithdrawnShares\n                );\n                _yieldInterestSharesForLender = (_totalYieldInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(\n                    pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares\n                );\n            }\n        }\n    }\n\n    //-------------------------------- Interest end --------------------------------//\n\n    //-------------------------------- Liquidity withdraw start --------------------------------//\n\n    /**\n     * @notice Function to withdraw liquidity by lender\n     * @dev Liquidity can be withdrawn when the pooled credit line in the following scenarios\n            - pcl is cancelled by the borrower\n            - pcl gets cancelled because because desired amount wasn't reached\n            - pcl gets cancelled because it was never started by the borrower and endTime has reached\n            - pcl is liquidated before the endTime has reached\n            - pcl is liquidated after the endTime has reached\n            - pcl is closed after all repayments\n           in the other cases this function reverts\n     * @param _id identifier for the pooled credit line\n     */\n\n    function withdrawLiquidity(uint256 _id) external nonReentrant {\n        _withdrawLiquidity(_id, false);\n    }\n\n    function _withdrawLiquidity(uint256 _id, bool _isLiquidationWithdrawn) private {\n        uint256 _liquidityProvided = balanceOf(msg.sender, _id);\n        require(_liquidityProvided != 0, 'LP:IWL1');\n\n        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);\n\n        address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n\n        if (_status == PooledCreditLineStatus.REQUESTED) {\n            if (block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) {\n                POOLED_CREDIT_LINE.cancelRequestOnLowCollection(_id);\n            } else if (block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)) {\n                POOLED_CREDIT_LINE.cancelRequestOnRequestedStateAtEnd(_id);\n            } else {\n                revert('LP:IWL3');\n            }\n            _status = PooledCreditLineStatus.CANCELLED;\n            delete pooledCLConstants[_id].startTime;\n        }\n\n        if (_status == PooledCreditLineStatus.CANCELLED) {\n            // Case 0:\n            // Credit Line request was cancelled by the borrower, which deletes the creditLineVariables, hence status = uint256(0)\n            // Cancellation can only be done in the REQUESTED state, therefore, the borrowLimit target was also not met\n            // &&\n            // Case 1: Pooled credit line never started because desired amount wasn't reached\n            // _maxToLend is 0 if credit line is accepted so this case is never run\n\n            //transfer liquidity provided\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _liquidityProvided);\n            emit WithdrawLiquidityOnCancel(_id, msg.sender, _liquidityProvided);\n        } else if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {\n            if (_status == PooledCreditLineStatus.LIQUIDATED) {\n                // _isLiquidationWithdrawn is true when _withdrawLiquidity is called from within\n                // withdrawTokensAfterLiquidation which means the lender is withdrawing all assets after the PCL\n                // has been liquidated. Once PCL has been liquidated lender cannot call withdrawLiquidity directly\n                require(_isLiquidationWithdrawn, 'LP:IWL2');\n            }\n            // all other cases distribute the sharesHeld proportional to their poolToken balances\n            address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n            uint256 _principalWithdrawable = _calculatePrincipalWithdrawable(_id, msg.sender);\n            uint256 _interestSharesWithdrawable = _updateInterestSharesToWithdraw(_id, msg.sender, _strategy, _borrowAsset);\n            uint256 _interestWithdrawable;\n            if (_interestSharesWithdrawable != 0) {\n                _interestWithdrawable = IYield(_strategy).getTokensForShares(_interestSharesWithdrawable, _borrowAsset);\n                pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesWithdrawable);\n            }\n            uint256 _amountToWithdraw = _principalWithdrawable.add(_interestWithdrawable);\n            uint256 _sharesToWithdraw = IYield(_strategy).getSharesForTokens(_amountToWithdraw, _borrowAsset);\n            if (_sharesToWithdraw != 0) {\n                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, msg.sender, _sharesToWithdraw, false);\n            }\n            emit WithdrawLiquidity(_id, msg.sender, _sharesToWithdraw);\n        } else {\n            revert('LP:IWL3');\n        }\n\n        _burn(msg.sender, _id, _liquidityProvided);\n    }\n\n    /**\n     * @notice Function that can be used to calculate principal withdrawable\n     * @param _id identifier for the pooled credit line\n     * @param _lender lender whose share of principal is to be withdrawn\n     * @return Principal withdrawable\n     */\n    function calculatePrincipalWithdrawable(uint256 _id, address _lender) external returns (uint256) {\n        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);\n        if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {\n            return _calculatePrincipalWithdrawable(_id, _lender);\n        } else if (\n            _status == PooledCreditLineStatus.CANCELLED ||\n            (_status == PooledCreditLineStatus.REQUESTED &&\n                ((block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) ||\n                    block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)))\n        ) {\n            // this else if block covers the conditions when PCL was cancelled OR\n            // the PCL was in requested stage but never started\n            return balanceOf(_lender, _id);\n        } else {\n            return 0;\n        }\n    }\n\n    /*\n    * @dev returns the amount of principal the lender can withdraw after the pcl has been liquidated or closed\n           this value is equal to (total lent amount - principal borrowed) * lenders lp balance / total lent amount\n    */\n    function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {\n        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);\n        return _principalWithdrawable;\n    }\n\n    //-------------------------------- Liquidity withdraw end --------------------------------//\n\n    //-------------------------------- Liquidation start --------------------------------//\n\n    /**\n     * @notice Function used to liquidate a pooled credit line\n     * @dev only one of the lenders can liquidate their pooled credit line\n     * @param _id identifier for the pooled credit line\n     * @param _withdraw flag used to identify if lender's share of\n              liquidated collateral and liquidity (amount lent + interest) is also withdrawn\n     */\n    function liquidate(uint256 _id, bool _withdraw) external nonReentrant {\n        uint256 _lendingShare = balanceOf(msg.sender, _id);\n        require(_lendingShare != 0, 'LP:LIQ1');\n        // This line would call the liquidate function in the pooledCreditLine contract.\n        // Which would transfer the totalCollateralTokens to the pooledCreditLine contract.\n        (address _collateralAsset, uint256 _collateralLiquidated) = POOLED_CREDIT_LINE.liquidate(_id);\n        pooledCLConstants[_id].collateralAsset = _collateralAsset;\n        pooledCLVariables[_id].collateralHeld = _collateralLiquidated;\n\n        emit Liquidated(_id, _collateralLiquidated);\n\n        if (_withdraw) {\n            // This function would give the share of the lender who called this function from the total liquidated amount\n            // this will withdraw both the _collateralAsset and the borrowAsset\n            _withdrawTokensAfterLiquidation(_id, _lendingShare);\n        }\n    }\n\n    /**\n     * @notice Function used to withdraw lender's share of liquidated collateral and the borrowAsset\n     * @param _id identifier for the pooled credit line\n     */\n    function withdrawTokensAfterLiquidation(uint256 _id) external nonReentrant {\n        uint256 _lendingShare = balanceOf(msg.sender, _id);\n        require(_lendingShare != 0, 'LP:WLC1');\n        _withdrawTokensAfterLiquidation(_id, _lendingShare);\n    }\n\n    function _withdrawTokensAfterLiquidation(uint256 _id, uint256 _balance) private {\n        address _collateralAsset = pooledCLConstants[_id].collateralAsset;\n        require(_collateralAsset != address(0), 'LP:IWLC1');\n        uint256 _collateralLiquidated = pooledCLVariables[_id].collateralHeld;\n        uint256 _currentSupply = totalSupply[_id];\n\n        uint256 _lenderCollateralShare = _balance.mul(_collateralLiquidated).div(_currentSupply);\n\n        if (_lenderCollateralShare != 0) {\n            pooledCLVariables[_id].collateralHeld = pooledCLVariables[_id].collateralHeld.sub(_lenderCollateralShare);\n\n            IERC20(_collateralAsset).safeTransfer(msg.sender, _lenderCollateralShare);\n            emit LiquidationWithdrawn(_id, msg.sender, _lenderCollateralShare);\n        }\n        // this will withdraw the lender's share of liquidity (amount lent + interest)\n        _withdrawLiquidity(_id, true);\n    }\n\n    //-------------------------------- Liquidation end --------------------------------//\n\n    //-------------------------------- Pre token transfer start --------------------------------//\n\n    function _beforeTokenTransfer(\n        address,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory\n    ) internal override {\n        require(from != to, 'LP:IT1');\n        for (uint256 i; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            if (to != address(0)) {\n                // cannot transfer to the borrower\n                require(to != POOLED_CREDIT_LINE.getBorrowerAddress(id), 'LP:IT2');\n                // cannot transfer to a non verified user\n                require(VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier), 'LP:IT3');\n            }\n\n            uint256 amount = amounts[i];\n\n            if (from == address(0)) {\n                // this is the case for minting tokens\n                // increase the total supply of lp tokens\n                totalSupply[id] = totalSupply[id].add(amount);\n            } else if (to == address(0)) {\n                // this is the case for burn\n                // reduce the total supply of lp tokens\n                uint256 supply = totalSupply[id];\n                require(supply >= amount, 'LP:IT4');\n                totalSupply[id] = supply - amount;\n            } else {\n                // case for user to user transfer\n                require(pooledCLConstants[id].areTokensTransferable, 'LP:IT5');\n            }\n\n            if (from != address(0)) {\n                // we need to transfer the lender info from to the receiving address\n                _rebalanceInterestWithdrawn(id, amount, from, to);\n            }\n        }\n    }\n\n    function _rebalanceInterestWithdrawn(\n        uint256 id,\n        uint256 amount,\n        address from,\n        address to\n    ) private {\n        if (from != address(0) && to != address(0)) {\n            // if the transfer is from user to user, we will withdraw all the interest for the user\n            // this is done because we need to transfer the lender info\n            // if the interest is not withdrawn the [from] user will not be able to withdraw the interest owned to them\n            _withdrawInterest(id, from);\n            _withdrawInterest(id, to);\n        }\n\n        uint256 fromBalance = balanceOf(from, id);\n        require(fromBalance != 0, 'LP:IRIW1');\n\n        uint256 yieldInterestOnTransferAmount = pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares.mul(amount).div(\n            fromBalance\n        );\n        uint256 borrowerInterestOnTransferAmount = pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn.mul(amount).div(\n            fromBalance\n        );\n\n        if (borrowerInterestOnTransferAmount != 0) {\n            pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn = pooledCLVariables[id]\n                .lenders[from]\n                .borrowerInterestSharesWithdrawn\n                .sub(borrowerInterestOnTransferAmount);\n        }\n\n        if (yieldInterestOnTransferAmount != 0) {\n            pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares = pooledCLVariables[id]\n                .lenders[from]\n                .yieldInterestWithdrawnShares\n                .sub(yieldInterestOnTransferAmount);\n        }\n\n        if (to != address(0)) {\n            if (borrowerInterestOnTransferAmount != 0) {\n                pooledCLVariables[id].lenders[to].borrowerInterestSharesWithdrawn = pooledCLVariables[id]\n                    .lenders[to]\n                    .borrowerInterestSharesWithdrawn\n                    .add(borrowerInterestOnTransferAmount);\n            }\n            if (yieldInterestOnTransferAmount != 0) {\n                pooledCLVariables[id].lenders[to].yieldInterestWithdrawnShares = pooledCLVariables[id]\n                    .lenders[to]\n                    .yieldInterestWithdrawnShares\n                    .add(yieldInterestOnTransferAmount);\n            }\n        }\n    }\n\n    //-------------------------------- Pre token transfer end --------------------------------//\n\n    //-------------------------------- getters start --------------------------------//\n\n    /**\n     * @notice Function used to get withdrawal info of a lender for a specific pooled credit line\n     * @param _id identifier for the pooled credit line\n     * @param _lender address of the lender for which query is made\n     * @return returns lender info\n     */\n    function getLenderInfo(uint256 _id, address _lender) external view returns (LenderInfo memory) {\n        return pooledCLVariables[_id].lenders[_lender];\n    }\n\n    //-------------------------------- getters end --------------------------------//\n}\n",
    "bin": []
}