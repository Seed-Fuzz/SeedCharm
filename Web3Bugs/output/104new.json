{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/104/core-contracts",
    "external_functions": [
        [
            "CoreCollection",
            "IERC20",
            "IERC721Receiver",
            "IRoyaltyVault"
        ],
        [
            "CoreFactory",
            "ICoreCollection"
        ],
        [
            "CoreProxy"
        ],
        [
            "ERC721Claimable"
        ],
        [
            "ERC721Payable",
            "IERC20"
        ]
    ],
    "new_contract": "contract CoreProxy is Ownable {\n    address private immutable _implement;\n\n    constructor(address _imp) {\n        _implement = _imp;\n    }\n\n    fallback() external {\n        address _impl = implement();\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    function implement() public view returns (address) {\n        return _implement;\n    }\n}\nabstract contract ERC721Payable {\n  uint256 public mintFee;\n  IERC20 public payableToken;\n  bool public isForSale;\n  address public royaltyVault;\n  address public splitFactory;\n  event NewPayment(\n    address from,\n    address to,\n    uint256 amount,\n    bool royaltyVaultPayment\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyVaultUninitialized() {\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n    _;\n  }\n\n  modifier onlyVaultInitialized() {\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function royaltyVaultInitialized() public view returns (bool) {\n    return royaltyVault != address(0);\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  /**\n   * @notice Handles the transfer of ERC20 tokens when a token gets minted\n   * @dev Tokens are transferred to the Royalty Vault if the vault is set\n   * Otherwise, tokens get transferred to the ERC721 collection contract\n   * @param _amount The amount of ERC20 to be transferred\n   */\n  function _handlePayment(uint256 _amount) internal {\n    address recipient = royaltyVaultInitialized()\n      ? royaltyVault\n      : address(this);\n    payableToken.transferFrom(msg.sender, recipient, _amount);\n    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());\n  }\n}\ncontract CoreFactory {\n  struct Project {\n    string id;\n    address creator;\n  }\n\n  event NewProject(string id, address creator);\n  event NewCollection(\n    string collectionId,\n    address collection,\n    string projectId\n  );\n\n  address public immutable collection;\n  address public immutable splitFactory;\n  mapping(string => Project) public projects;\n  mapping(string => address) public collections;\n\n  constructor(address _collection, address _splitFactory) {\n    collection = _collection;\n    splitFactory = _splitFactory;\n  }\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyAvailableProject(string memory _projectId) {\n    require(\n      projects[_projectId].creator == address(0),\n      'CoreFactory: Unavailable project id'\n    );\n    _;\n  }\n\n  modifier onlyProjectOwner(string memory _projectId) {\n    require(\n      projects[_projectId].creator == msg.sender,\n      'CoreFactory: Not an owner of the project'\n    );\n    _;\n  }\n\n  modifier onlyAvailableCollection(string memory _collectionId) {\n    require(\n      collections[_collectionId] == address(0),\n      'CoreFactory: Unavailable collection id'\n    );\n    _;\n  }\n\n  // ---------------- EXTERNAL ----------------\n\n  /**\n   * @notice Allows to create a project as well as deploy its collection(s)\n   * For adding a collection to a project, use the addCollection() method.\n   * @dev Projects have unique identifiers.\n   * Collections are deployed using a proxy pattern. This is mainly for gas optimization purposes\n   * and to support future contract upgrades.\n   * Collections ownership are transferred to the caller.\n   * @param _projectId Project id which is a unique identifier\n   * @param _collections An array of Collection that needs to be deployed\n   */\n  function createProject(\n    string memory _projectId,\n    Collection[] memory _collections\n  ) external onlyAvailableProject(_projectId) {\n    require(\n      _collections.length > 0,\n      'CoreFactory: should have more at least one collection'\n    );\n\n    for (uint256 i; i < _collections.length; i++) {\n      Collection memory _collection = _collections[i];\n      address coreCollection = _createCollection(_collection);\n\n      if (_collection.claimsMerkleRoot != bytes32(0)) {\n        ICoreCollection(coreCollection).initializeClaims(\n          _collection.claimsMerkleRoot\n        );\n      }\n\n      emit NewCollection(_collection.id, coreCollection, _projectId);\n\n      ICoreCollection(coreCollection).transferOwnership(msg.sender);\n    }\n    Project memory project;\n    project.id = _projectId;\n    project.creator = msg.sender;\n    projects[_projectId] = project;\n\n    emit NewProject(_projectId, msg.sender);\n  }\n\n  /**\n   * @notice Allows to add a collection to a project\n   * @dev Can only be called by project creator\n   * Collection's ownership is transferred to the caller\n   * @param _projectId Project id which is a unique identifier\n   * @param _collection Collection that needs to be deployed\n   */\n  function addCollection(\n    string memory _projectId,\n    Collection memory _collection\n  ) external onlyProjectOwner(_projectId) returns (address) {\n    address coreCollection = _createCollection(_collection);\n\n    if (_collection.claimsMerkleRoot != bytes32(0)) {\n      ICoreCollection(coreCollection).initializeClaims(\n        _collection.claimsMerkleRoot\n      );\n    }\n\n    emit NewCollection(_collection.id, coreCollection, _projectId);\n\n    ICoreCollection(coreCollection).transferOwnership(msg.sender);\n    return coreCollection;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function getProject(string memory _projectId)\n    external\n    view\n    returns (Project memory)\n  {\n    return projects[_projectId];\n  }\n\n  // ---------------- PRIVATE ----------------\n\n  /**\n   * @notice Instanciates/Deploys a collection\n   * @param _collection Collection that needs to be deployed\n   */\n  function _createCollection(Collection memory _collection)\n    private\n    onlyAvailableCollection(_collection.id)\n    returns (address)\n  {\n    address coreCollection = address(\n      new CoreProxy{salt: keccak256(abi.encodePacked(_collection.id))}(\n        collection\n      )\n    );\n\n    ICoreCollection(coreCollection).initialize(\n      _collection.name,\n      _collection.symbol,\n      _collection.baseURI,\n      _collection.maxSupply,\n      _collection.mintFee,\n      _collection.payableToken,\n      _collection.isForSale,\n      splitFactory\n    );\n\n    collections[_collection.id] = coreCollection;\n    return coreCollection;\n  }\n}\ncontract CoreCollection is\n    Ownable,\n    ERC721Claimable,\n    ERC721Enumerable,\n    ERC721Payable\n{\n    bool public initialized;\n    string private _name;\n    string private _symbol;\n    string private _baseUri;\n    uint256 public maxSupply;\n    uint256 public startingIndex;\n    uint256 public startingIndexBlock;\n    string public HASHED_PROOF = \"\";\n\n    event ClaimInitialized(bytes32 root);\n    event NewCollectionMeta(string name, string symbol);\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\n    event StartingIndexSet(uint256 index);\n    event RoyaltyVaultInitialized(address royaltyVault);\n    event NewHashedProof(string proof);\n    event NewWithdrawal(address to, uint256 amount);\n\n    constructor() ERC721(\"\", \"\") {}\n\n    // ----------------- MODIFIER -----------------\n\n    modifier onlyInitialized() {\n        require(initialized, \"CoreCollection: Not initialized\");\n        _;\n    }\n\n    modifier onlyUnInitialized() {\n        require(!initialized, \"CoreCollection: Already initialized\");\n        _;\n    }\n\n    modifier onlyValidSupply(uint256 _maxSupply) {\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n        _;\n    }\n\n    modifier tokenExists(uint256 _tokenId) {\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\n        _;\n    }\n\n    // ----------------- EXTERNAL -----------------\n\n    /**\n     * @notice Initializes the collection\n     * @dev This method is being called from the CoreFactory contract\n     * @param _collectionName Name of the collection\n     * @param _collectionSymbol Symbol of the collection\n     * @param _collectionURI Base URI for the collection\n     * @param _maxSupply The maximum number of tokens that can be minted\n     * @param _mintFee The price of a token in this collection\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\n     * @param _splitFactory base URI for the collection\n     */\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        _baseUri = _collectionURI;\n        maxSupply = _maxSupply;\n        mintFee = _mintFee;\n        payableToken = IERC20(_payableToken);\n        isForSale = _isForSale;\n        splitFactory = _splitFactory;\n        initialized = true;\n    }\n\n    /**\n     * @notice Allows the collection owner to airdrop tokens\n     * @dev The Merkle tree defines for each address how much token can be claimed\n     * @dev This method can only be called once\n     * @param _root A Merkle root\n     */\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n    {\n        _setMerkelRoot(_root);\n        emit ClaimInitialized(_root);\n    }\n\n    /**\n     * @notice Allows the collection owner to change the collection's name and symbol\n     * @dev This function is only callable by the collection's owner\n     * @param _collectionName A collection name\n     * @param _collectionSymbol A collection symbol\n     */\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\n    }\n\n    /**\n     * @notice This function is called to mint tokens from this ERC721 collection\n     * @dev The collection must be initialized first\n     * @param to Token recipient\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\n     * @param claimableAmount The amount of tokens the user has been airdropped\n     * @param amount The amount of tokens the user wants to mint\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\n     */\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"CoreCollection: Over Max Supply\"\n        );\n\n        if (isClaim) {\n            require(claimableSet(), \"CoreCollection: No claimable\");\n            require(\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\n                \"CoreCollection: Can't claim\"\n            );\n            _claim(msg.sender, amount);\n        } else {\n            require(isForSale, \"CoreCollection: Not for sale\");\n            if (mintFee > 0) {\n                _handlePayment(mintFee * amount);\n            }\n        }\n\n        batchMint(to, amount, isClaim);\n    }\n\n    /**\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\n     */\n    function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Set royalty vault address for collection\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \n     * from the collection are transferred to the vault when the vault is initialized\n     * @param _royaltyVault The address of the royalty vault\n     */\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n    {\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n        royaltyVault = _royaltyVault;\n        emit RoyaltyVaultInitialized(_royaltyVault);\n    }\n\n    /**\n     * @notice Set a provenance hash\n     * @dev This hash is used to verify the minting ordering of a collection (\u00e0 la BAYC)\n     * This hash is generated off-chain\n     * @param _proof The SHA256 generated hash\n     */\n    function setHashedProof(string calldata _proof) external onlyOwner {\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n\n        HASHED_PROOF = _proof;\n        emit NewHashedProof(_proof);\n    }\n\n    // ----------------- PUBLIC -----------------\n\n    /**\n     * @notice Set the mint starting index\n     * @dev The starting index can only be generated once\n     */\n    function setStartingIndex() public {\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n\n        startingIndex =\n            (uint256(\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\n            ) % maxSupply) +\n            1;\n        startingIndexBlock = uint256(block.number);\n        emit StartingIndexSet(startingIndex);\n    }\n\n    // ---------------- VIEW ----------------\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseUri;\n    }\n\n    // ---------------- PRIVATE ----------------\n\n    /**\n     * @notice Mint token\n     * @dev A starting index is calculated at the time of first mint\n     * returns a tokenId\n     * @param _to Token recipient\n     */\n    function mint(address _to) private returns (uint256 tokenId) {\n        if (startingIndex == 0) {\n            setStartingIndex();\n        }\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n        _mint(_to, tokenId);\n    }\n\n    /**\n     * @notice Mint tokens in batch\n     * @param _to Token recipient\n     * @param _amount Number of tokens to include in batch\n     * @param _isClaim Whether the batch mint is an airdrop or not\n     */\n    function batchMint(\n        address _to,\n        uint256 _amount,\n        bool _isClaim\n    ) private {\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = mint(_to);\n            if (_isClaim) {\n                emit NewClaim(msg.sender, _to, tokenId);\n            }\n        }\n    }\n\n    // ---------------- INTERNAL ----------------\n\n    /**\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\n     * @dev The split contract is a contract that allows a team to share revenue together\n     * @param _from Transfer sender\n     * @param _to Transfer recipient\n     * @param _tokenId TokenId of token being transferred\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n\n        if (\n            royaltyVault != address(0) &&\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\n        ) {\n            IRoyaltyVault(royaltyVault).sendToSplitter();\n        }\n    }\n}\nabstract contract ERC721Claimable {\n  bytes32 private _merkleRoot;\n  mapping(address => uint256) private _claimedAmount;\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyValidRoot(bytes32 root) {\n    require(root != bytes32(0), 'ERC721Claimable: Not valid root');\n    _;\n  }\n\n  modifier onlyClaimableSet() {\n    require(claimableSet(), 'ERC721Claimable: No claimable');\n    _;\n  }\n\n  modifier onlyNotClaimableSet() {\n    require(!claimableSet(), 'ERC721Claimable: Claimable is already set');\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function claimableSet() public view returns (bool) {\n    return getMerkleRoot() != bytes32(0);\n  }\n\n  function verifyProof(\n    bytes32[] memory proof,\n    bytes32 root,\n    bytes32 leaf\n  ) public pure returns (bool) {\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  function processProof(bytes32[] memory proof, bytes32 leaf)\n    public\n    pure\n    returns (bytes32)\n  {\n    return MerkleProof.processProof(proof, leaf);\n  }\n\n  /**\n   * @notice Verifies whether an address can claim tokens\n   * @dev \n   * @param who Claimer address\n   * @param claimableAmount Amount airdropped to claimer\n   * @param claimedAmount Amount of tokens claimer wants to claim\n   * @param merkleProof Proof\n   */\n  function canClaim(\n    address who,\n    uint256 claimableAmount,\n    uint256 claimedAmount,\n    bytes32[] calldata merkleProof\n  ) public view returns (bool) {\n    require(\n      verifyProof(merkleProof, getMerkleRoot(), getNode(who, claimableAmount)),\n      'ERC721Claimable: Invalid proof'\n    );\n\n    return _claimedAmount[who] + claimedAmount <= claimableAmount;\n  }\n\n  function getMerkleRoot() public view returns (bytes32) {\n    return _merkleRoot;\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  function _setMerkelRoot(bytes32 root) internal {\n    _merkleRoot = root;\n  }\n\n  function _claim(address claimer, uint256 claimedAmount) internal {\n    _claimedAmount[claimer] += claimedAmount;\n  }\n\n  // ---------------- PRIVATE ----------------\n\n  /**\n   * @dev get Node hash of given data.\n   * @param who {address} Membership contract address\n   * @param claimableAmount {uint256} token id which claiming person owns\n   * @return {bytes32} node hash\n   */\n  function getNode(address who, uint256 claimableAmount)\n    private\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(who, claimableAmount));\n  }\n}\n",
    "bin": []
}