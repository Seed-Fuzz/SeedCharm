{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/110",
    "external_functions": [
        [
            "CitadelMinter",
            "IGac",
            "IVault",
            "ISupplySchedule",
            "ICitadelToken",
            "IStakedCitadelLocker"
        ],
        [
            "CitadelToken",
            "IGac"
        ],
        [
            "Funding",
            "IGac",
            "IERC20",
            "IVault",
            "IMedianOracle"
        ],
        [
            "GlobalAccessControl"
        ],
        [
            "KnightingRound",
            "IGac",
            "ERC20Upgradeable",
            "IBadgerVipGuestlist"
        ],
        [
            "StakedCitadel",
            "IERC20",
            "IERC20Upgradeable",
            "IStrategy",
            "IBadgerGuestlist",
            "IVesting"
        ],
        [
            "StakedCitadelVester",
            "IGac"
        ],
        [
            "SupplySchedule",
            "IGac"
        ]
    ],
    "new_contract": "contract CitadelToken is GlobalAccessControlManaged, ERC20Upgradeable {\n    bytes32 public constant CITADEL_MINTER_ROLE =\n        keccak256(\"CITADEL_MINTER_ROLE\");\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @param _name Token name\n     * @param _symbol Token symbol\n     * @param _gac Global access control to allow permissioned calls by role\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _gac\n    ) public initializer {\n        __ERC20_init(_name, _symbol);\n        __GlobalAccessControlManaged_init(_gac);\n    }\n\n    /// ==========================\n    /// ===== Minter actions =====\n    /// ==========================\n\n    /**\n     * @dev Mints new tokens.\n     * @param dest The address to mint the new tokens to.\n     * @param amount The quantity of tokens to mint.\n     */\n    function mint(address dest, uint256 amount)\n        external\n        onlyRole(CITADEL_MINTER_ROLE)\n        gacPausable\n    {\n        _mint(dest, amount);\n    }\n}\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\ncontract SettAccessControl is Initializable {\n    address public governance;\n    address public strategist;\n    address public keeper;\n\n    // ===== MODIFIERS =====\n    function _onlyGovernance() internal view {\n        require(msg.sender == governance, \"onlyGovernance\");\n    }\n\n    function _onlyGovernanceOrStrategist() internal view {\n        require(\n            msg.sender == strategist || msg.sender == governance,\n            \"onlyGovernanceOrStrategist\"\n        );\n    }\n\n    function _onlyAuthorizedActors() internal view {\n        require(\n            msg.sender == keeper || msg.sender == governance,\n            \"onlyAuthorizedActors\"\n        );\n    }\n\n    // ===== PERMISSIONED ACTIONS =====\n\n    /// @notice Change strategist address\n    /// @notice Can only be changed by governance itself\n    function setStrategist(address _strategist) external {\n        _onlyGovernance();\n        strategist = _strategist;\n    }\n\n    /// @notice Change keeper address\n    /// @notice Can only be changed by governance itself\n    function setKeeper(address _keeper) external {\n        _onlyGovernance();\n        keeper = _keeper;\n    }\n\n    /// @notice Change governance address\n    /// @notice Can only be changed by governance itself\n    function setGovernance(address _governance) public {\n        _onlyGovernance();\n        governance = _governance;\n    }\n\n    uint256[50] private __gap;\n}\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\ncontract GlobalAccessControl is\n    AccessControlEnumerableUpgradeable,\n    PausableUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant TREASURY_GOVERNANCE_ROLE =\n        keccak256(\"TREASURY_GOVERNANCE_ROLE\");\n\n    bytes32 public constant TECH_OPERATIONS_ROLE =\n        keccak256(\"TECH_OPERATIONS_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE =\n        keccak256(\"TREASURY_OPERATIONS_ROLE\");\n\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n\n    bytes32 public constant BLOCKLIST_MANAGER_ROLE =\n        keccak256(\"BLOCKLIST_MANAGER_ROLE\");\n    bytes32 public constant BLOCKLISTED_ROLE = keccak256(\"BLOCKLISTED_ROLE\");\n\n    bytes32 public constant CITADEL_MINTER_ROLE =\n        keccak256(\"CITADEL_MINTER_ROLE\");\n\n    // Should the function transferFrom be disabled\n    // NOTE: This is enforced at the contract level, the contract just allows the toggling of the bool\n    bool public transferFromDisabled; // Set to true in initialize\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @param _initialContractGovernance Global access control\n     */\n    function initialize(address _initialContractGovernance)\n        external\n        initializer\n    {\n        __AccessControlEnumerable_init();\n        __Pausable_init();\n\n        // Set this for assumptions and clarity\n        _setupRole(DEFAULT_ADMIN_ROLE, _initialContractGovernance);\n        \n        _setupRole(CONTRACT_GOVERNANCE_ROLE, _initialContractGovernance);\n\n        // All roles are managed by CONTRACT_GOVERNANCE_ROLE\n        _setRoleAdmin(CONTRACT_GOVERNANCE_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(POLICY_OPERATIONS_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(TREASURY_GOVERNANCE_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(PAUSER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(UNPAUSER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(BLOCKLIST_MANAGER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(CITADEL_MINTER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(KEEPER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n\n        // Add default admin role here to avoid governance mistakes\n        _setRoleAdmin(DEFAULT_ADMIN_ROLE, CONTRACT_GOVERNANCE_ROLE);\n\n        // BLOCKLIST is managed by BLOCKLIST_MANAGER\n        _setRoleAdmin(BLOCKLISTED_ROLE, BLOCKLIST_MANAGER_ROLE);\n    }\n\n    /// ================================================\n    /// ===== Permissioned Actions (various roles) =====\n    /// ================================================\n\n    function pause() external {\n        require(hasRole(PAUSER_ROLE, msg.sender), \"PAUSER_ROLE\");\n        _pause();\n    }\n\n    function unpause() external {\n        require(hasRole(UNPAUSER_ROLE, msg.sender), \"UNPAUSER_ROLE\");\n        _unpause();\n    }\n\n    /// @dev setup a new role via contract governance, without upgrade\n    /// @dev note that no constant will be available on the contract here to search role, but we can delegate viewing to another contract\n    /// TODO: Add string -> hash EnumerableSet to a new RoleRegistry contract for easy on-chain viewing.\n    function initializeNewRole(\n        bytes32 role,\n        string memory roleString,\n        bytes32 adminRole\n    ) external {\n        require(\n            hasRole(CONTRACT_GOVERNANCE_ROLE, msg.sender),\n            \"CONTRACT_GOVERNANCE_ROLE\"\n        );\n        require(\n            keccak256(bytes(roleString)) == role,\n            \"Role string and role do not match\"\n        );\n        _setRoleAdmin(role, adminRole);\n    }\n}\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\ncontract StakedCitadel is\n    ERC20Upgradeable,\n    SettAccessControl,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    uint256 constant ONE_ETH = 1e18;\n\n    /// ===== Storage Variables ====\n\n    IERC20Upgradeable public token; // Token used for deposits\n    IBadgerGuestlist public guestList; // guestlist when vault is in experiment/ guarded state\n\n    bool public pausedDeposit; // false by default Allows to only block deposits, use pause for the normal pause state\n\n    address public strategy; // address of the strategy connected to the vault\n    address public guardian; // guardian of vault and strategy\n    address public treasury; // set by governance ... any fees go there\n\n    address public badgerTree; // Address we send tokens too via reportAdditionalTokens\n    address public vesting; // Address of the vesting contract where after withdrawal we send CTDL to vest for 21 days\n\n    /// @dev name and symbol prefixes for lpcomponent token of vault\n    string internal constant _defaultNamePrefix = \"Staked \";\n    string internal constant _symbolSymbolPrefix = \"x\";\n\n    /// Params to track autocompounded rewards\n    uint256 public lifeTimeEarned; // keeps track of total earnings\n    uint256 public lastHarvestedAt; // timestamp of the last harvest\n    uint256 public lastHarvestAmount; // amount harvested during last harvest\n    uint256 public assetsAtLastHarvest; // assets for which the harvest took place.\n\n    mapping(address => uint256) public additionalTokensEarned;\n    mapping(address => uint256) public lastAdditionalTokenAmount;\n\n    /// Fees ///\n    /// @notice all fees will be in bps\n    uint256 public performanceFeeGovernance; // Perf fee sent to `treasury`\n    uint256 public performanceFeeStrategist; // Perf fee sent to `strategist`\n    uint256 public withdrawalFee; // fee issued to `treasury` on withdrawal\n    uint256 public managementFee; // fee issued to `treasury` on report (typically on harvest, but only if strat is autocompounding)\n\n    uint256 public maxPerformanceFee; // maximum allowed performance fees\n    uint256 public maxWithdrawalFee; // maximum allowed withdrawal fees\n    uint256 public maxManagementFee; // maximum allowed management fees\n\n    uint256 public toEarnBps; // NOTE: in BPS, minimum amount of token to deposit into strategy when earn is called\n\n    /// ===== Constants ====\n\n    uint256 public constant MAX_BPS = 10_000;\n    uint256 public constant SECS_PER_YEAR = 31_556_952; // 365.2425 days\n\n    uint256 public constant WITHDRAWAL_FEE_HARD_CAP = 200; // Never higher than 2%\n    uint256 public constant PERFORMANCE_FEE_HARD_CAP = 3_000; // Never higher than 30% // 30% maximum performance fee // We usually do 20, so this is insanely high already\n    uint256 public constant MANAGEMENT_FEE_HARD_CAP = 200; // Never higher than 2%\n\n    /// ===== Events ====\n\n    // Emitted when a token is sent to the badgerTree for emissions\n    event TreeDistribution(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    // Emitted during a report, when there has been an increase in pricePerFullShare (ppfs)\n    event Harvested(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    event SetTreasury(address indexed newTreasury);\n    event SetStrategy(address indexed newStrategy);\n    event SetToEarnBps(uint256 newEarnToBps);\n    event SetMaxWithdrawalFee(uint256 newMaxWithdrawalFee);\n    event SetMaxPerformanceFee(uint256 newMaxPerformanceFee);\n    event SetMaxManagementFee(uint256 newMaxManagementFee);\n    event SetGuardian(address indexed newGuardian);\n    event SetVesting(address indexed newVesting);\n    event SetGuestList(address indexed newGuestList);\n    event SetWithdrawalFee(uint256 newWithdrawalFee);\n    event SetPerformanceFeeStrategist(uint256 newPerformanceFeeStrategist);\n    event SetPerformanceFeeGovernance(uint256 newPerformanceFeeGovernance);\n    event SetManagementFee(uint256 newManagementFee);\n\n    event PauseDeposits(address indexed pausedBy);\n    event UnpauseDeposits(address indexed pausedBy);\n\n    /// @notice Initializes the Sett. Can only be called once, ideally when the contract is deployed.\n    /// @param _token Address of the token that can be deposited into the sett.\n    /// @param _governance Address authorized as governance.\n    /// @param _keeper Address authorized as keeper.\n    /// @param _guardian Address authorized as guardian.\n    /// @param _treasury Address to distribute governance fees/rewards to.\n    /// @param _strategist Address authorized as strategist.\n    /// @param _badgerTree Address of badgerTree used for emissions.\n    /// @param _name Specify a custom sett name. Leave empty for default value.\n    /// @param _symbol Specify a custom sett symbol. Leave empty for default value.\n    /// @param _feeConfig Values for the 4 different types of fees charges by the sett\n    ///         [performanceFeeGovernance, performanceFeeStrategist, withdrawToVault, managementFee]\n    ///         Each fee should be less than the constant hard-caps defined above.\n    function initialize(\n        address _token,\n        address _governance,\n        address _keeper,\n        address _guardian,\n        address _treasury,\n        address _strategist,\n        address _badgerTree,\n        address _vesting,\n        string memory _name,\n        string memory _symbol,\n        uint256[4] memory _feeConfig\n    ) public initializer whenNotPaused {\n        require(_token != address(0)); // dev: _token address should not be zero\n        require(_governance != address(0)); // dev: _governance address should not be zero\n        require(_keeper != address(0)); // dev: _keeper address should not be zero\n        require(_guardian != address(0)); // dev: _guardian address should not be zero\n        require(_treasury != address(0)); // dev: _treasury address should not be zero\n        require(_strategist != address(0)); // dev: _strategist address should not be zero\n        require(_badgerTree != address(0)); // dev: _badgerTree address should not be zero\n        require(_vesting != address(0)); // dev: _vesting address should not be zero\n\n        // Check for fees being reasonable (see below for interpretation)\n        require(\n            _feeConfig[0] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeGovernance too high\"\n        );\n        require(\n            _feeConfig[1] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n        require(\n            _feeConfig[2] <= WITHDRAWAL_FEE_HARD_CAP,\n            \"withdrawalFee too high\"\n        );\n        require(\n            _feeConfig[3] <= MANAGEMENT_FEE_HARD_CAP,\n            \"managementFee too high\"\n        );\n\n        string memory name;\n        string memory symbol;\n\n        // If they are non empty string we'll use the custom names\n        // Else just add the default prefix\n        IERC20 namedToken = IERC20(_token);\n\n        if (keccak256(abi.encodePacked(_name)) != keccak256(\"\")) {\n            name = _name;\n        } else {\n            name = string(\n                abi.encodePacked(_defaultNamePrefix, namedToken.name())\n            );\n        }\n\n        if (keccak256(abi.encodePacked(_symbol)) != keccak256(\"\")) {\n            symbol = _symbol;\n        } else {\n            symbol = string(\n                abi.encodePacked(_symbolSymbolPrefix, namedToken.symbol())\n            );\n        }\n\n        // Initializing the lpcomponent token\n        __ERC20_init(name, symbol);\n        // Initialize the other contracts\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        token = IERC20Upgradeable(_token);\n        governance = _governance;\n        treasury = _treasury;\n        strategist = _strategist;\n        keeper = _keeper;\n        guardian = _guardian;\n        badgerTree = _badgerTree;\n        vesting = _vesting;\n\n        lastHarvestedAt = block.timestamp; // setting initial value to the time when the vault was deployed\n\n        performanceFeeGovernance = _feeConfig[0];\n        performanceFeeStrategist = _feeConfig[1];\n        withdrawalFee = _feeConfig[2];\n        managementFee = _feeConfig[3];\n        maxPerformanceFee = PERFORMANCE_FEE_HARD_CAP; // 30% max performance fee\n        maxWithdrawalFee = WITHDRAWAL_FEE_HARD_CAP; // 2% maximum withdrawal fee\n        maxManagementFee = MANAGEMENT_FEE_HARD_CAP; // 2% maximum management fee\n\n        toEarnBps = 9_500; // initial value of toEarnBps // 95% is invested to the strategy, 5% for cheap withdrawals\n    }\n\n    /// ===== Modifiers ====\n\n    /// @notice Checks whether a call is from guardian or governance.\n    function _onlyAuthorizedPausers() internal view {\n        require(\n            msg.sender == guardian || msg.sender == governance,\n            \"onlyPausers\"\n        );\n    }\n\n    /// @notice Checks whether a call is from the strategy.\n    function _onlyStrategy() internal view {\n        require(msg.sender == strategy, \"onlyStrategy\");\n    }\n\n    /// ===== View Functions =====\n\n    /// @notice Used to track the deployed version of the contract.\n    /// @return Current version of the contract.\n    function version() external pure returns (string memory) {\n        return \"1.5\";\n    }\n\n    /// @notice Gives the price for a single Sett share.\n    /// @dev Sett starts with a price per share of 1.\n    /// @return Value of a single share.\n    function getPricePerFullShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return ONE_ETH;\n        }\n        return (balance() * ONE_ETH) / totalSupply();\n    }\n\n    /// @notice Gives the total balance of the underlying token within the sett and strategy system.\n    /// @return Balance of token handled by the sett.\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Defines how much of the Setts' underlying is available for strategy to borrow.\n    /// @return Amount of tokens that the sett can provide to the strategy.\n    function available() public view returns (uint256) {\n        return (token.balanceOf(address(this)) * toEarnBps) / MAX_BPS;\n    }\n\n    /// ===== Public Actions =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _amount Quantity of tokens to deposit.\n    function deposit(uint256 _amount) external whenNotPaused {\n        _depositWithAuthorization(_amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling account is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _amount Quantity of tokens to deposit.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function deposit(uint256 _amount, bytes32[] memory proof)\n        external\n        whenNotPaused\n    {\n        _depositWithAuthorization(_amount, proof);\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    function depositAll() external whenNotPaused {\n        _depositWithAuthorization(\n            token.balanceOf(msg.sender),\n            new bytes32[](0)\n        );\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling is authorized to make a full deposit.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function depositAll(bytes32[] memory proof) external whenNotPaused {\n        _depositWithAuthorization(token.balanceOf(msg.sender), proof);\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(address _recipient, uint256 _amount)\n        external\n        whenNotPaused\n    {\n        _depositForWithAuthorization(_recipient, _amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Checks the guestlist to verify that `recipient` is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) external whenNotPaused {\n        _depositForWithAuthorization(_recipient, _amount, proof);\n    }\n\n    /// @notice Redeems `_shares` for an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused.\n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    /// @param _shares Quantity of shares to redeem.\n    function withdraw(uint256 _shares) external whenNotPaused {\n        _withdraw(_shares);\n    }\n\n    /// @notice Redeems all shares, issuing an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused.\n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    function withdrawAll() external whenNotPaused {\n        _withdraw(balanceOf(msg.sender));\n    }\n\n    /// ===== Permissioned Actions: Strategy =====\n\n    /// @notice Used by the strategy to report a harvest to the sett.\n    ///         Issues shares for the strategist and treasury based on the performance fees and harvested amount.\n    ///         Issues shares for the treasury based on the management fee and the time elapsed since last harvest.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This implicitly trusts that the strategy reports the correct amount.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _harvestedAmount Amount of underlying token harvested by the strategy.\n    function reportHarvest(uint256 _harvestedAmount) external nonReentrant {\n        _onlyStrategy();\n\n        uint256 harvestTime = block.timestamp;\n        uint256 assetsAtHarvest = balance() - _harvestedAmount; // Must be less than or equal or revert\n\n        _handleFees(_harvestedAmount, harvestTime);\n\n        // Updated lastHarvestAmount\n        lastHarvestAmount = _harvestedAmount;\n\n        // if we withdrawAll\n        // we will have some yield left\n        // having 0 for assets will inflate APY\n        // Instead, have the last harvest report with the previous assets\n        // And if you end up harvesting again, that report will have both 0s\n        if (assetsAtHarvest != 0) {\n            assetsAtLastHarvest = assetsAtHarvest;\n        } else if (_harvestedAmount == 0) {\n            // If zero\n            assetsAtLastHarvest = 0;\n        }\n\n        lifeTimeEarned = lifeTimeEarned + _harvestedAmount;\n        // Update time either way\n        lastHarvestedAt = harvestTime;\n\n        emit Harvested(\n            address(token),\n            _harvestedAmount,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// @notice Used by the strategy to report harvest of additional tokens to the sett.\n    ///         Charges performance fees on the additional tokens and transfers fees to treasury and strategist.\n    ///         The remaining amount is sent to badgerTree for emissions.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This function is called after the strategy sends the additional tokens to the sett.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _token Address of additional token harvested by the strategy.\n    function reportAdditionalToken(address _token) external nonReentrant {\n        _onlyStrategy();\n        require(address(token) != _token, \"No want\");\n        uint256 tokenBalance = IERC20Upgradeable(_token).balanceOf(\n            address(this)\n        );\n\n        additionalTokensEarned[_token] =\n            additionalTokensEarned[_token] +\n            tokenBalance;\n        lastAdditionalTokenAmount[_token] = tokenBalance;\n\n        // We may have more, but we still report only what the strat sent\n        uint256 governanceRewardsFee = _calculateFee(\n            tokenBalance,\n            performanceFeeGovernance\n        );\n        uint256 strategistRewardsFee = _calculateFee(\n            tokenBalance,\n            performanceFeeStrategist\n        );\n\n        IERC20Upgradeable(_token).safeTransfer(treasury, governanceRewardsFee);\n        IERC20Upgradeable(_token).safeTransfer(\n            strategist,\n            strategistRewardsFee\n        );\n\n        // Send rest to tree\n        uint256 newBalance = IERC20Upgradeable(_token).balanceOf(address(this));\n        IERC20Upgradeable(_token).safeTransfer(badgerTree, newBalance);\n        emit TreeDistribution(\n            _token,\n            newBalance,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// ===== Permissioned Actions: Governance =====\n\n    /// @notice Changes the treasury address.\n    ///         Treasury is recipient of management and governance performance fees.\n    ///         This can only be called by governance.\n    ///         Note that this can only be called when sett is not paused.\n    /// @param _treasury Address of the new treasury.\n    function setTreasury(address _treasury) external whenNotPaused {\n        _onlyGovernance();\n        require(_treasury != address(0), \"Address 0\");\n\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n\n    /// @notice Changes the strategy address.\n    ///         This can only be called by governance.\n    ///         Note that this can only be called when sett is not paused.\n    /// @dev This is a rug vector, pay extremely close attention to the next strategy being set.\n    ///      Changing the strategy should happen only via timelock.\n    ///      This function must not be callable when the sett is paused as this would force depositors into a strategy they may not want to use.\n    /// @param _strategy Address of new strategy.\n    function setStrategy(address _strategy) external whenNotPaused {\n        _onlyGovernance();\n        require(_strategy != address(0), \"Address 0\");\n\n        /// NOTE: Migrate funds if settings strategy when already existing one\n        if (strategy != address(0)) {\n            require(\n                IStrategy(strategy).balanceOf() == 0,\n                \"Please withdrawToVault before changing strat\"\n            );\n        }\n        strategy = _strategy;\n        emit SetStrategy(_strategy);\n    }\n\n    // === Setters that can be called by governance even when paused ===\n\n    /// @notice Sets the max withdrawal fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `WITHDRAWAL_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for withdrawal fee.\n    function setMaxWithdrawalFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(_fees <= WITHDRAWAL_FEE_HARD_CAP, \"withdrawalFee too high\");\n\n        maxWithdrawalFee = _fees;\n        emit SetMaxWithdrawalFee(_fees);\n    }\n\n    /// @notice Sets the max performance fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `PERFORMANCE_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for performance fee.\n    function setMaxPerformanceFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(\n            _fees <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n\n        maxPerformanceFee = _fees;\n        emit SetMaxPerformanceFee(_fees);\n    }\n\n    /// @notice Sets the max management fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `MANAGEMENT_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for management fee.\n    function setMaxManagementFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(_fees <= MANAGEMENT_FEE_HARD_CAP, \"managementFee too high\");\n\n        maxManagementFee = _fees;\n        emit SetMaxManagementFee(_fees);\n    }\n\n    /// @notice Changes the guardian address.\n    ///         Guardian is an authorized actor that can pause the sett in case of an emergency.\n    ///         This can only be called by governance.\n    /// @param _guardian Address of the new guardian.\n    function setGuardian(address _guardian) external {\n        _onlyGovernance();\n        require(_guardian != address(0), \"Address cannot be 0x0\");\n\n        guardian = _guardian;\n        emit SetGuardian(_guardian);\n    }\n\n    /// @notice Changes the vesting contract address.\n    ///         Vesting contract is used to vest withdrawn tokens linearly over period of 21 days\n    ///         This can only be called by governance.\n    /// @param _vesting Address of the new guardian.\n    function setVesting(address _vesting) external {\n        _onlyGovernance();\n        require(_vesting != address(0), \"Address cannot be 0x0\");\n\n        vesting = _vesting;\n        emit SetVesting(_vesting);\n    }\n\n    /// ===== Permissioned Functions: Trusted Actors =====\n\n    /// @notice Sets the fraction of sett balance (in basis points) that the strategy can borrow.\n    ///         This can be called by either governance or strategist.\n    ///         Note that this can only be called when the sett is not paused.\n    /// @param _newToEarnBps The new maximum cap for management fee.\n    function setToEarnBps(uint256 _newToEarnBps) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_newToEarnBps <= MAX_BPS, \"toEarnBps should be <= MAX_BPS\");\n\n        toEarnBps = _newToEarnBps;\n        emit SetToEarnBps(_newToEarnBps);\n    }\n\n    /// @notice Changes the guestlist address.\n    ///         The guestList is used to gate or limit deposits. If no guestlist is set then anyone can deposit any amount.\n    ///         This can be called by either governance or strategist.\n    ///         Note that this can only be called when the sett is not paused.\n    /// @param _guestList Address of the new guestlist.\n    function setGuestList(address _guestList) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        guestList = IBadgerGuestlist(_guestList);\n        emit SetGuestList(_guestList);\n    }\n\n    /// @notice Sets the withdrawal fee charged by the Sett.\n    ///         The fee is taken at the time of withdrawals in the underlying token which is then used to issue new shares for the treasury.\n    ///         The new withdrawal fee should be less than `maxWithdrawalFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `_withdraw` to see how withdrawal fee is charged.\n    /// @param _withdrawalFee The new withdrawal fee.\n    function setWithdrawalFee(uint256 _withdrawalFee) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_withdrawalFee <= maxWithdrawalFee, \"Excessive withdrawal fee\");\n        withdrawalFee = _withdrawalFee;\n        emit SetWithdrawalFee(_withdrawalFee);\n    }\n\n    /// @notice Sets the performance fee taken by the strategist on the harvests.\n    ///         The fee is taken at the time of harvest reporting for both the underlying token and additional tokens.\n    ///         For the underlying token, the fee is used to issue new shares for the strategist.\n    ///         The new performance fee should be less than `maxPerformanceFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `reportHarvest` and `reportAdditionalToken` to see how performance fees are charged.\n    /// @param _performanceFeeStrategist The new performance fee.\n    function setPerformanceFeeStrategist(uint256 _performanceFeeStrategist)\n        external\n        whenNotPaused\n    {\n        _onlyGovernanceOrStrategist();\n        require(\n            _performanceFeeStrategist <= maxPerformanceFee,\n            \"Excessive strategist performance fee\"\n        );\n        performanceFeeStrategist = _performanceFeeStrategist;\n        emit SetPerformanceFeeStrategist(_performanceFeeStrategist);\n    }\n\n    /// @notice Sets the performance fee taken by the treasury on the harvests.\n    ///         The fee is taken at the time of harvest reporting for both the underlying token and additional tokens.\n    ///         For the underlying token, the fee is used to issue new shares for the treasury.\n    ///         The new performance fee should be less than `maxPerformanceFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `reportHarvest` and `reportAdditionalToken` to see how performance fees are charged.\n    /// @param _performanceFeeGovernance The new performance fee.\n    function setPerformanceFeeGovernance(uint256 _performanceFeeGovernance)\n        external\n        whenNotPaused\n    {\n        _onlyGovernanceOrStrategist();\n        require(\n            _performanceFeeGovernance <= maxPerformanceFee,\n            \"Excessive governance performance fee\"\n        );\n        performanceFeeGovernance = _performanceFeeGovernance;\n        emit SetPerformanceFeeGovernance(_performanceFeeGovernance);\n    }\n\n    /// @notice Sets the management fee taken by the treasury on the AUM in the sett.\n    ///         The fee is calculated at the time of `reportHarvest` and is used to issue new shares for the treasury.\n    ///         The new management fee should be less than `maxManagementFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `_handleFees` to see how the management fee is calculated.\n    /// @param _fees The new management fee.\n    function setManagementFee(uint256 _fees) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_fees <= maxManagementFee, \"Excessive management fee\");\n        managementFee = _fees;\n        emit SetManagementFee(_fees);\n    }\n\n    /// === Strategist level operations that can be done even when paused ==\n\n    /// @notice Withdraws all funds from the strategy back to the sett.\n    ///         This can be called by either governance or strategist.\n    /// @dev This calls `_withdrawAll` on the strategy and transfers the balance to the sett.\n    function withdrawToVault() external {\n        _onlyGovernanceOrStrategist();\n        IStrategy(strategy).withdrawToVault();\n    }\n\n    /// @notice Sends balance of any extra token earned by the strategy (from airdrops, donations etc.)\n    ///         to the badgerTree for emissions.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by either strategist or governance.\n    /// @dev See `BaseStrategy.emitNonProtectedToken` for details.\n    /// @param _token Address of the token to be emitted.\n    function emitNonProtectedToken(address _token) external {\n        _onlyGovernanceOrStrategist();\n\n        IStrategy(strategy).emitNonProtectedToken(_token);\n    }\n\n    /// @notice Sweeps the balance of an extra token from the vault and strategy and sends it to governance.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by either strategist or governance.\n    /// @dev Sweeping doesn't take any fee.\n    /// @param _token Address of the token to be swept.\n    function sweepExtraToken(address _token) external {\n        _onlyGovernanceOrStrategist();\n        require(address(token) != _token, \"No want\");\n\n        IStrategy(strategy).withdrawOther(_token);\n        // Send all `_token` we have\n        // Safe because `withdrawOther` will revert on protected tokens\n        // Done this way works for both a donation to strategy or to vault\n        IERC20Upgradeable(_token).safeTransfer(\n            governance,\n            IERC20Upgradeable(_token).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Deposits the available balance of the underlying token into the strategy.\n    ///         The strategy then uses the amount for yield-generating activities.\n    ///         This can be called by either the keeper or governance.\n    ///         Note that earn cannot be called when deposits are paused.\n    /// @dev Pause is enforced at the Strategy level (this allows to still earn yield when the Vault is paused)\n    function earn() external {\n        require(!pausedDeposit, \"pausedDeposit\"); // dev: deposits are paused, we don't earn as well\n        _onlyAuthorizedActors();\n\n        uint256 _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IStrategy(strategy).earn();\n    }\n\n    /// @notice Pauses only deposits.\n    ///         This can be called by either guardian or governance.\n    function pauseDeposits() external {\n        _onlyAuthorizedPausers();\n        pausedDeposit = true;\n        emit PauseDeposits(msg.sender);\n    }\n\n    /// @notice Unpauses deposits.\n    ///         This can only be called by governance.\n    function unpauseDeposits() external {\n        _onlyGovernance();\n        pausedDeposit = false;\n        emit UnpauseDeposits(msg.sender);\n    }\n\n    /// @notice Pauses everything.\n    ///         This can be called by either guardian or governance.\n    function pause() external {\n        _onlyAuthorizedPausers();\n        _pause();\n    }\n\n    /// @notice Unpauses everything\n    ///         This can only be called by governance.\n    function unpause() external {\n        _onlyGovernance();\n        _unpause();\n    }\n\n    /// ===== Internal Implementations =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Note that deposits are not accepted when `pausedDeposit` is true.\n    /// @dev This is the actual deposit operation.\n    ///      Deposits are based on the realized value of underlying assets between Sett & associated Strategy\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function _depositFor(address _recipient, uint256 _amount)\n        internal\n        nonReentrant\n    {\n        require(_recipient != address(0), \"Address 0\");\n        require(_amount != 0, \"Amount 0\");\n        require(!pausedDeposit, \"pausedDeposit\"); // dev: deposits are paused\n\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _mintSharesFor(_recipient, _after - _before, _pool);\n    }\n\n    /// @dev See `_depositWithAuthorization`\n    function _depositWithAuthorization(uint256 _amount, bytes32[] memory proof)\n        internal\n    {\n        _depositForWithAuthorization(msg.sender, _amount, proof);\n    }\n\n    /// @dev Verifies that `_recipient` is authorized to deposit `_amount` based on the guestlist.\n    ///      See `_depositFor` for deposit details.\n    function _depositForWithAuthorization(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) internal {\n        if (address(guestList) != address(0)) {\n            require(\n                guestList.authorized(_recipient, _amount, proof),\n                \"GuestList: Not Authorized\"\n            );\n        }\n        _depositFor(_recipient, _amount);\n    }\n\n    /// @notice Redeems `_shares` for an appropriate amount of tokens.\n    /// @dev This is the actual withdraw operation.\n    ///      Withdraws from strategy positions if sett doesn't contain enough tokens to process the withdrawal.\n    ///      Calculates withdrawal fees and issues corresponding shares to treasury.\n    ///      No rebalance implementation for lower fees and faster swaps\n    /// @param _shares Quantity of shares to redeem.\n    function _withdraw(uint256 _shares) internal nonReentrant {\n        require(_shares != 0, \"0 Shares\");\n\n        uint256 r = (balance() * _shares) / totalSupply();\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 b = token.balanceOf(address(this));\n        if (b < r) {\n            uint256 _toWithdraw = r - b;\n            IStrategy(strategy).withdraw(_toWithdraw);\n            uint256 _after = token.balanceOf(address(this));\n            uint256 _diff = _after - b;\n            if (_diff < _toWithdraw) {\n                r = b + _diff;\n            }\n        }\n\n        uint256 _fee = _calculateFee(r, withdrawalFee);\n        uint256 _amount = r - _fee;\n\n        // Send funds to vesting contract and setup vesting\n        IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);\n        token.safeTransfer(vesting, _amount);\n\n        // After you burned the shares, and you have sent the funds, adding here is equivalent to depositing\n        // Process withdrawal fee\n        if(_fee > 0) {\n            _mintSharesFor(treasury, _fee, balance() - _fee);\n        }\n    }\n\n    /// @dev Helper function to calculate fees.\n    /// @param amount Amount to calculate fee on.\n    /// @param feeBps The fee to be charged in basis points.\n    /// @return Amount of fees to take.\n    function _calculateFee(uint256 amount, uint256 feeBps)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (feeBps == 0) {\n            return 0;\n        }\n        uint256 fee = (amount * feeBps) / MAX_BPS;\n        return fee;\n    }\n\n    /// @dev Helper function to calculate governance and strategist performance fees. Make sure to use it to get paid!\n    /// @param _amount Amount to calculate fee on.\n    /// @return Tuple containing amount of (governance, strategist) fees to take.\n    function _calculatePerformanceFee(uint256 _amount)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        uint256 governancePerformanceFee = _calculateFee(\n            _amount,\n            performanceFeeGovernance\n        );\n\n        uint256 strategistPerformanceFee = _calculateFee(\n            _amount,\n            performanceFeeStrategist\n        );\n\n        return (governancePerformanceFee, strategistPerformanceFee);\n    }\n\n    /// @dev Helper function to issue shares to `recipient` based on an input `_amount` and `_pool` size.\n    /// @param recipient Address to issue shares to.\n    /// @param _amount Amount to issue shares on.\n    /// @param _pool Pool size to use while calculating amount of shares to mint.\n    function _mintSharesFor(\n        address recipient,\n        uint256 _amount,\n        uint256 _pool\n    ) internal {\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount * totalSupply()) / _pool;\n        }\n        _mint(recipient, shares);\n    }\n\n    /// @dev Helper function that issues shares based on performance and management fee when a harvest is reported.\n    /// @param _harvestedAmount The harvested amount to take fee on.\n    /// @param harvestTime Time of harvest (block.timestamp).\n    function _handleFees(uint256 _harvestedAmount, uint256 harvestTime)\n        internal\n    {\n        (\n            uint256 feeGovernance,\n            uint256 feeStrategist\n        ) = _calculatePerformanceFee(_harvestedAmount);\n        uint256 duration = harvestTime - lastHarvestedAt;\n\n        // Management fee is calculated against the assets before harvest, to make it fair to depositors\n        uint256 management_fee = managementFee > 0\n            ? (managementFee * (balance() - _harvestedAmount) * duration) /\n                SECS_PER_YEAR /\n                MAX_BPS\n            : 0;\n        uint256 totalGovernanceFee = feeGovernance + management_fee;\n\n        // Pool size is the size of the pool minus the fees, this way\n        // it's equivalent to sending the tokens as rewards after the harvest\n        // and depositing them again\n        uint256 _pool = balance() - totalGovernanceFee - feeStrategist;\n\n        // uint != is cheaper and equivalent to >\n        if (totalGovernanceFee != 0) {\n            _mintSharesFor(treasury, totalGovernanceFee, _pool);\n        }\n\n        if (feeStrategist != 0 && strategist != address(0)) {\n            /// NOTE: adding feeGovernance backed to _pool as shares would have been issued for it.\n            _mintSharesFor(\n                strategist,\n                feeStrategist,\n                _pool + totalGovernanceFee\n            );\n        }\n    }\n}\ncontract StakedCitadelVester is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n\n    struct VestingParams {\n        uint256 unlockBegin;\n        uint256 unlockEnd;\n        uint256 lockedAmounts;\n        uint256 claimedAmounts;\n    }\n\n    IERC20Upgradeable public vestingToken;\n    address public vault;\n    mapping(address => VestingParams) public vesting;\n\n    uint256 public constant INITIAL_VESTING_DURATION = 86400 * 21; // 21 days of vesting\n    uint256 public vestingDuration;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Vest(\n        address indexed recipient,\n        uint256 _amount,\n        uint256 _unlockBegin,\n        uint256 _unlockEnd\n    );\n    event Claimed(\n        address indexed owner,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    event SetVestingDuration(uint256 duration);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    function initialize(\n        address _gac,\n        address _vestingToken,\n        address _vault\n    ) external initializer {\n        require(_vestingToken != address(0), \"Address zero invalid\");\n        require(_vault != address(0), \"Address zero invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        vestingDuration = INITIAL_VESTING_DURATION;\n\n        vestingToken = IERC20Upgradeable(_vestingToken);\n        vault = _vault;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Claims the caller's tokens that have been unlocked, sending them to `recipient`.\n     * @param recipient The account to transfer unlocked tokens to.\n     * @param amount The amount to transfer. If greater than the claimable amount, the maximum is transferred.\n     */\n    function claim(address recipient, uint256 amount) external {\n        uint256 claimable = claimableBalance(msg.sender);\n        if (amount > claimable) {\n            amount = claimable;\n        }\n        if (amount != 0) {\n            vesting[msg.sender].claimedAmounts =\n                vesting[msg.sender].claimedAmounts +\n                amount;\n            vestingToken.safeTransfer(recipient, amount);\n            emit Claimed(msg.sender, recipient, amount);\n        }\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Returns the maximum number of tokens currently claimable by `recipient`.\n     * @param recipient The account to check the claimable balance of.\n     * @return The number of tokens currently claimable.\n     */\n    function claimableBalance(address recipient) public view returns (uint256) {\n        uint256 locked = vesting[recipient].lockedAmounts;\n        uint256 claimed = vesting[recipient].claimedAmounts;\n        if (block.timestamp >= vesting[recipient].unlockEnd) {\n            return locked - claimed;\n        }\n        return\n            ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /\n                (vesting[recipient].unlockEnd -\n                    vesting[recipient].unlockBegin)) - claimed;\n    }\n\n    /// =========================\n    /// ===== Vault actions =====\n    /// =========================\n\n    /**\n     * @dev setup vesting for recipient.\n     * @notice note that a given address can only have one active vest at a time.\n     * @notice adding a new vest before claiming completely from the previous will re-lock the previous amount according to the new vesting timeline.\n     * @param recipient The account for which vesting will be setup.\n     * @param _amount amount that will be vested\n     * @param _unlockBegin The time at which unlocking of tokens will begin.\n     */\n    function vest(\n        address recipient,\n        uint256 _amount,\n        uint256 _unlockBegin\n    ) external {\n        require(msg.sender == vault, \"StakedCitadelVester: only xCTDL vault\");\n        require(_amount > 0, \"StakedCitadelVester: cannot vest 0\");\n\n        vesting[recipient].lockedAmounts =\n            vesting[recipient].lockedAmounts +\n            _amount;\n        vesting[recipient].unlockBegin = _unlockBegin;\n        vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;\n\n        emit Vest(\n            recipient,\n            vesting[recipient].lockedAmounts,\n            _unlockBegin,\n            vesting[recipient].unlockEnd\n        );\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    /**\n     * @notice modify vesting duration\n     * @dev does not affect currently active vests, only future vests\n     * @param _duration new vesting duration\n     */\n    function setVestingDuration(uint256 _duration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        vestingDuration = _duration;\n        emit SetVestingDuration(_duration);\n    }\n}\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\ncontract KnightingRound is GlobalAccessControlManaged, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for ERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant TREASURY_GOVERNANCE_ROLE =\n        keccak256(\"TREASURY_GOVERNANCE_ROLE\");\n\n    bytes32 public constant TECH_OPERATIONS_ROLE =\n        keccak256(\"TECH_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE =\n        keccak256(\"TREASURY_OPERATIONS_ROLE\");\n\n    /// token to give out (CTDL)\n    ERC20Upgradeable public tokenOut;\n    /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n    ERC20Upgradeable public tokenIn;\n    /// time when tokens can be first purchased\n    uint256 public saleStart;\n    /// duration of the token sale, cannot purchase afterwards\n    uint256 public saleDuration;\n    /// address receiving the proceeds of the sale - will be citadel multisig\n    address public saleRecipient;\n    /// whether the sale has been finalized\n    bool public finalized;\n\n    /// tokenIn per tokenOut price\n    /// eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public tokenOutPrice;\n\n    /// Amounts bought by accounts\n    mapping(address => uint256) public boughtAmounts;\n    /// Whether an account has claimed tokens\n    /// NOTE: can reset boughtAmounts after a claim to optimize gas\n    ///       but we need to persist boughtAmounts\n    mapping(address => bool) public hasClaimed;\n\n    /// Amount of `tokenIn` taken in\n    uint256 public totalTokenIn;\n    /// Amount of `tokenOut` sold\n    uint256 public totalTokenOutBought;\n    /// Amount of `tokenOut` claimed\n    uint256 public totalTokenOutClaimed;\n\n    /// Max tokenIn that can be taken by the contract (defines the cap for tokenOut sold)\n    uint256 public tokenInLimit;\n\n    uint256 public tokenInNormalizationValue;\n\n    /// Whitelist\n    IBadgerVipGuestlist public guestlist;\n\n    /// Amount vote for each DAO\n    mapping(uint8 => uint256) public daoCommitments;\n    mapping(address => uint8) public daoVotedFor;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Sale(\n        address indexed buyer,\n        uint8 indexed daoId,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event Claim(address indexed claimer, uint256 amount);\n    event Finalized();\n\n    event SaleStartUpdated(uint256 saleStart);\n    event SaleDurationUpdated(uint256 saleDuration);\n    event TokenOutPriceUpdated(uint256 tokenOutPrice);\n    event SaleRecipientUpdated(address indexed recipient);\n    event GuestlistUpdated(address indexed guestlist);\n    event TokenInLimitUpdated(uint256 tokenInLimit);\n\n    event Sweep(address indexed token, uint256 amount);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _tokenOut The token this contract will return in a trade (citadel)\n     * @param _tokenIn The token this contract will receive in a trade\n     * @param _saleStart The time when tokens can be first purchased\n     * @param _saleDuration The duration of the token sale\n     * @param _tokenOutPrice The tokenOut per tokenIn price\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _guestlist Address that will manage auction approvals\n     * @param _tokenInLimit The max tokenIn that the contract can take\n     */\n    function initialize(\n        address _globalAccessControl,\n        address _tokenOut,\n        address _tokenIn,\n        uint256 _saleStart,\n        uint256 _saleDuration,\n        uint256 _tokenOutPrice,\n        address _saleRecipient,\n        address _guestlist,\n        uint256 _tokenInLimit\n    ) external initializer {\n        require(\n            _saleStart >= block.timestamp,\n            \"KnightingRound: start date may not be in the past\"\n        );\n        require(\n            _saleDuration > 0,\n            \"KnightingRound: the sale duration must not be zero\"\n        );\n        require(\n            _tokenOutPrice > 0,\n            \"KnightingRound: the price must not be zero\"\n        );\n        require(\n            _saleRecipient != address(0),\n            \"KnightingRound: sale recipient should not be zero\"\n        );\n\n        __GlobalAccessControlManaged_init(_globalAccessControl);\n\n        tokenOut = ERC20Upgradeable(_tokenOut);\n        tokenIn = ERC20Upgradeable(_tokenIn);\n        saleStart = _saleStart;\n        saleDuration = _saleDuration;\n        tokenOutPrice = _tokenOutPrice;\n        saleRecipient = _saleRecipient;\n        guestlist = IBadgerVipGuestlist(_guestlist);\n        tokenInLimit = _tokenInLimit;\n\n        tokenInNormalizationValue = 10**tokenIn.decimals();\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_tokenInAmount` of `tokenIn` for `tokenOut`\n     * @param _tokenInAmount Amount of `tokenIn` to give\n     * @param _daoId ID of DAO to vote for\n     * @param _proof Merkle proof for the guestlist. Use `new bytes32[](0)` if there's no guestlist\n     * @return tokenOutAmount_ Amount of `tokenOut` bought\n     */\n    function buy(\n        uint256 _tokenInAmount,\n        uint8 _daoId,\n        bytes32[] calldata _proof\n    ) external gacPausable returns (uint256 tokenOutAmount_) {\n        require(saleStart <= block.timestamp, \"KnightingRound: not started\");\n        require(\n            block.timestamp < saleStart + saleDuration,\n            \"KnightingRound: already ended\"\n        );\n        require(_tokenInAmount > 0, \"_tokenInAmount should be > 0\");\n        require(\n            totalTokenIn + _tokenInAmount <= tokenInLimit,\n            \"total amount exceeded\"\n        );\n\n        if (address(guestlist) != address(0)) {\n            require(guestlist.authorized(msg.sender, _proof), \"not authorized\");\n        }\n\n        uint256 boughtAmountTillNow = boughtAmounts[msg.sender];\n\n        if (boughtAmountTillNow > 0) {\n            require(\n                _daoId == daoVotedFor[msg.sender],\n                \"can't vote for multiple daos\"\n            );\n        } else {\n            daoVotedFor[msg.sender] = _daoId;\n        }\n\n        tokenOutAmount_ = getAmountOut(_tokenInAmount);\n\n        boughtAmounts[msg.sender] = boughtAmountTillNow + tokenOutAmount_;\n        daoCommitments[_daoId] = daoCommitments[_daoId] + tokenOutAmount_;\n\n        totalTokenIn = totalTokenIn + _tokenInAmount;\n        totalTokenOutBought = totalTokenOutBought + tokenOutAmount_;\n\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n\n        emit Sale(msg.sender, _daoId, _tokenInAmount, tokenOutAmount_);\n    }\n\n    /**\n     * @notice Claim bought tokens after sale has been finalized\n     */\n    function claim() external gacPausable returns (uint256 tokenOutAmount_) {\n        require(finalized, \"sale not finalized\");\n        require(!hasClaimed[msg.sender], \"already claimed\");\n\n        tokenOutAmount_ = boughtAmounts[msg.sender];\n\n        require(tokenOutAmount_ > 0, \"nothing to claim\");\n\n        hasClaimed[msg.sender] = true;\n        totalTokenOutClaimed = totalTokenOutClaimed + tokenOutAmount_;\n\n        tokenOut.safeTransfer(msg.sender, tokenOutAmount_);\n\n        emit Claim(msg.sender, tokenOutAmount_);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `tokenIn`\n     * @param _tokenInAmount Amount of `tokenIn` to exchange\n     * @return tokenOutAmount_ Amount of `tokenOut` received\n     */\n    function getAmountOut(uint256 _tokenInAmount)\n        public\n        view\n        returns (uint256 tokenOutAmount_)\n    {\n        tokenOutAmount_ =\n            (_tokenInAmount * tokenOutPrice) /\n            tokenInNormalizationValue;\n    }\n\n    /**\n     * @notice Check how much `tokenIn` can still be taken in\n     * @return limitLeft_ Amount of `tokenIn` that can still be exchanged\n     */\n    function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {\n        if (totalTokenIn < tokenInLimit) {\n            limitLeft_ = tokenInLimit - totalTokenIn;\n        }\n    }\n\n    /**\n     * @notice Check if the sale has ended\n     * @return hasEnded_ True if the sale has ended\n     */\n    function saleEnded() public view returns (bool hasEnded_) {\n        hasEnded_ =\n            (block.timestamp >= saleStart + saleDuration) ||\n            (totalTokenIn >= tokenInLimit);\n    }\n\n    /// ====================================\n    /// ===== Permissioned: governance =====\n    /// ====================================\n\n    /**\n     * @notice Finalize the sale after sale duration. Can only be called by owner\n       @dev Ensure contract has enough `tokenOut` before calling\n     */\n    function finalize() external onlyRole(CONTRACT_GOVERNANCE_ROLE) {\n        require(!finalized, \"KnightingRound: already finalized\");\n        require(saleEnded(), \"KnightingRound: not finished\");\n        require(\n            tokenOut.balanceOf(address(this)) >= totalTokenOutBought,\n            \"KnightingRound: not enough balance\"\n        );\n\n        finalized = true;\n\n        emit Finalized();\n    }\n\n    /**\n     * @notice Update the sale start time. Can only be called by owner\n     * @param _saleStart New start time\n     */\n    function setSaleStart(uint256 _saleStart)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleStart >= block.timestamp,\n            \"KnightingRound: start date may not be in the past\"\n        );\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        saleStart = _saleStart;\n\n        emit SaleStartUpdated(_saleStart);\n    }\n\n    /**\n     * @notice Update sale duration. Can only be called by owner\n     * @param _saleDuration New duration\n     */\n    function setSaleDuration(uint256 _saleDuration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleDuration > 0,\n            \"KnightingRound: the sale duration must not be zero\"\n        );\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        saleDuration = _saleDuration;\n\n        emit SaleDurationUpdated(_saleDuration);\n    }\n\n    /**\n     * @notice Modify the tokenOut price in. Can only be called by owner\n     * @param _tokenOutPrice New tokenOut price\n     */\n    function setTokenOutPrice(uint256 _tokenOutPrice)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _tokenOutPrice > 0,\n            \"KnightingRound: the price must not be zero\"\n        );\n\n        tokenOutPrice = _tokenOutPrice;\n\n        emit TokenOutPriceUpdated(_tokenOutPrice);\n    }\n\n    /**\n     * @notice Update the `tokenIn` receipient address. Can only be called by owner\n     * @param _saleRecipient New recipient address\n     */\n    function setSaleRecipient(address _saleRecipient)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleRecipient != address(0),\n            \"KnightingRound: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    /// ============================\n    /// ===== Tech ops actions =====\n    /// ============================\n\n    /**\n     * @notice Update the guestlist address. Can only be called by owner\n     * @param _guestlist New guestlist address\n     */\n    function setGuestlist(address _guestlist)\n        external\n        onlyRole(TECH_OPERATIONS_ROLE)\n    {\n        guestlist = IBadgerVipGuestlist(_guestlist);\n\n        emit GuestlistUpdated(_guestlist);\n    }\n\n    /**\n     * @notice Modify the max tokenIn that this contract can take. Can only be called by owner\n     * @param _tokenInLimit New max amountIn\n     */\n    function setTokenInLimit(uint256 _tokenInLimit)\n        external\n        onlyRole(TECH_OPERATIONS_ROLE)\n    {\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        tokenInLimit = _tokenInLimit;\n\n        emit TokenInLimitUpdated(_tokenInLimit);\n    }\n\n    /// ================================\n    /// ===== Treasury Ops actions =====\n    /// ================================\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `tokenIn` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `tokenIn`. For `tokenOut`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token) external gacPausable nonReentrant onlyRole(TREASURY_OPERATIONS_ROLE) {\n        uint256 amount = ERC20Upgradeable(_token).balanceOf(address(this));\n\n        if (_token == address(tokenOut)) {\n            uint256 amountLeftToBeClaimed = totalTokenOutBought -\n                totalTokenOutClaimed;\n            amount = amount - amountLeftToBeClaimed;\n        }\n\n        require(amount > 0, \"nothing to sweep\");\n\n        emit Sweep(_token, amount);\n        ERC20Upgradeable(_token).safeTransfer(saleRecipient, amount);\n    }\n}\ncontract CitadelMinter is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n\n    ICitadelToken public citadelToken;\n    IVault public xCitadel;\n    IStakedCitadelLocker public xCitadelLocker;\n    ISupplySchedule public supplySchedule;\n\n    uint256 public lastMintTimestamp;\n\n    uint256 constant MAX_BPS = 10000;\n\n    EnumerableSetUpgradeable.AddressSet internal fundingPools;\n    mapping(address => uint256) public fundingPoolWeights;\n    uint256 public totalFundingPoolWeight;\n\n    uint256 public fundingBps;\n    uint256 public stakingBps;\n    uint256 public lockingBps;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event FundingPoolWeightSet(\n        address pool,\n        uint256 weight,\n        uint256 totalFundingPoolWeight\n    );\n    event CitadelDistributionSplitSet(\n        uint256 fundingBps,\n        uint256 stakingBps,\n        uint256 lockingBps\n    );\n    event CitadelDistribution(\n        uint256 fundingAmount,\n        uint256 stakingAmount,\n        uint256 lockingAmount\n    );\n\n    event CitadelDistributionToFunding(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToFundingPool(\n        uint256 startTime,\n        uint256 endTime,\n        address pool,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToStaking(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToLocking(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount,\n        uint256 xCitadelAmount\n    );\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @dev this contract must have the rights to mint the citadel token to function correctly\n     * @dev this contract is intended to be the only way citadel is minted, with the expection of the initial minting event\n     * @param _gac global access control which is pinged to allow / deny access to permissioned calls by role\n     * @param _citadelToken citadel token\n     * @param _xCitadel staked citadel\n     * @param _xCitadelLocker staked citadel locker\n     * @param _supplySchedule contract that determines how much citadel to mint at a given time\n     */\n    function initialize(\n        address _gac,\n        address _citadelToken,\n        address _xCitadel,\n        address _xCitadelLocker,\n        address _supplySchedule\n    ) external initializer {\n        require(_gac != address(0), \"address 0 invalid\");\n        require(_citadelToken != address(0), \"address 0 invalid\");\n        require(_xCitadel != address(0), \"address 0 invalid\");\n        require(_xCitadelLocker != address(0), \"address 0 invalid\");\n        require(_supplySchedule != address(0), \"address 0 invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        citadelToken = ICitadelToken(_citadelToken);\n        xCitadel = IVault(_xCitadel);\n        xCitadelLocker = IStakedCitadelLocker(_xCitadelLocker);\n\n        supplySchedule = ISupplySchedule(_supplySchedule);\n\n        // Approve xCitadel vault for use of citadel tokens\n        // NOTE: Using input params as those cost 3 to read vs 100 from storage\n        IERC20Upgradeable(_citadelToken).safeApprove(_xCitadel, type(uint256).max);\n\n        // Approve xCitadel for locker to use\n        IERC20Upgradeable(_xCitadel).safeApprove(_xCitadelLocker, type(uint256).max);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    function getFundingPoolWeights()\n        external\n        view\n        returns (address[] memory pools, uint256[] memory weights)\n    {\n        uint256 numPools = fundingPools.length();\n        pools = new address[](numPools);\n        weights = new uint256[](numPools);\n\n        for (uint256 i = 0; i < numPools; i++) {\n            address pool = fundingPools.at(i);\n            uint256 weight = fundingPoolWeights[pool];\n\n            pools[i] = pool;\n            weights[i] = weight;\n        }\n    }\n\n    /// ==============================\n    /// ===== Policy Ops actions =====\n    /// ==============================\n\n    /**\n     * @notice Update the state of citadel emissions by minting and distributing citadel tokens according to the emission schedule and proportional splits between destinations (e.g. funding pools, stakers, lockers)\n     * @dev In theory this call should be permissionless, and after sufficient security analysis this may be changed to be the case\n     */\n    function mintAndDistribute()\n        external\n        onlyRole(POLICY_OPERATIONS_ROLE)\n        gacPausable\n        nonReentrant\n    {\n        uint256 cachedLastMintTimestamp = lastMintTimestamp;\n\n        uint256 mintable = supplySchedule.getMintable(cachedLastMintTimestamp);\n        citadelToken.mint(address(this), mintable);\n\n        uint256 lockingAmount = 0;\n        uint256 stakingAmount = 0;\n        uint256 fundingAmount = 0;\n\n        // 3 gas to store + 3 to read\n        // Saves 100 gas for each time we xCitadel\n        IVault cachedXCitadel = xCitadel;\n\n        // Saves gas below if true\n        uint256 cachedLockingBps = lockingBps;\n        if (cachedLockingBps != 0) {\n            lockingAmount = (mintable * cachedLockingBps) / MAX_BPS;\n\n            uint256 beforeAmount = cachedXCitadel.balanceOf(address(this));\n\n            IVault(cachedXCitadel).deposit(lockingAmount);\n\n            uint256 afterAmount = cachedXCitadel.balanceOf(address(this));\n\n            uint256 xCitadelToLockers = afterAmount - beforeAmount;\n\n            xCitadelLocker.notifyRewardAmount(\n                address(cachedXCitadel),\n                xCitadelToLockers\n            );\n            emit CitadelDistributionToLocking(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                lockingAmount,\n                xCitadelToLockers\n            );\n        }\n\n        uint256 cachedStakingBps = stakingBps;\n        if (cachedStakingBps != 0) {\n            stakingAmount = (mintable * cachedStakingBps) / MAX_BPS;\n\n            IERC20Upgradeable(address(citadelToken)).safeTransfer(address(cachedXCitadel), stakingAmount);\n            emit CitadelDistributionToStaking(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                stakingAmount\n            );\n        }\n\n        /// Saves gas if the if is true, if it's not costs 6 extra gas\n        uint256 cachedFundingBps = fundingBps;\n        if (cachedFundingBps != 0) {\n            fundingAmount = (mintable * cachedFundingBps) / MAX_BPS;\n\n            _transferToFundingPools(fundingAmount);\n            emit CitadelDistributionToFunding(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                fundingAmount\n            );\n        }\n\n        emit CitadelDistribution(fundingAmount, stakingAmount, lockingAmount);\n\n        lastMintTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Set the funding weight for a given address.\n     * @dev If the pool does not exist and is assigned a weight\n     * @dev Setting the funding pool weight to 0 for an existing pool will delete it from the set\n     * @param _pool Address of funding pool contract to add\n     * @param _weight Weight to give to pool. Must be between 0 and 10000, inclusive\n     */\n    function setFundingPoolWeight(address _pool, uint256 _weight)\n        external\n        onlyRole(POLICY_OPERATIONS_ROLE)\n        gacPausable\n        nonReentrant\n    {\n        require(\n            address(_pool) != address(0),\n            \"CitadelMinter: address(0) check\"\n        );\n\n        bool poolExists = fundingPools.contains(_pool);\n\n        // NOTE: Could cachedTotalFundingPoolWeight but honestly logic is already messy enough\n\n        // Remove existing pool on 0 weight\n        if (_weight == 0 && poolExists) {\n            _removeFundingPool(_pool);\n\n            emit FundingPoolWeightSet(_pool, _weight, totalFundingPoolWeight);\n        } else if (_weight > 0) {\n            // Add new pool or modify existing pool\n            require(_weight <= 10000, \"exceed max funding pool weight\");\n            if (!poolExists) {\n                _addFundingPool(_pool);\n            }\n            uint256 _newTotalWeight = totalFundingPoolWeight;\n            _newTotalWeight = _newTotalWeight - fundingPoolWeights[_pool];\n            fundingPoolWeights[_pool] = _weight;\n            _newTotalWeight = _newTotalWeight + _weight;\n            totalFundingPoolWeight = _newTotalWeight;\n\n            emit FundingPoolWeightSet(_pool, _weight, _newTotalWeight);\n        }\n    }\n\n    /**\n     * @notice Set the proportions of newly minted citadel to go to funding pools, stakers, and lockers on mintAndDistribute() calls\n     * @dev This is decided according to the treasury / marketcap logic outlined in the tokenomics, and is intended to be automated on-chain when safe\n     * @dev Sum of basis point values supplied must exactly equal 10000 (100%)\n     * @param _fundingBps Percentage of newly minted citadel to be allocated to funding pools, in basis points\n     * @param _stakingBps Percentage of newly minted citadel to be allocated to stakers as auto-compounding xCitadel rewards, in basis points\n     * @param _lockingBps Percentage of newly minted citadel to be allocated to lockers as emitted xCitadel rewards, in basis points\n     */\n    function setCitadelDistributionSplit(\n        uint256 _fundingBps,\n        uint256 _stakingBps,\n        uint256 _lockingBps\n    ) external onlyRole(POLICY_OPERATIONS_ROLE) gacPausable nonReentrant {\n        require(\n            _fundingBps + _stakingBps + _lockingBps == MAX_BPS,\n            \"CitadelMinter: Sum of propvalues must be 10000 bps\"\n        );\n        fundingBps = _fundingBps;\n        stakingBps = _stakingBps;\n        lockingBps = _lockingBps;\n\n        emit CitadelDistributionSplitSet(_fundingBps, _stakingBps, _lockingBps);\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    function initializeLastMintTimestamp()\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n        gacPausable\n    {\n        require(\n            lastMintTimestamp == 0,\n            \"CitadelMinter: last mint timestamp already initialized\"\n        );\n        uint256 globalStartTimestamp = ISupplySchedule(supplySchedule)\n            .globalStartTimestamp();\n\n        require(\n            globalStartTimestamp != 0,\n            \"CitadelMinter: supply schedule start not initialized\"\n        );\n        lastMintTimestamp = globalStartTimestamp;\n    }\n\n    /// ==============================\n    /// ===== Internal Functions =====\n    /// ==============================\n\n    // === Funding Pool Management ===\n    function _transferToFundingPools(uint256 _citadelAmount) internal {\n        uint256 length = fundingPools.length();\n        // Use cached to save 96 gas per loop read\n        uint256 cachedTotalFundingPoolWeight = totalFundingPoolWeight;\n\n        require(length > 0, \"CitadelMinter: no funding pools\");\n        for (uint256 i; i < length; ++i) {\n            address pool = fundingPools.at(i);\n            uint256 weight = fundingPoolWeights[pool];\n\n            uint256 amount = (_citadelAmount * weight) /\n                cachedTotalFundingPoolWeight;\n\n            IERC20Upgradeable(address(citadelToken)).safeTransfer(pool, amount);\n\n            emit CitadelDistributionToFundingPool(\n                lastMintTimestamp,\n                block.timestamp,\n                pool,\n                amount\n            );\n        }\n    }\n\n    function _removeFundingPool(address _pool) internal {\n        uint256 currentPoolWeight = fundingPoolWeights[_pool];\n        totalFundingPoolWeight = totalFundingPoolWeight - currentPoolWeight;\n\n        fundingPoolWeights[_pool] = 0;\n\n        require(\n            fundingPools.remove(_pool),\n            \"CitadelMinter: funding pool does not exist for removal\"\n        );\n    }\n\n    function _addFundingPool(address _pool) internal {\n        require(\n            fundingPools.add(_pool),\n            \"CitadelMinter: funding pool already exists\"\n        );\n    }\n}\ncontract GlobalAccessControlManaged is PausableUpgradeable {\n    IGac public gac;\n\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @dev this is assumed to be used in the initializer of the inhereiting contract\n     * @param _globalAccessControl global access control which is pinged to allow / deny access to permissioned calls by role\n     */\n    function __GlobalAccessControlManaged_init(address _globalAccessControl)\n        public\n        onlyInitializing\n    {\n        __Pausable_init_unchained();\n        gac = IGac(_globalAccessControl);\n    }\n\n    /// =====================\n    /// ===== Modifiers =====\n    /// =====================\n\n    // @dev only holders of the given role on the GAC can call\n    modifier onlyRole(bytes32 role) {\n        require(gac.hasRole(role, msg.sender), \"GAC: invalid-caller-role\");\n        _;\n    }\n\n    // @dev only holders of any of the given set of roles on the GAC can call\n    modifier onlyRoles(bytes32[] memory roles) {\n        bool validRoleFound = false;\n        for (uint256 i = 0; i < roles.length; i++) {\n            bytes32 role = roles[i];\n            if (gac.hasRole(role, msg.sender)) {\n                validRoleFound = true;\n                break;\n            }\n        }\n        require(validRoleFound, \"GAC: invalid-caller-role\");\n        _;\n    }\n\n    // @dev only holders of the given role on the GAC can call, or a specified address\n    // @dev used to faciliate extra contract-specific permissioned accounts\n    modifier onlyRoleOrAddress(bytes32 role, address account) {\n        require(\n            gac.hasRole(role, msg.sender) || msg.sender == account,\n            \"GAC: invalid-caller-role-or-address\"\n        );\n        _;\n    }\n\n    /// @dev can be pausable by GAC or local flag\n    modifier gacPausable() {\n        require(!gac.paused(), \"global-paused\");\n        require(!paused(), \"local-paused\");\n        _;\n    }\n\n    /// ================================\n    /// ===== Permissioned actions =====\n    /// ================================\n\n    function pause() external {\n        require(gac.hasRole(PAUSER_ROLE, msg.sender));\n        _pause();\n    }\n\n    function unpause() external {\n        require(gac.hasRole(UNPAUSER_ROLE, msg.sender));\n        _unpause();\n    }\n}\ncontract Funding is GlobalAccessControlManaged, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // Roles used from GAC\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE = keccak256(\"TREASURY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_VAULT_ROLE =\n        keccak256(\"TREASURY_VAULT_ROLE\");\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    uint256 public constant MAX_BPS = 10000;\n\n    IERC20 public citadel; /// token to distribute (in vested xCitadel form)\n    IVault public xCitadel; /// wrapped citadel form that is actually distributed\n    IERC20 public asset; /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n\n    uint256 public citadelPriceInAsset; /// asset per citadel price eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public minCitadelPriceInAsset; /// Lower bound on expected citadel price in asset terms. Used as circuit breaker oracle.\n    uint256 public maxCitadelPriceInAsset; /// Upper bound on expected citadel price in asset terms. Used as circuit breaker oracle.\n    bool public citadelPriceFlag; /// Flag citadel price for review by guardian if it exceeds min and max bounds;\n\n    uint256 public assetDecimalsNormalizationValue;\n\n    address public citadelPriceInAssetOracle;\n    address public saleRecipient;\n\n    struct FundingParams {\n        uint256 discount;\n        uint256 minDiscount;\n        uint256 maxDiscount;\n        address discountManager;\n        uint256 assetCumulativeFunded; /// persistent sum of asset amount in over lifetime of contract.\n        uint256 assetCap; /// Max asset token that can be taken in by the contract (defines the cap for citadel sold)\n    }\n\n    FundingParams public funding;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    // TODO: we should conform to some interface here\n    event Deposit(\n        address indexed buyer,\n        uint256 assetIn,\n        uint256 citadelOutValue\n    );\n\n    event CitadelPriceInAssetUpdated(uint256 citadelPrice);\n\n    event CitadelPriceBoundsSet(uint256 minPrice, uint256 maxPrice);\n    event CitadelPriceFlag(uint256 price, uint256 minPrice, uint256 maxPrice);\n\n    event SaleRecipientUpdated(address indexed recipient);\n    event AssetCapUpdated(uint256 assetCap);\n\n    event Sweep(address indexed token, uint256 amount);\n    event ClaimToTreasury(address indexed token, uint256 amount);\n\n    modifier onlyCitadelPriceInAssetOracle() {\n        require(\n            msg.sender == citadelPriceInAssetOracle,\n            \"onlyCitadelPriceInAssetOracle\"\n        );\n        _;\n    }\n\n    event DiscountLimitsSet(uint256 minDiscount, uint256 maxDiscount);\n    event DiscountSet(uint256 discount);\n    event DiscountManagerSet(address discountManager);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _gac Global access control\n     * @param _citadel The token this contract will return in a trade\n     * @param _asset The token this contract will receive in a trade\n     * @param _xCitadel Staked citadel, citadel will be granted to funders in this form\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _assetCap The max asset that the contract can take\n     */\n    function initialize(\n        address _gac,\n        address _citadel,\n        address _asset,\n        address _xCitadel,\n        address _saleRecipient,\n        address _citadelPriceInAssetOracle,\n        uint256 _assetCap\n    ) external initializer {\n        require(\n            _saleRecipient != address(0),\n            \"Funding: 0 sale\"\n        );\n        require(\n            _citadelPriceInAssetOracle != address(0),\n            \"Funding: 0 oracle\"\n        );\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        citadel = IERC20(_citadel);\n        xCitadel = IVault(_xCitadel);\n        asset = IERC20(_asset);\n        saleRecipient = _saleRecipient;\n\n        citadelPriceInAssetOracle = _citadelPriceInAssetOracle;\n\n        funding = FundingParams(0, 0, 0, address(0), 0, _assetCap);\n\n        assetDecimalsNormalizationValue = 10**asset.decimals();\n\n        // No circuit breaker on price by default\n        minCitadelPriceInAsset = 0;\n        maxCitadelPriceInAsset = type(uint256).max;\n\n        // Allow to deposit in vault\n        // Done last for reEntrancy concerns\n        IERC20(_citadel).safeApprove(address(_xCitadel), type(uint256).max);\n    }\n\n    modifier onlyWhenPriceNotFlagged() {\n        require(\n            citadelPriceFlag == false,\n            \"Funding: citadel price from oracle flagged and pending review\"\n        );\n        _;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_assetAmountIn` of `asset` for `citadel`\n     * @param _assetAmountIn Amount of `asset` to give\n     * @param _minCitadelOut ID of DAO to vote for\n     * @return citadelAmount_ Amount of `xCitadel` bought\n     */\n    function deposit(uint256 _assetAmountIn, uint256 _minCitadelOut)\n        external\n        onlyWhenPriceNotFlagged\n        gacPausable\n        nonReentrant\n        returns (uint256 citadelAmount_)\n    {\n        require(_assetAmountIn > 0, \"_assetAmountIn must not be 0\");\n        require(\n            funding.assetCumulativeFunded + _assetAmountIn <= funding.assetCap,\n            \"asset funding cap exceeded\"\n        );\n        funding.assetCumulativeFunded = funding.assetCumulativeFunded + _assetAmountIn;\n        // Take in asset from user\n        citadelAmount_ = getAmountOut(_assetAmountIn);\n        require(citadelAmount_ >= _minCitadelOut, \"minCitadelOut\");\n\n        asset.safeTransferFrom(msg.sender, saleRecipient, _assetAmountIn);\n        \n        // Deposit xCitadel and send to user\n        // TODO: Check gas costs. How does this relate to market buying if you do want to deposit to xCTDL?\n        xCitadel.depositFor(msg.sender, citadelAmount_);\n\n        emit Deposit(\n            msg.sender,\n            _assetAmountIn,\n            citadelAmount_\n        );\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `asset`\n     * @param _assetAmountIn Amount of `asset` to exchange\n     * @return citadelAmount_ Amount of `citadel` received\n     */\n    function getAmountOut(uint256 _assetAmountIn)\n        public\n        view\n        returns (uint256 citadelAmount_)\n    {\n        uint256 citadelAmountWithoutDiscount = _assetAmountIn * citadelPriceInAsset;\n\n        if (funding.discount > 0) {\n            citadelAmount_ =\n                (citadelAmountWithoutDiscount * MAX_BPS) /\n                (MAX_BPS - funding.discount);\n        }\n\n        citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;\n    }\n\n    /**\n     * @notice Get the amount received when exchanging `asset`, in terms of xCitadel at current price per share\n     * @param _assetAmountIn Amount of `asset` to exchange\n     * @return xCitadelAmount_ Amount of `xCitadel` received at current price per share\n     */\n    function getStakedCitadelAmountOut(uint256 _assetAmountIn) public view returns (uint256 xCitadelAmount_) {\n        uint citadelAmount = getAmountOut(_assetAmountIn);\n        xCitadelAmount_ = citadelAmount * 10**citadel.decimals() / xCitadel.getPricePerFullShare();\n    }\n\n    /**\n     * @notice Check how much `asset` can still be taken in, based on cap and cumulative amount funded\n     * @return limitLeft_ Amount of `asset` that can still be exchanged for citadel\n     */\n    function getRemainingFundable() external view returns (uint256 limitLeft_) {\n        uint256 assetCumulativeFunded = funding.assetCumulativeFunded;\n        uint256 assetCap = funding.assetCap;\n        if (assetCumulativeFunded < assetCap) {\n            limitLeft_ = assetCap - assetCumulativeFunded;\n        }\n    }\n\n    /**\n     * @notice Get all funding params\n     * @return funding all funding params\n     */\n    function getFundingParams() external view returns (FundingParams memory) {\n        return funding;\n    }\n\n    /**\n     * @notice Convenience function to get current discount rate\n     * @return discount current discount rate\n     */\n    function getDiscount() external view returns (uint256) {\n        return funding.discount;\n    }\n\n    /// ==============================\n    /// ===== Policy Ops actions =====\n    /// ==============================\n\n    /**\n     * @notice Set discount manually, within the constraints of min and max discount values\n     * @dev managed by policy operations for rapid response to market conditions\n     * @param _discount active discount (in bps)\n     */\n    function setDiscount(uint256 _discount)\n        external\n        gacPausable\n        onlyRoleOrAddress(POLICY_OPERATIONS_ROLE, funding.discountManager)\n    {\n        require(_discount >= funding.minDiscount, \"discount < minDiscount\");\n        require(_discount <= funding.maxDiscount, \"discount > maxDiscount\");\n\n        funding.discount = _discount;\n\n        emit DiscountSet(_discount);\n    }\n\n    function clearCitadelPriceFlag()\n        external\n        gacPausable\n        onlyRole(POLICY_OPERATIONS_ROLE)\n    {\n        citadelPriceFlag = false;\n    }\n\n    /**\n     * @notice Modify the max asset amount that this contract can take. Managed by policy governance.\n     * @dev This is cumulative asset cap, so must take into account the asset amount already funded.\n     * @param _assetCap New max cumulatiive amountIn\n     */\n    function setAssetCap(uint256 _assetCap)\n        external\n        gacPausable\n        onlyRole(POLICY_OPERATIONS_ROLE)\n    {\n        require(\n            _assetCap > funding.assetCumulativeFunded,\n            \"cannot decrease cap below global sum of assets in\"\n        );\n        funding.assetCap = _assetCap;\n        emit AssetCapUpdated(_assetCap);\n    }\n\n    /// ================================\n    /// ===== Treasury Ops actions =====\n    /// ================================\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `asset` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `asset`. For `citadel`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token)\n        external\n        gacPausable\n        nonReentrant\n        onlyRole(TREASURY_OPERATIONS_ROLE)\n    {\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        require(amount > 0, \"nothing to sweep\");\n        require(\n            _token != address(asset),\n            \"cannot sweep funding asset, use claimAssetToTreasury()\"\n        );\n\n        emit Sweep(_token, amount);\n        IERC20(_token).safeTransfer(saleRecipient, amount);\n    }\n\n    /// @notice Claim accumulated asset token to treasury\n    /// @dev We let assets accumulate and batch transfer to treasury (rather than transfer atomically on each deposi)t for user gas savings\n    function claimAssetToTreasury()\n        external\n        gacPausable\n        onlyRole(TREASURY_OPERATIONS_ROLE)\n    {\n        uint256 amount = asset.balanceOf(address(this));\n        require(amount > 0, \"nothing to claim\");\n        asset.safeTransfer(saleRecipient, amount);\n\n        emit ClaimToTreasury(address(asset), amount);\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    /**\n     * @notice Set minimum and maximum discount\n     * @dev managed by contract governance to place constraints around the parameter for policy operations to play within\n     * @param _minDiscount minimum discount (in bps)\n     * @param _maxDiscount maximum discount (in bps)\n     */\n    function setDiscountLimits(uint256 _minDiscount, uint256 _maxDiscount)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(_maxDiscount < MAX_BPS , \"maxDiscount >= MAX_BPS\");\n        funding.minDiscount = _minDiscount;\n        funding.maxDiscount = _maxDiscount;\n\n        emit DiscountLimitsSet(_minDiscount, _maxDiscount);\n    }\n\n    /**\n     * @notice Set a discount manager address\n     * @dev This is intended to be used for an automated discount manager contract to supplement or replace manual calls\n     * @param _discountManager discount manager address\n     */\n    function setDiscountManager(address _discountManager)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        funding.discountManager = _discountManager;\n\n        emit DiscountManagerSet(_discountManager);\n    }\n\n    function setSaleRecipient(address _saleRecipient)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleRecipient != address(0),\n            \"Funding: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    function setCitadelAssetPriceBounds(uint256 _minPrice, uint256 _maxPrice)\n        external\n        gacPausable\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        minCitadelPriceInAsset = _minPrice;\n        maxCitadelPriceInAsset = _maxPrice;\n\n        emit CitadelPriceBoundsSet(_minPrice, _maxPrice);\n    }\n\n    /// ==========================\n    /// ===== Oracle actions =====\n    /// ==========================\n\n    /// @notice Update citadel price in asset terms from oracle source\n    /// @dev Note that the oracle mechanics are abstracted to the oracle address\n    function updateCitadelPriceInAsset()\n        external\n        gacPausable\n        onlyRole(KEEPER_ROLE)\n    {   \n        uint _citadelPriceInAsset;\n        bool _valid;\n\n        (_citadelPriceInAsset, _valid) = IMedianOracle(citadelPriceInAssetOracle).getData();\n\n        require(_citadelPriceInAsset > 0, \"citadel price must not be zero\");\n        require(_valid, \"oracle data must be valid\");\n\n        if (\n            _citadelPriceInAsset < minCitadelPriceInAsset ||\n            _citadelPriceInAsset > maxCitadelPriceInAsset\n        ) {\n            citadelPriceFlag = true;\n            emit CitadelPriceFlag(\n                _citadelPriceInAsset,\n                minCitadelPriceInAsset,\n                maxCitadelPriceInAsset\n            );\n        } else {\n            citadelPriceInAsset = _citadelPriceInAsset;\n            emit CitadelPriceInAssetUpdated(_citadelPriceInAsset);\n        }\n    }\n\n\n    /// @dev OUT OF AUDIT SCOPE: This is a test function that will be removed in final code\n    /// @notice Update citadel price in asset terms from oracle source\n    /// @dev Note that the oracle mechanics are abstracted to the oracle address\n    function updateCitadelPriceInAsset(uint256 _citadelPriceInAsset)\n        external\n        gacPausable\n        onlyCitadelPriceInAssetOracle\n    {\n        require(_citadelPriceInAsset > 0, \"citadel price must not be zero\");\n\n        if (\n            _citadelPriceInAsset < minCitadelPriceInAsset ||\n            _citadelPriceInAsset > maxCitadelPriceInAsset\n        ) {\n            citadelPriceFlag = true;\n            emit CitadelPriceFlag(\n                _citadelPriceInAsset,\n                minCitadelPriceInAsset,\n                maxCitadelPriceInAsset\n            );\n        } else {\n            citadelPriceInAsset = _citadelPriceInAsset;\n            emit CitadelPriceInAssetUpdated(_citadelPriceInAsset);\n        }\n    }\n}\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\ncontract SupplySchedule is GlobalAccessControlManaged, DSTest {\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n\n    uint256 public constant epochLength = 21 days;\n    uint256 public globalStartTimestamp;\n\n    /// epoch index * epoch length = start time\n\n    mapping(uint256 => uint256) public epochRate;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event MintingStartTimeSet(uint256 globalStartTimestamp);\n    event EpochSupplyRateSet(uint256 epoch, uint256 rate);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    function initialize(address _gac) public initializer {\n        __GlobalAccessControlManaged_init(_gac);\n        _setEpochRates();\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    // @dev duplicate of getMintable() with debug print added\n    // @dev this function is out of scope for reviews and audits\n\n    function getEpochAtTimestamp(uint256 _timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        require(\n            globalStartTimestamp > 0,\n            \"SupplySchedule: minting not started\"\n        );\n        return (_timestamp - globalStartTimestamp) / epochLength;\n    }\n\n    function getCurrentEpoch() public view returns (uint256) {\n        return getEpochAtTimestamp(block.timestamp);\n    }\n\n    function getEmissionsForEpoch(uint256 _epoch)\n        public\n        view\n        returns (uint256)\n    {\n        return epochRate[_epoch] * epochLength;\n    }\n\n    function getEmissionsForCurrentEpoch() public view returns (uint256) {\n        uint256 epoch = getCurrentEpoch();\n        return getEmissionsForEpoch(epoch);\n    }\n\n    function getMintable(uint256 lastMintTimestamp)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 cachedGlobalStartTimestamp = globalStartTimestamp;\n        require(\n            cachedGlobalStartTimestamp > 0,\n            \"SupplySchedule: minting not started\"\n        );\n        require(\n            block.timestamp > lastMintTimestamp,\n            \"SupplySchedule: already minted up to current block\"\n        );\n\n        if (lastMintTimestamp < cachedGlobalStartTimestamp) {\n            lastMintTimestamp = cachedGlobalStartTimestamp;\n        }\n\n        uint256 mintable = 0;\n\n        uint256 startingEpoch = (lastMintTimestamp - cachedGlobalStartTimestamp) /\n            epochLength;\n\n        uint256 endingEpoch = (block.timestamp - cachedGlobalStartTimestamp) /\n            epochLength;\n\n        for (uint256 i = startingEpoch; i <= endingEpoch; /** See below ++i */) {\n            uint256 rate = epochRate[i];\n\n            uint256 epochStartTime = cachedGlobalStartTimestamp + i * epochLength;\n            uint256 epochEndTime = cachedGlobalStartTimestamp + (i + 1) * epochLength;\n\n            uint256 time = MathUpgradeable.min(block.timestamp, epochEndTime) -\n                MathUpgradeable.max(lastMintTimestamp, epochStartTime);\n\n            mintable += rate * time;\n\n            unchecked { ++i; }\n        }\n\n        return mintable;\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    function setMintingStart(uint256 _globalStartTimestamp)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n        gacPausable\n    {\n        require(\n            globalStartTimestamp == 0,\n            \"SupplySchedule: minting already started\"\n        );\n        require(\n            _globalStartTimestamp >= block.timestamp,\n            \"SupplySchedule: minting must start at or after current time\"\n        );\n\n        globalStartTimestamp = _globalStartTimestamp;\n        emit MintingStartTimeSet(_globalStartTimestamp);\n    }\n\n    function setEpochRate(uint256 _epoch, uint256 _rate)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n        gacPausable\n    {\n        require(\n            epochRate[_epoch] == 0,\n            \"SupplySchedule: rate already set for given epoch\"\n        );\n        // TODO: Require this epoch is in the future. What happens if no data is set? (It just fails to mint until set)\n        epochRate[_epoch] = _rate;\n        emit EpochSupplyRateSet(_epoch, _rate);\n    }\n\n    /// ========================\n    /// ===== Test actions =====\n    /// ========================\n\n    // @dev Set rates for the initial epochs\n    function _setEpochRates() internal {\n        epochRate[0] = 593962000000000000000000 / epochLength;\n        epochRate[1] = 591445000000000000000000 / epochLength;\n        epochRate[2] = 585021000000000000000000 / epochLength;\n        epochRate[3] = 574138000000000000000000 / epochLength;\n        epochRate[4] = 558275000000000000000000 / epochLength;\n        epochRate[5] = 536986000000000000000000 / epochLength;\n    }\n\n    function getMintableDebug(uint256 lastMintTimestamp) external {\n        require(\n            globalStartTimestamp > 0,\n            \"SupplySchedule: minting not started\"\n        );\n        require(\n            lastMintTimestamp > globalStartTimestamp,\n            \"SupplySchedule: attempting to mint before start block\"\n        );\n        require(\n            block.timestamp > lastMintTimestamp,\n            \"SupplySchedule: already minted up to current block\"\n        );\n\n        uint256 mintable = 0;\n\n        emit log_named_uint(\"mintable\", mintable);\n        emit log_named_uint(\"block.timestamp\", block.timestamp);\n        emit log_named_uint(\"lastMintTimestamp\", lastMintTimestamp);\n        emit log_named_uint(\"globalStartTimestamp\", globalStartTimestamp);\n        emit log_named_uint(\"epochLength\", epochLength);\n\n        uint256 startingEpoch = (lastMintTimestamp - globalStartTimestamp) /\n            epochLength;\n        emit log_named_uint(\"startingEpoch\", startingEpoch);\n\n        uint256 endingEpoch = (block.timestamp - globalStartTimestamp) /\n            epochLength;\n        emit log_named_uint(\"endingEpoch\", endingEpoch);\n\n        for (uint256 i = startingEpoch; i <= endingEpoch; i++) {\n            uint256 rate = epochRate[i];\n\n            uint256 epochStartTime = globalStartTimestamp + i * epochLength;\n            uint256 epochEndTime = globalStartTimestamp + (i + 1) * epochLength;\n\n            emit log_named_uint(\"epoch iteration\", i);\n            emit log_named_uint(\"epochStartTime\", epochStartTime);\n            emit log_named_uint(\"epochEndTime\", epochEndTime);\n\n            uint256 time = MathUpgradeable.min(block.timestamp, epochEndTime) -\n                MathUpgradeable.max(lastMintTimestamp, epochStartTime);\n\n            emit log_named_uint(\"time to mint over\", time);\n\n            mintable += rate * time;\n\n            emit log_named_uint(\"mintable from this iteration\", rate * time);\n            emit log_named_uint(\n                \"total mintable after this iteration\",\n                mintable\n            );\n        }\n\n        // return mintable;\n    }\n}\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n",
    "bin": []
}