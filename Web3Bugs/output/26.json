{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/26",
    "external_functions": [
        [
            "RCFactory",
            "IRCMarket",
            "IRCNftHubL2",
            "IRCTreasury"
        ],
        [
            "RCLeaderboard",
            "IRCMarket"
        ],
        [
            "RCOrderbook",
            "IRCMarket",
            "IRCTreasury"
        ],
        [
            "RCTreasury",
            "IRCFactory",
            "IERC20",
            "IRCOrderbook",
            "IRCBridge"
        ]
    ],
    "new_contract": "contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev a record of a users single bid.\n    /// @dev now declared in the interface, left here for reference\n    // struct Bid {\n    //     address market;\n    //     address next;\n    //     address prev;\n    //     uint64 card;\n    //     uint128 price;\n    //     uint64 timeHeldLimit;\n    // }\n\n    /// @dev maps a user address to an array of their bids\n    mapping(address => Bid[]) public user;\n    /// @dev index of a bid record in the user array, User|Market|Token->Index\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        public\n        override index;\n\n    /// @dev record of market specific variables\n    struct Market {\n        uint64 mode;\n        uint64 cardCount;\n        uint64 minimumPriceIncreasePercent;\n        uint64 minimumRentalDuration;\n    }\n    /// @dev map a market address to a market record\n    mapping(address => Market) public market;\n    /// @dev find the current owner of a card in a given market. Market -> Card -> Owner\n    mapping(address => mapping(uint256 => address)) public override ownerOf;\n    /// @dev store the oldOwner and oldPrice in the event we can't find a new owner\n    mapping(address => mapping(uint256 => address)) public oldOwner;\n    mapping(address => mapping(uint256 => uint256)) public oldPrice;\n    /// @dev an array of closed markets, used to reduce user bid rates\n    address[] public override closedMarkets;\n    /// @dev how far through the array a given user is, saves iterating the whole array every time.\n    mapping(address => uint256) public override userClosedMarketIndex;\n\n    ///// GOVERNANCE VARIABLES /////\n    /// @dev the current treasury\n    IRCTreasury public override treasury;\n    /// @dev max number of searches to place an order in the book\n    /// @dev current estimates place limit around 2000 but 1000 is sufficient\n    uint256 public override maxSearchIterations = 1000;\n    /// @dev max number of records to delete in one transaction\n    uint256 public override maxDeletions = 70;\n    /// @dev number of bids a user should clean when placing a new bid\n    uint256 public override cleaningLoops = 2;\n    /// @dev max number of market records to put into the waste pile in one go\n    uint256 public override marketCloseLimit = 70;\n    /// @dev nonce emitted with orderbook insertions, for frontend sorting\n    uint256 public override nonce;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant WHITELIST = keccak256(\"WHITELIST\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          MODIFIERS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice only allow markets to call certain functions\n    modifier onlyMarkets() {\n        require(\n            treasury.checkPermission(MARKET, msgSender()),\n            \"Not authorised\"\n        );\n        _;\n    }\n\n    modifier onlyUberOwner() {\n        require(\n            treasury.checkPermission(UBER_OWNER, msgSender()),\n            \"Extremely Verboten\"\n        );\n        _;\n    }\n\n    modifier onlyFactory() {\n        require(\n            treasury.checkPermission(FACTORY, msgSender()),\n            \"Extremely Verboten\"\n        );\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev emitted every time an order is added to the orderbook\n    event LogAddToOrderbook(\n        address indexed newOwner,\n        uint256 indexed newPrice,\n        uint256 timeHeldLimit,\n        uint256 nonce,\n        uint256 indexed tokenId,\n        address market\n    );\n    /// @dev emitted when an order is removed from the orderbook\n    event LogRemoveFromOrderbook(\n        address indexed owner,\n        address indexed market,\n        uint256 indexed tokenId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CONSTRUCTOR             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(IRCTreasury _treasury) {\n        treasury = _treasury;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         GOVERNANCE              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function setTreasuryAddress(address _newTreasury)\n        external\n        override\n        onlyUberOwner\n    {\n        require(_newTreasury != address(0));\n        treasury = IRCTreasury(_newTreasury);\n    }\n\n    function setDeletionLimit(uint256 _deletionLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        maxDeletions = _deletionLimit;\n    }\n\n    function setCleaningLimit(uint256 _cleaningLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        cleaningLoops = _cleaningLimit;\n    }\n\n    function setSearchLimit(uint256 _searchLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        maxSearchIterations = _searchLimit;\n    }\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        marketCloseLimit = _marketCloseLimit;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             INSERTIONS              \u2551\n      \u2551 functions that add to the orderbook \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice adds a new market to the orderbook\n    function addMarket(\n        address _market,\n        uint256 _cardCount,\n        uint256 _minIncrease\n    ) internal {\n        market[_market].cardCount = SafeCast.toUint64(_cardCount);\n        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(\n            _minIncrease\n        );\n        market[_market].minimumRentalDuration = SafeCast.toUint64(\n            1 days / IRCMarket(_market).minRentalDayDivisor()\n        );\n        for (uint64 i = 0; i < _cardCount; i++) {\n            // create new record for each card that becomes the head&tail of the linked list\n            Bid memory _newBid;\n            _newBid.market = _market;\n            _newBid.card = i;\n            _newBid.prev = _market;\n            _newBid.next = _market;\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = type(uint64).max;\n            index[_market][_market][i] = user[_market].length;\n            user[_market].push(_newBid);\n        }\n    }\n\n    /// @notice adds or updates a bid in the orderbook\n    /// @param _user the user placing the bid\n    /// @param _card the card to place the bid on\n    /// @param _price the price of the new bid\n    /// @param _timeHeldLimit an optional time limit for the bid\n    /// @param _prevUserAddress to help find where to insert the bid\n    function addBidToOrderbook(\n        address _user,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external override onlyMarkets {\n        address _market = msgSender();\n        if (!bidExists(_market, _market, _card)) {\n            uint256 _cardCount = IRCMarket(_market).numberOfCards();\n            uint256 _minIncrease = IRCMarket(_market)\n                .minimumPriceIncreasePercent();\n            addMarket(_market, _cardCount, _minIncrease);\n        }\n        // each new bid can help clean up some junk\n        cleanWastePile();\n\n        if (user[_user].length == 0) {\n            //users first bid, skip already closed markets\n            userClosedMarketIndex[_user] = closedMarkets.length;\n        }\n\n        if (_prevUserAddress == address(0)) {\n            _prevUserAddress = _market;\n        } else {\n            require(\n                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]\n                    .price >= _price,\n                \"Location too low\"\n            );\n        }\n        require(\n            bidExists(_prevUserAddress, _market, _card),\n            \"Invalid starting location\"\n        );\n        Bid storage _prevUser = user[_prevUserAddress][\n            index[_prevUserAddress][_market][_card]\n        ];\n\n        if (bidExists(_user, _market, _card)) {\n            // old bid exists, update it\n            _updateBidInOrderbook(\n                _user,\n                _market,\n                _card,\n                _price,\n                _timeHeldLimit,\n                _prevUser\n            );\n        } else {\n            // new bid, add it\n            _newBidInOrderbook(\n                _user,\n                _market,\n                _card,\n                _price,\n                _timeHeldLimit,\n                _prevUser\n            );\n        }\n    }\n\n    /// @dev finds the correct location in the orderbook for a given bid\n    /// @dev returns an adjusted (lowered) bid price if necessary.\n    function _searchOrderbook(\n        Bid storage _prevUser,\n        address _market,\n        uint256 _card,\n        uint256 _price\n    ) internal view returns (Bid storage, uint256) {\n        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;\n        Bid storage _nextUser = user[_prevUser.next][\n            index[_prevUser.next][_market][_card]\n        ];\n        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /\n            (100);\n\n        uint256 i = 0;\n        while (\n            // break loop if match price above AND above price below (so if either is false, continue, hence OR )\n            // if match previous then must be greater than next to continue\n            (_price != _prevUser.price || _price <= _nextUser.price) &&\n            // break loop if price x% above below\n            _price < _requiredPrice &&\n            // break loop if hits max iterations\n            i < maxSearchIterations\n        ) {\n            _prevUser = _nextUser;\n            _nextUser = user[_prevUser.next][\n                index[_prevUser.next][_market][_card]\n            ];\n            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);\n            i++;\n        }\n        require(i < maxSearchIterations, \"Position not found\");\n\n        // if previous price is zero it must be the market and this is a new owner\n        // .. then don't reduce their price, we already checked they are 10% higher\n        // .. than the previous owner.\n        if (_prevUser.price != 0 && _prevUser.price < _price) {\n            _price = _prevUser.price;\n        }\n        return (_prevUser, _price);\n    }\n\n    /// @dev add a new bid to the orderbook\n    function _newBidInOrderbook(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        Bid storage _prevUser\n    ) internal {\n        if (ownerOf[_market][_card] != _market) {\n            (_prevUser, _price) = _searchOrderbook(\n                _prevUser,\n                _market,\n                _card,\n                _price\n            );\n        }\n\n        Bid storage _nextUser = user[_prevUser.next][\n            index[_prevUser.next][_market][_card]\n        ];\n\n        // create new record\n        Bid memory _newBid;\n        _newBid.market = _market;\n        _newBid.card = SafeCast.toUint64(_card);\n        _newBid.prev = _nextUser.prev;\n        _newBid.next = _prevUser.next;\n        _newBid.price = SafeCast.toUint128(_price);\n        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);\n\n        // insert in linked list\n        _nextUser.prev = _user; // next record update prev link\n        _prevUser.next = _user; // prev record update next link\n        user[_user].push(_newBid);\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = user[_user].length - (1);\n\n        emit LogAddToOrderbook(\n            _user,\n            _price,\n            _timeHeldLimit,\n            nonce,\n            _card,\n            _market\n        );\n        nonce++;\n\n        // update treasury values and transfer ownership if required\n        treasury.increaseBidRate(_user, _price);\n        if (user[_user][index[_user][_market][_card]].prev == _market) {\n            address _oldOwner = user[_user][index[_user][_market][_card]].next;\n            transferCard(_market, _card, _oldOwner, _user, _price);\n            treasury.updateRentalRate(\n                _oldOwner,\n                _user,\n                user[_oldOwner][index[_oldOwner][_market][_card]].price,\n                _price,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @dev updates a bid that is already in the orderbook\n    function _updateBidInOrderbook(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        Bid storage _prevUser\n    ) internal {\n        // TODO no need to unlink and relink if bid doesn't change position in orderbook\n        // unlink current bid\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n        user[_currUser.next][index[_currUser.next][_market][_card]]\n            .prev = _currUser.prev;\n        user[_currUser.prev][index[_currUser.prev][_market][_card]]\n            .next = _currUser.next;\n        bool _wasOwner = _currUser.prev == _market;\n\n        // find new position\n        (_prevUser, _price) = _searchOrderbook(\n            _prevUser,\n            _market,\n            _card,\n            _price\n        );\n        Bid storage _nextUser = user[_prevUser.next][\n            index[_prevUser.next][_market][_card]\n        ];\n\n        // update price, save old price for rental rate adjustment later\n        (_currUser.price, _price) = (\n            SafeCast.toUint128(_price),\n            uint256(_currUser.price)\n        );\n        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);\n\n        // relink bid\n        _currUser.next = _prevUser.next;\n        _currUser.prev = _nextUser.prev;\n        _nextUser.prev = _user; // next record update prev link\n        _prevUser.next = _user; // prev record update next link\n\n        emit LogAddToOrderbook(\n            _user,\n            _currUser.price,\n            _timeHeldLimit,\n            nonce,\n            _card,\n            _market\n        );\n        nonce++;\n\n        // update treasury values and transfer ownership if required\n        treasury.increaseBidRate(_user, _currUser.price);\n        treasury.decreaseBidRate(_user, _price);\n        if (_wasOwner && _currUser.prev == _market) {\n            // if owner before and after, update the price difference\n            transferCard(_market, _card, _user, _user, _currUser.price);\n            treasury.updateRentalRate(\n                _user,\n                _user,\n                _price,\n                _currUser.price,\n                block.timestamp\n            );\n        } else if (_wasOwner && _currUser.prev != _market) {\n            // if owner before and not after, remove the old price\n            address _newOwner = user[_market][index[_market][_market][_card]]\n                .next;\n            uint256 _newPrice = user[_newOwner][\n                index[_newOwner][_market][_card]\n            ].price;\n            treasury.updateRentalRate(\n                _user,\n                _newOwner,\n                _price,\n                _newPrice,\n                block.timestamp\n            );\n            transferCard(_market, _card, _user, _newOwner, _newPrice);\n        } else if (!_wasOwner && _currUser.prev == _market) {\n            // if not owner before but is owner after, add new price\n            address _oldOwner = _currUser.next;\n            uint256 _oldPrice = user[_oldOwner][\n                index[_oldOwner][_market][_card]\n            ].price;\n            treasury.updateRentalRate(\n                _oldOwner,\n                _user,\n                _oldPrice,\n                _currUser.price,\n                block.timestamp\n            );\n            transferCard(_market, _card, _oldOwner, _user, _currUser.price);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551                DELETIONS                 \u2551      \n      \u2551 functions that remove from the orderbook \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice removes a single bid from the orderbook - onlyMarkets\n    function removeBidFromOrderbook(address _user, uint256 _card)\n        external\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        assert(_user != ownerOf[_market][_card]);\n        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);\n    }\n\n    /// @dev removes a single bid from the orderbook, doesn't update ownership\n    function _removeBidFromOrderbookIgnoreOwner(\n        address _user,\n        address _market,\n        uint256 _card\n    ) internal returns (uint256 _newPrice) {\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n\n        // extract from linked list\n        address _tempNext = _currUser.next;\n        address _tempPrev = _currUser.prev;\n        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;\n        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;\n\n        // return next users price to check they're eligible later\n        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;\n\n        // update rate\n        treasury.decreaseBidRate(_user, _currUser.price);\n\n        // overwrite array element\n        uint256 _index = index[_user][_market][_card];\n        uint256 _lastRecord = user[_user].length - 1;\n        // no point overwriting itself\n        if (_index != _lastRecord) {\n            user[_user][_index] = user[_user][_lastRecord];\n        }\n        user[_user].pop();\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = 0;\n        if (user[_user].length != 0 && _index != _lastRecord) {\n            index[_user][user[_user][_index].market][\n                user[_user][_index].card\n            ] = _index;\n        }\n\n        assert(!bidExists(_user, _market, _card));\n        emit LogRemoveFromOrderbook(_user, _market, _card);\n    }\n\n    /// @notice find the next valid owner of a given card - onlyMarkets\n    /// @param _card the card to remove\n    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes\n    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)\n        external\n        override\n        onlyMarkets\n    {\n        address _newOwner = address(0);\n        address _market = msgSender();\n        // the market is the head of the list, the next bid is therefore the owner\n        Bid storage _head = user[_market][index[_market][_market][_card]];\n        address _oldOwner = address(0);\n        uint256 _oldPrice = 0;\n        if (oldOwner[_market][_card] != address(0)) {\n            _oldOwner = oldOwner[_market][_card];\n            _oldPrice = oldPrice[_market][_card];\n            oldOwner[_market][_card] = address(0);\n            oldPrice[_market][_card] = 0;\n        } else {\n            _oldOwner = ownerOf[_market][_card];\n            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;\n        }\n        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +\n            market[_market].minimumRentalDuration;\n        uint256 _newPrice;\n        uint256 _loopCounter = 0;\n\n        // delete current owner\n        do {\n            _newPrice = _removeBidFromOrderbookIgnoreOwner(\n                _head.next,\n                _market,\n                _card\n            );\n            _loopCounter++;\n            // delete next bid if foreclosed\n        } while (\n            treasury.foreclosureTimeUser(\n                _head.next,\n                _newPrice,\n                _timeOwnershipChanged\n            ) <\n                minimumTimeToOwnTo &&\n                _loopCounter < maxDeletions\n        );\n\n        if (_loopCounter != maxDeletions) {\n            // the old owner is dead, long live the new owner\n            _newOwner = user[_market][index[_market][_market][_card]].next;\n            treasury.updateRentalRate(\n                _oldOwner,\n                _newOwner,\n                _oldPrice,\n                _newPrice,\n                _timeOwnershipChanged\n            );\n            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);\n        } else {\n            // we hit the limit, save the old owner, we'll try again next time\n            oldOwner[_market][_card] = _oldOwner;\n            oldPrice[_market][_card] = _oldPrice;\n        }\n    }\n\n    /// @notice when a user has foreclosed we can freely delete their bids, however leave owned cards\n    /// @notice .. as the markets will need to finish the accounting for them first.\n    /// @param _user the user whose bids to start deleting\n    function removeUserFromOrderbook(address _user) external override {\n        require(treasury.isForeclosed(_user), \"User must be foreclosed\");\n        uint256 i = user[_user].length;\n        if (i != 0) {\n            uint256 _limit = 0;\n            if (i > maxDeletions) {\n                _limit = i - maxDeletions;\n            }\n\n            do {\n                i--;\n\n                // If the prev record isn't the market, this is only a bid (not owned) so we can delete\n                if (user[_user][i].prev != user[_user][i].market) {\n                    address _market = user[_user][i].market;\n                    uint256 _card = user[_user][i].card;\n                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);\n                }\n            } while (user[_user].length > _limit && i > 0);\n        }\n        treasury.assessForeclosure(_user);\n    }\n\n    /// @notice reduces the rentalRates of the card owners when a market closes\n    /// @dev too many bidders to reduce all bid rates also\n    function closeMarket() external override onlyMarkets returns (bool) {\n        address _market = msgSender();\n        // check if the market was ever added to the orderbook\n        if (bidExists(_market, _market, 0)) {\n            closedMarkets.push(_market);\n            uint256 i = user[_market].length; // start on the last record so we can easily pop()\n            uint256 _limit = 0;\n            if (marketCloseLimit < user[_market].length) {\n                _limit = user[_market].length - marketCloseLimit;\n            } else {\n                _limit = 0;\n            }\n            do {\n                i--;\n                address _lastOwner = user[_market][index[_market][_market][i]]\n                    .next;\n                if (_lastOwner != _market) {\n                    uint256 _price = user[_lastOwner][\n                        index[_lastOwner][_market][i]\n                    ].price;\n\n                    // store last bid for later\n                    address _lastBid = user[_market][index[_market][_market][i]]\n                        .prev;\n\n                    // detach market from rest of list\n                    user[_market][index[_market][_market][i]].prev = _market;\n                    user[_market][index[_market][_market][i]].next = _market;\n                    user[_lastOwner][index[_lastOwner][_market][i]]\n                        .prev = address(this);\n                    user[_lastBid][index[_lastBid][_market][i]].next = address(\n                        this\n                    );\n\n                    index[address(this)][_market][i] = user[address(this)]\n                        .length;\n\n                    // insert bids in the waste pile\n                    Bid memory _newBid;\n                    _newBid.market = _market;\n                    _newBid.card = SafeCast.toUint64(i);\n                    _newBid.prev = _lastBid;\n                    _newBid.next = _lastOwner;\n                    _newBid.price = 0;\n                    _newBid.timeHeldLimit = 0;\n                    user[address(this)].push(_newBid);\n\n                    // reduce owners rental rate\n                    treasury.updateRentalRate(\n                        _lastOwner,\n                        _market,\n                        _price,\n                        0,\n                        block.timestamp\n                    );\n                }\n                // remove the market record\n                user[_market].pop();\n            } while (i > _limit);\n        }\n        if (user[_market].length == 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Remove bids in closed markets for a given user\n    /// @notice this can reduce the users bidRate and chance to foreclose\n    /// @param _user the address of the users bids to remove\n    function removeOldBids(address _user) external override {\n        if (user[_user].length != 0) {\n            address _market = address(0);\n            uint256 _cardCount = 0;\n            uint256 _loopCounter = 0;\n            uint256 _subLoopCounter = 0;\n            while (\n                userClosedMarketIndex[_user] < closedMarkets.length &&\n                _loopCounter + _cardCount < maxDeletions\n            ) {\n                _market = closedMarkets[userClosedMarketIndex[_user]];\n                // Just do the whole market at once\n                _cardCount = market[_market].cardCount;\n                uint256 i = _cardCount;\n                do {\n                    i--;\n                    if (bidExists(_user, _market, i)) {\n                        uint256 _index = index[_user][_market][i];\n                        // reduce bidRate\n                        uint256 _price = user[_user][_index].price;\n\n                        // preserve linked list\n                        address _tempPrev = user[_user][_index].prev;\n                        address _tempNext = user[_user][_index].next;\n\n                        user[_tempNext][index[_tempNext][_market][i]]\n                            .prev = _tempPrev;\n                        user[_tempPrev][index[_tempPrev][_market][i]]\n                            .next = _tempNext;\n\n                        uint256 _lastRecord = user[_user].length - 1;\n                        // no point overwriting itself\n                        if (_index != _lastRecord) {\n                            // overwrite array element\n                            user[_user][_index] = user[_user][_lastRecord];\n                        }\n                        user[_user].pop();\n\n                        // update the index to help find the record later\n                        index[_user][_market][i] = 0;\n                        if (user[_user].length != 0 && _index != _lastRecord) {\n                            index[_user][user[_user][_index].market][\n                                user[_user][_index].card\n                            ] = _index;\n                        }\n\n                        treasury.decreaseBidRate(_user, _price);\n                        // count deletions\n                        _loopCounter++;\n                    } else {\n                        // iterations cost gas also\n                        // after enough increment the loopCounter\n                        _subLoopCounter++;\n                        if (_subLoopCounter > 100) {\n                            _subLoopCounter = 0;\n                            _loopCounter++;\n                        }\n                    }\n                } while (i > 0);\n                userClosedMarketIndex[_user]++;\n            }\n        }\n    }\n\n    /// @dev remove bids in closed markets, not user specific\n    function cleanWastePile() public override {\n        uint256 i = 0;\n        while (i < cleaningLoops && user[address(this)].length > 0) {\n            uint256 _pileHeight = user[address(this)].length - 1;\n            address _market = user[address(this)][_pileHeight].market;\n            uint256 _card = user[address(this)][_pileHeight].card;\n            address _user = user[address(this)][_pileHeight].next;\n\n            if (user[address(this)][_pileHeight].next == address(this)) {\n                index[address(this)][_market][_card] = 0;\n                user[address(this)].pop();\n            } else {\n                uint256 _index = index[_user][_market][_card];\n                address _tempNext = user[_user][_index].next;\n\n                treasury.decreaseBidRate(_user, user[_user][_index].price);\n\n                // extract from linked list\n                user[address(this)][_pileHeight].next = _tempNext;\n                user[_tempNext][index[_tempNext][_market][_card]]\n                    .prev = address(this);\n\n                // overwrite array element\n                uint256 _lastRecord = user[_user].length - 1;\n                // no point overwriting itself\n                if (_index != _lastRecord) {\n                    user[_user][_index] = user[_user][_lastRecord];\n                }\n                user[_user].pop();\n\n                // update the index to help find the record later\n                index[_user][_market][_card] = 0;\n                if (user[_user].length != 0 && _index != _lastRecord) {\n                    index[_user][user[_user][_index].market][\n                        user[_user][_index].card\n                    ] = _index;\n                }\n            }\n            i++;\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        HELPER FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check if a bid exists\n    /// @param _user the address of the user\n    /// @param _market the address of the market\n    /// @param _card the card index\n    /// @return if the bid exists or not\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) public view override returns (bool) {\n        if (user[_user].length != 0) {\n            //some bids exist\n            if (index[_user][_market][_card] != 0) {\n                // this bid exists\n                return true;\n            } else {\n                // check bid isn't index 0\n                if (\n                    user[_user][0].market == _market &&\n                    user[_user][0].card == _card\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function getBidValue(address _user, uint256 _card)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address _market = msgSender();\n        if (bidExists(_user, _market, _card)) {\n            return user[_user][index[_user][_market][_card]].price;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @dev just to pass old tests, not needed otherwise\n    /// @dev but also useful to have so probably will stay\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view override returns (Bid memory) {\n        if (bidExists(_user, _market, _card)) {\n            Bid memory _bid = user[_user][index[_user][_market][_card]];\n            return _bid;\n        } else {\n            Bid memory _newBid;\n            _newBid.market = address(0);\n            _newBid.card = SafeCast.toUint64(_card);\n            _newBid.prev = address(0);\n            _newBid.next = address(0);\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = 0;\n            return _newBid;\n        }\n    }\n\n    function getTimeHeldlimit(address _user, uint256 _card)\n        external\n        view\n        override\n        onlyMarkets\n        returns (uint256)\n    {\n        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;\n    }\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeldLimit\n    ) external override onlyMarkets {\n        address _market = msgSender();\n        require(bidExists(_user, _market, _card), \"Bid doesn't exist\");\n        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast\n            .toUint64(_timeHeldLimit);\n    }\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _card,\n        uint256 _timeToReduce\n    ) external override onlyMarkets {\n        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast\n            .toUint64(_timeToReduce);\n    }\n\n    function transferCard(\n        address _market,\n        uint256 _card,\n        address _oldOwner,\n        address _newOwner,\n        uint256 _price\n    ) internal {\n        ownerOf[_market][_card] = _newOwner;\n        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]\n            .timeHeldLimit;\n        IRCMarket _rcmarket = IRCMarket(_market);\n        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\ncontract RCFactory is NativeMetaTransaction, IRCFactory {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /////// CONTRACT VARIABLES ///////\n    IRCTreasury public override treasury;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRCLeaderboard public override leaderboard;\n    IRealitio public override realitio;\n    /// @dev reference contract\n    address public override referenceContractAddress;\n    /// @dev increments each time a new reference contract is added\n    uint256 public override referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(IRCMarket.Mode => address[]) public marketAddresses;\n\n    ////// BACKUP MODE //////\n    /// @dev should the Graph fail the UI needs a way to poll the contracts for market data\n    /// @dev the IPFS hash for each market\n    mapping(address => string) public override ipfsHash;\n    /// @dev the slug each market is hosted at\n    mapping(string => address) public override slugToAddress;\n    mapping(address => string) public override addressToSlug;\n    /// @dev the number of results to return in the backup view function\n    uint256 public override marketInfoResults;\n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum tokens that must be sent when creating market which forms initial pot\n    uint256 public override sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev The number of users that are allowed to mint an NFT\n    uint256 public override nftsToAward;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public override advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public override maximumDuration;\n    /// @dev market closing time must be at least this many seconds after opening\n    uint32 public override minimumDuration;\n    /// @dev if false, anyone can create markets\n    bool public override marketCreationGovernorsOnly = true;\n    /// @dev if false, anyone can be an affiliate\n    bool public override approvedAffiliatesOnly = true;\n    /// @dev if false, anyone can be an artist\n    bool public override approvedArtistsOnly = true;\n    /// @dev the maximum number of rent collections to perform in a single transaction\n    uint256 public override maxRentIterations;\n    /// @dev the maximum number of rent collections to have performed before locking the market\n    uint256 public override maxRentIterationsToLockMarket;\n    /// @dev the address of the arbitrator\n    address public override arbitrator;\n    /// @dev the time allowed to dispute the oracle answer\n    uint32 public override timeout;\n    /// @dev if true markets default to the paused state\n    bool public override marketPausedDefaultState;\n    /// @dev a limit to the number of NFTs to mint per market\n    uint256 public override cardLimit;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public override isMarketApproved;\n\n    ///// OTHER /////\n    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)\n    /// @dev store the tokenURIs for when we need to mint them\n    /// @dev we may want the original and the copies to have slightly different metadata\n    /// @dev so we append the metadata for the copies to the end of this array\n    mapping(address => mapping(uint256 => string)) tokenURIs;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogMarketCreated1(\n        address contractAddress,\n        address treasuryAddress,\n        address nftHubAddress,\n        uint256 referenceContractVersion\n    );\n    event LogMarketCreated2(\n        address contractAddress,\n        IRCMarket.Mode mode,\n        string[] tokenURIs,\n        string ipfsHash,\n        uint32[] timestamps,\n        uint256 totalNftMintCount\n    );\n    event LogMarketApproved(address market, bool approved);\n    event LogMarketTimeRestrictions(\n        uint256 _newAdvancedWarning,\n        uint256 _newMinimumDuration,\n        uint256 _newMaximumDuration\n    );\n    event LogMintNFTCopy(\n        uint256 _originalTokenId,\n        address _newOwner,\n        uint256 _newTokenId\n    );\n    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(\n        IRCTreasury _treasury,\n        address _realitioAddress,\n        address _arbitratorAddress\n    ) {\n        require(address(_treasury) != address(0), \"Must set Address\");\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\", \"1\");\n\n        // store contract instances\n        treasury = _treasury;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate\n        setMinimumPriceIncreasePercent(10); // 10%\n        setNumberOfNFTsToAward(3);\n        setCardLimit(100); // safe limit tested and set at 100, can be adjusted later if gas limit changes\n        setMaxRentIterations(50, 25); // safe limit tested and set at 50 & 25, can be adjusted later if gas limit changes\n        // oracle\n        setArbitrator(_arbitratorAddress);\n        setRealitioAddress(_realitioAddress);\n        setTimeout(86400); // 24 hours\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          VIEW FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Fetch the address of the most recently created market\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return the address of the most recent market in the given mode\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        override\n        returns (address)\n    {\n        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n    }\n\n    /// @notice Fetch all the market addresses for a given mode\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return an array of all markets in a given mode\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return marketAddresses[_mode];\n    }\n\n    /// @notice Returns the currently set pot distribution\n    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates\n    function getPotDistribution()\n        external\n        view\n        override\n        returns (uint256[5] memory)\n    {\n        return potDistribution;\n    }\n\n    /// @notice fetch the current oracle, arbitrator and timeout settings\n    /// @dev called by the market upon initialise\n    /// @dev not passed to initialise to avoid stack too deep error\n    /// @return Oracle Address\n    /// @return Arbitrator Address\n    /// @return Question timeout in seconds\n    function getOracleSettings()\n        external\n        view\n        override\n        returns (\n            IRealitio,\n            address,\n            uint32\n        )\n    {\n        return (realitio, arbitrator, timeout);\n    }\n\n    /// @notice Returns market addresses and ipfs hashes\n    /// @dev used for the UI backup mode\n    /// @param _mode return markets only in the given mode\n    /// @param _state return markets only in the given state\n    /// @param _skipResults the number of results to skip\n    function getMarketInfo(\n        IRCMarket.Mode _mode,\n        uint256 _state,\n        uint256 _skipResults\n    )\n        external\n        view\n        returns (\n            address[] memory,\n            string[] memory,\n            string[] memory,\n            uint256[] memory\n        )\n    {\n        uint256 _marketIndex = marketAddresses[_mode].length;\n        uint256 _resultNumber = 0;\n        address[] memory _marketAddresses = new address[](marketInfoResults);\n        string[] memory _ipfsHashes = new string[](marketInfoResults);\n        uint256[] memory _potSizes = new uint256[](marketInfoResults);\n        string[] memory _slugs = new string[](marketInfoResults);\n        while (_resultNumber < marketInfoResults && _marketIndex > 1) {\n            _marketIndex--;\n            address _market = marketAddresses[_mode][_marketIndex];\n            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {\n                if (_resultNumber < _skipResults) {\n                    _resultNumber++;\n                } else {\n                    _marketAddresses[_resultNumber] = _market;\n                    _ipfsHashes[_resultNumber] = ipfsHash[_market];\n                    _slugs[_resultNumber] = addressToSlug[_market];\n                    _potSizes[_resultNumber] = IRCMarket(_market)\n                        .totalRentCollected();\n                    _resultNumber++;\n                }\n            }\n        }\n        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    modifier onlyUberOwner() {\n        require(\n            treasury.checkPermission(UBER_OWNER, msgSender()),\n            \"Not approved\"\n        );\n        _;\n    }\n    modifier onlyOwner() {\n        require(treasury.checkPermission(OWNER, msgSender()), \"Not approved\");\n        _;\n    }\n    modifier onlyGovernors() {\n        require(\n            treasury.checkPermission(GOVERNOR, msgSender()),\n            \"Not approved\"\n        );\n        _;\n    }\n    modifier onlyMarkets() {\n        require(treasury.checkPermission(MARKET, msgSender()), \"Not approved\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase & pot distribution emitted by Market.\n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice update stakeholder payouts\n    /// @dev in MegaBip (so 1000 = 100%)\n    /// @param _artistCut The artist that designed the card\n    /// @param _winnerCut Extra cut for the longest owner\n    /// @param _creatorCut The creator of the market\n    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts\n    /// @param _cardAffiliateCut An affiliate cur for specific cards\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) public override onlyOwner {\n        require(\n            _artistCut +\n                _winnerCut +\n                _creatorCut +\n                _affiliateCut +\n                _cardAffiliateCut <=\n                PER_MILLE,\n            \"Cuts too big\"\n        );\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)\n        public\n        override\n        onlyOwner\n    {\n        minimumPriceIncreasePercent = _percentIncrease;\n    }\n\n    /// @notice how many NFTs will be awarded to the leaderboard\n    /// @param _nftsToAward the number of NFTs to award\n    function setNumberOfNFTsToAward(uint256 _nftsToAward)\n        public\n        override\n        onlyOwner\n    {\n        nftsToAward = _nftsToAward;\n    }\n\n    /// @notice A limit to the number of NFTs to mint per market\n    /// @dev to avoid gas limits\n    /// @param _cardLimit the limit to set\n    function setCardLimit(uint256 _cardLimit) public override onlyOwner {\n        cardLimit = _cardLimit;\n    }\n\n    /// @notice A limit to the number of rent collections per transaction\n    /// @dev to avoid gas limits\n    /// @param _rentLimit the limit to set\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        public\n        override\n        onlyOwner\n    {\n        maxRentIterations = _rentLimit;\n        maxRentIterationsToLockMarket = _rentLimitLocking;\n    }\n\n    /// @notice set the address of the reality.eth contracts\n    /// @param _newAddress the address to set\n    function setRealitioAddress(address _newAddress) public override onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @notice address of the arbitrator, in case of continued disputes on reality.eth\n    /// @param _newAddress the address to set\n    function setArbitrator(address _newAddress) public override onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        arbitrator = _newAddress;\n    }\n\n    /// @notice set how long reality.eth waits for disputes before finalising\n    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs\n    function setTimeout(uint32 _newTimeout) public override onlyOwner {\n        // event is emitted from the Oracle when the question is asked\n        timeout = _newTimeout;\n    }\n\n    function setMarketPausedDefaultState(bool _state)\n        external\n        override\n        onlyOwner\n    {\n        marketPausedDefaultState = _state;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice whether or not only governors can create the market\n    function changeMarketCreationGovernorsOnly() external override onlyOwner {\n        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;\n    }\n\n    /// @notice whether or not anyone can be an artist\n    function changeApprovedArtistsOnly() external override onlyOwner {\n        approvedArtistsOnly = !approvedArtistsOnly;\n    }\n\n    /// @notice whether or not anyone can be an affiliate\n    function changeApprovedAffilliatesOnly() external override onlyOwner {\n        approvedAffiliatesOnly = !approvedAffiliatesOnly;\n    }\n\n    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot\n    /// @param _amount the sponsorship required in wei\n    function setSponsorshipRequired(uint256 _amount)\n        external\n        override\n        onlyOwner\n    {\n        sponsorshipRequired = _amount;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    /// @param _newAdvancedWarning the warning time to set in seconds\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external override onlyOwner {\n        advancedWarning = _newAdvancedWarning;\n        minimumDuration = _newMinimumDuration;\n        maximumDuration = _newMaximumDuration;\n        emit LogMarketTimeRestrictions(\n            _newAdvancedWarning,\n            _newMinimumDuration,\n            _newMaximumDuration\n        );\n    }\n\n    /// @notice Allow the owner to update a token URI.\n    /// @param _market the market address the token belongs to\n    /// @param _cardId the index 0 card id of the token to change\n    /// @param _newTokenURI the new URI to set\n    /// @param _newCopyTokenURI the new URI to set for the copy\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external override onlyOwner {\n        IRCMarket.Mode _mode = IRCMarket(_market).mode();\n        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();\n        tokenURIs[_market][_cardId] = _newTokenURI;\n        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;\n        string[] memory _tokenURIs = new string[](_numberOfCards);\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            _tokenURIs[i] = tokenURIs[_market][i];\n        }\n        uint32[] memory _timestamps = new uint32[](3);\n        _timestamps[0] = IRCMarket(_market).marketOpeningTime();\n        _timestamps[1] = IRCMarket(_market).marketLockingTime();\n        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();\n\n        // reuse this event so the frontend can pickup the change\n        emit LogMarketCreated2(\n            _market,\n            IRCMarket.Mode(_mode),\n            _tokenURIs,\n            ipfsHash[_market],\n            _timestamps,\n            nfthub.totalSupply()\n        );\n    }\n\n    /// @notice change how many results are returned from getMarketInfo\n    /// @dev would be better to pass this as a parameter in getMarketInfo\n    /// @dev .. however we are limited because of stack too deep errors\n    function setMarketInfoResults(uint256 _results)\n        external\n        override\n        onlyOwner\n    {\n        // no event needed, only used for the backup view mode\n        marketInfoResults = _results;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - GOVERNORS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    /// @param _market the market address to change approval for\n    function changeMarketApproval(address _market)\n        external\n        override\n        onlyGovernors\n    {\n        require(_market != address(0), \"Must set Address\");\n        // check it's an RC contract\n        require(treasury.checkPermission(MARKET, _market), \"Not Market\");\n        isMarketApproved[_market] = !isMarketApproved[_market];\n        // governors shouldn't have the ability to pause a market, only un-pause.\n        // .. if a governor accidentally approves a market they should seek\n        // .. assistance from the owner to decide if it should be paused.\n        treasury.unPauseMarket(_market);\n        // the market will however be hidden from the UI in the meantime\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551   GOVERNANCE - Role management  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev the following functions could all be performed directly on the treasury\n    /// @dev .. they are here as an interim solution to give governors an easy way\n    /// @dev .. to change all their parameters via the block explorer.\n\n    /// @notice Grant the artist role to an address\n    /// @param _newArtist the address to grant the role of artist\n    function addArtist(address _newArtist) external override onlyGovernors {\n        treasury.grantRole(ARTIST, _newArtist);\n    }\n\n    /// @notice Remove the artist role from an address\n    /// @param _oldArtist the address to revoke the role of artist\n    function removeArtist(address _oldArtist) external override onlyGovernors {\n        treasury.revokeRole(ARTIST, _oldArtist);\n    }\n\n    /// @notice Grant the affiliate role to an address\n    /// @param _newAffiliate the address to grant the role of affiliate\n    function addAffiliate(address _newAffiliate)\n        external\n        override\n        onlyGovernors\n    {\n        treasury.grantRole(AFFILIATE, _newAffiliate);\n    }\n\n    /// @notice Remove the affiliate role from an address\n    /// @param _oldAffiliate the address to revoke the role of affiliate\n    function removeAffiliate(address _oldAffiliate)\n        external\n        override\n        onlyGovernors\n    {\n        treasury.revokeRole(AFFILIATE, _oldAffiliate);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades, this is separated so owner can be\n    /// @dev ..  set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    /// @notice change the reference contract for the contract logic\n    /// @param _newAddress the address of the new reference contract to set\n    function setReferenceContractAddress(address _newAddress)\n        external\n        override\n        onlyUberOwner\n    {\n        require(_newAddress != address(0));\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        require(newContractVariable.isMarket(), \"Not Market\");\n        // set\n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion += 1;\n    }\n\n    /// @notice where the NFTs live\n    /// @param _newAddress the address to set\n    function setNftHubAddress(IRCNftHubL2 _newAddress)\n        external\n        override\n        onlyUberOwner\n    {\n        require(address(_newAddress) != address(0), \"Must set Address\");\n        nfthub = _newAddress;\n    }\n\n    /// @notice set the address of the orderbook contract\n    /// @param _newOrderbook the address to set\n    /// @dev set by the treasury to ensure all contracts use the same orderbook\n    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {\n        require(\n            treasury.checkPermission(TREASURY, msgSender()),\n            \"Not approved\"\n        );\n        orderbook = _newOrderbook;\n    }\n\n    /// @notice set the address of the leaderboard contract\n    /// @param _newLeaderboard the address to set\n    /// @dev set by the treasury to ensure all contracts use the same leaderboard\n    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)\n        external\n        override\n    {\n        require(\n            treasury.checkPermission(TREASURY, msgSender()),\n            \"Not approved\"\n        );\n        leaderboard = _newLeaderboard;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         MARKET CREATION         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Creates a new market with the given parameters\n    /// @param _mode 0 = normal, 1 = winner takes all\n    /// @param _ipfsHash the IPFS location of the market metadata\n    /// @param _slug the URL subdomain in the UI\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata, originals followed by copies\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliates cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliates cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    /// @param _sponsorship amount of sponsorship to create the market with\n    /// @return The address of the new market\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string memory _realitioQuestion,\n        uint256 _sponsorship\n    ) external override returns (address) {\n        address _creator = msgSender();\n\n        // check nfthub has been set\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n\n        // check sponsorship\n        require(\n            _sponsorship >= sponsorshipRequired,\n            \"Insufficient sponsorship\"\n        );\n        treasury.checkSponsorship(_creator, _sponsorship);\n\n        // check the number of NFTs to mint is within limits\n        /// @dev we want different tokenURIs for originals and copies\n        /// @dev ..the copies are appended to the end of the array\n        /// @dev ..so half the array length if the number of tokens.\n        require(\n            (_tokenURIs.length / 2) <= cardLimit,\n            \"Too many tokens to mint\"\n        );\n\n        // check stakeholder addresses\n        // artist\n        if (approvedArtistsOnly) {\n            require(\n                _artistAddress == address(0) ||\n                    treasury.checkPermission(ARTIST, _artistAddress),\n                \"Artist not approved\"\n            );\n        }\n\n        // affiliate\n        require(\n            _cardAffiliateAddresses.length == 0 ||\n                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),\n            \"Card Affiliate Length Error\"\n        );\n        if (approvedAffiliatesOnly) {\n            require(\n                _affiliateAddress == address(0) ||\n                    treasury.checkPermission(AFFILIATE, _affiliateAddress),\n                \"Affiliate not approved\"\n            );\n            // card affiliates\n            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {\n                require(\n                    _cardAffiliateAddresses[i] == address(0) ||\n                        treasury.checkPermission(\n                            CARD_AFFILIATE,\n                            _cardAffiliateAddresses[i]\n                        ),\n                    \"Card affiliate not approved\"\n                );\n            }\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(\n                treasury.checkPermission(GOVERNOR, _creator),\n                \"Not approved\"\n            );\n        }\n\n        _checkTimestamps(_timestamps);\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = Clones.clone(referenceContractAddress);\n        emit LogMarketCreated1(\n            _newAddress,\n            address(treasury),\n            address(nfthub),\n            referenceContractVersion\n        );\n        emit LogMarketCreated2(\n            _newAddress,\n            IRCMarket.Mode(_mode),\n            _tokenURIs,\n            _ipfsHash,\n            _timestamps,\n            nfthub.totalSupply()\n        );\n\n        // tell Treasury and NFT hub about new market\n        // before initialize as during initialize the market may call the treasury\n        treasury.addMarket(_newAddress, marketPausedDefaultState);\n        nfthub.addMarket(_newAddress);\n\n        // update internals\n        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);\n        ipfsHash[_newAddress] = _ipfsHash;\n        slugToAddress[_slug] = _newAddress;\n        addressToSlug[_newAddress] = _slug;\n\n        // initialize the market\n        IRCMarket(_newAddress).initialize(\n            IRCMarket.Mode(_mode),\n            _timestamps,\n            (_tokenURIs.length / 2),\n            _artistAddress,\n            _affiliateAddress,\n            _cardAffiliateAddresses,\n            _creator,\n            _realitioQuestion,\n            nftsToAward\n        );\n\n        // store token URIs\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            tokenURIs[_newAddress][i] = _tokenURIs[i];\n        }\n\n        // pay sponsorship, if applicable\n        if (_sponsorship > 0) {\n            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);\n        }\n\n        return _newAddress;\n    }\n\n    function _checkTimestamps(uint32[] memory _timestamps) internal view {\n        // check timestamps\n        require(_timestamps.length == 3, \"Incorrect number of array elements\");\n        // check market opening time\n        if (advancedWarning != 0) {\n            // different statements to give clearer revert messages\n            require(\n                _timestamps[0] >= block.timestamp,\n                \"Market opening time not set\"\n            );\n            require(\n                _timestamps[0] - advancedWarning > block.timestamp,\n                \"Market opens too soon\"\n            );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(\n                _timestamps[1] < block.timestamp + maximumDuration,\n                \"Market locks too late\"\n            );\n        }\n        require(\n            _timestamps[0] + minimumDuration < _timestamps[1] &&\n                block.timestamp + minimumDuration < _timestamps[1],\n            \"Market lock must be after opening\"\n        );\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(\n            _timestamps[1] + (1 weeks) > _timestamps[2] &&\n                _timestamps[1] <= _timestamps[2],\n            \"Oracle resolution time error\"\n        );\n    }\n\n    /// @notice Called by the markets to mint the original NFTs\n    /// @param _card the card id to be minted\n    function mintMarketNFT(uint256 _card) external override onlyMarkets {\n        uint256 nftHubMintCount = nfthub.totalSupply();\n        address _market = msgSender();\n        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);\n        emit LogMintNFT(_card, _market, nftHubMintCount);\n    }\n\n    /// @notice allows the market to mint a copy of the NFT for users on the leaderboard\n    /// @param _user the user to award the NFT to\n    /// @param _cardId the tokenId to copy\n    function mintCopyOfNFT(address _user, uint256 _cardId)\n        external\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        uint256 _newTokenId = nfthub.totalSupply();\n        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();\n        nfthub.mint(\n            _user,\n            _newTokenId,\n            tokenURIs[_market][(_cardId + _numberOfCards)]\n        );\n        emit LogMintNFTCopy(_cardId, _user, _newTokenId);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\ncontract NativeMetaTransaction is EIP712Base {\n    bytes32 private constant META_TRANSACTION_TYPEHASH =\n        keccak256(\n            bytes(\n                \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"\n            )\n        );\n    event MetaTransactionExecuted(\n        address userAddress,\n        address relayerAddress,\n        bytes functionSignature\n    );\n    mapping(address => uint256) nonces;\n\n    /*\n     * Meta transaction structure.\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\n     * He should call the desired function directly in that case.\n     */\n    struct MetaTransaction {\n        uint256 nonce;\n        address from;\n        bytes functionSignature;\n    }\n\n    function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress] + (1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            msg.sender,\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }\n\n    function hashMetaTransaction(MetaTransaction memory metaTx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    META_TRANSACTION_TYPEHASH,\n                    metaTx.nonce,\n                    metaTx.from,\n                    keccak256(metaTx.functionSignature)\n                )\n            );\n    }\n\n    function getNonce(address user) public view returns (uint256 nonce) {\n        nonce = nonces[user];\n    }\n\n    function verify(\n        address signer,\n        MetaTransaction memory metaTx,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) internal view returns (bool) {\n        require(signer != address(0), \"NativeMetaTransaction: INVALID_SIGNER\");\n        return\n            signer ==\n            ecrecover(\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\n                sigV,\n                sigR,\n                sigS\n            );\n    }\n\n    function msgSender() internal view returns (address payable sender) {\n        if (msg.sender == address(this)) {\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            sender = payable(msg.sender);\n        }\n        return sender;\n    }\n}\ncontract EIP712Base is Initializable {\n    struct EIP712Domain {\n        string name;\n        string version;\n        address verifyingContract;\n        bytes32 salt;\n    }\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\"\n            )\n        );\n    bytes32 internal domainSeperator;\n    uint256 private cachedChainId;\n    string private cachedName;\n    string private cachedVersion;\n\n    // supposed to be called once while initializing.\n    // one of the contractsa that inherits this contract follows proxy pattern\n    // so it is not possible to do this in a constructor\n    function _initializeEIP712(string memory name, string memory version)\n        internal\n        initializer\n    {\n        cachedChainId = getChainId();\n        cachedName = name;\n        cachedVersion = version;\n        _setDomainSeperator(name, version);\n    }\n\n    function _setDomainSeperator(string memory name, string memory version)\n        internal\n    {\n        domainSeperator = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                address(this),\n                bytes32(getChainId())\n            )\n        );\n    }\n\n    function getDomainSeperator() public view returns (bytes32) {\n        if (getChainId() == cachedChainId) {\n            return domainSeperator;\n        } else {\n            return\n                keccak256(\n                    abi.encode(\n                        EIP712_DOMAIN_TYPEHASH,\n                        keccak256(bytes(cachedName)),\n                        keccak256(bytes(cachedVersion)),\n                        address(this),\n                        bytes32(getChainId())\n                    )\n                );\n        }\n    }\n\n    function getChainId() public view returns (uint256) {\n        return block.chainid;\n    }\n\n    /**\n     * Accept message hash and returns hash message in EIP712 compatible form\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\n     * https://eips.ethereum.org/EIPS/eip-712\n     * \"\\\\x19\" makes the encoding deterministic\n     * \"\\\\x01\" is the version byte to make it compatible to EIP-191\n     */\n    function toTypedMessageHash(bytes32 messageHash)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash)\n            );\n    }\n}\ncontract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {\n    using SafeERC20 for IERC20;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public override orderbook;\n    /// @dev leaderboard instance\n    IRCLeaderboard public override leaderboard;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev the Factory so only the Factory can add new markets\n    IRCFactory public override factory;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public override marketBalance;\n    /// @dev a quick check if a user is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 public override marketBalanceTopup;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    /// @dev intended for beta use only, will be disabled after launch\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n    /// @dev allow markets to be restricted to a certain role\n    mapping(address => bytes32) public marketWhitelist;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent, claim or upgrade any cards for specific market\n    mapping(address => bool) public override marketPaused;\n    /// @dev if true, owner has locked the market pause (Governors are locked out)\n    mapping(address => bool) public override lockMarketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant WHITELIST = keccak256(\"WHITELIST\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n    event LogWhitelistUser(address user, bool allowed);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        /* setup AccessControl\n\n                         UBER_OWNER\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502           \u2502          \u2502            \u2502         \u2502\n          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD\n            \u2502           \u2502\n         GOVERNOR     MARKET\n            \u2502\n         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE\n        */\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(UBER_OWNER, _msgSender());\n        _setupRole(OWNER, _msgSender());\n        _setupRole(GOVERNOR, _msgSender());\n        _setupRole(WHITELIST, _msgSender());\n        _setupRole(TREASURY, address(this));\n        _setRoleAdmin(UBER_OWNER, UBER_OWNER);\n        _setRoleAdmin(OWNER, UBER_OWNER);\n        _setRoleAdmin(FACTORY, UBER_OWNER);\n        _setRoleAdmin(ORDERBOOK, UBER_OWNER);\n        _setRoleAdmin(TREASURY, UBER_OWNER);\n        _setRoleAdmin(GOVERNOR, OWNER);\n        _setRoleAdmin(WHITELIST, GOVERNOR);\n        _setRoleAdmin(ARTIST, GOVERNOR);\n        _setRoleAdmin(AFFILIATE, GOVERNOR);\n        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);\n        _setRoleAdmin(MARKET, FACTORY);\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1_000_000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks() {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyRole(OWNER)\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @dev this is only a soft check, it is possible to exceed this limit\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyRole(OWNER)\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyRole(OWNER) {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market\n    function changePauseMarket(address _market, bool _paused)\n        external\n        override\n        onlyRole(OWNER)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        marketPaused[_market] = _paused;\n        lockMarketPaused[_market] = marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it\n    function unPauseMarket(address _market)\n        external\n        override\n        onlyRole(FACTORY)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        require(!lockMarketPaused[_market], \"Owner has paused market\");\n        marketPaused[_market] = false;\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyRole(OWNER) {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add/Remove multiple users to the whitelist\n    /// @param _users an array of users to add or remove\n    /// @param add true to add the users\n    function batchWhitelist(address[] calldata _users, bool add)\n        external\n        override\n        onlyRole(GOVERNOR)\n    {\n        if (add) {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.grantRole(WHITELIST, _users[index]);\n            }\n        } else {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.revokeRole(WHITELIST, _users[index]);\n            }\n        }\n    }\n\n    /// @notice Some markets may be restricted to certain roles,\n    /// @notice This function checks if the user has the role requried for a given market\n    /// @dev Used for the markets to check themselves\n    /// @param _user The user to check\n    function marketWhitelistCheck(address _user)\n        external\n        view\n        override\n        returns (bool)\n    {\n        bytes32 requiredRole = marketWhitelist[msgSender()];\n        if (requiredRole == bytes32(0)) {\n            return true;\n        } else {\n            return hasRole(requiredRole, _user);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    function setFactoryAddress(address _newFactory)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newFactory != address(0), \"Must set an address\");\n        // factory is also an OWNER and GOVERNOR to use the proxy functions\n        revokeRole(FACTORY, address(factory));\n        revokeRole(OWNER, address(factory));\n        revokeRole(GOVERNOR, address(factory));\n        factory = IRCFactory(_newFactory);\n        grantRole(FACTORY, address(factory));\n        grantRole(OWNER, address(factory));\n        grantRole(GOVERNOR, address(factory));\n    }\n\n    function setOrderbookAddress(address _newOrderbook)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newOrderbook != address(0), \"Must set an address\");\n        revokeRole(ORDERBOOK, address(orderbook));\n        orderbook = IRCOrderbook(_newOrderbook);\n        grantRole(ORDERBOOK, address(orderbook));\n        factory.setOrderbookAddress(orderbook);\n    }\n\n    function setLeaderboardAddress(address _newLeaderboard)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newLeaderboard != address(0), \"Must set an address\");\n        leaderboard = IRCLeaderboard(_newLeaderboard);\n        factory.setLeaderboardAddress(leaderboard);\n    }\n\n    function setTokenAddress(address _newToken)\n        public\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner\n    function globalExit() external onlyRole(UBER_OWNER) {\n        uint256 _balance = erc20.balanceOf(address(this));\n        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised\n        erc20.safeTransfer(msg.sender, _balance);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        external\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(hasRole(WHITELIST, _user), \"Not in whitelist\");\n        }\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        assessForeclosure(_user);\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // step 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.safeTransfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        // do some cleaning up first, it might help avoid their foreclosure\n        orderbook.removeOldBids(_msgSender);\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            // foreclose user, this is requred to remove them from the orderbook\n            isForeclosed[_msgSender] = true;\n            // remove them from the orderbook\n            orderbook.removeUserFromOrderbook(_msgSender);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount)\n        external\n        override\n        balancedBooks\n    {\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n        marketBalanceTopup += _amount;\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (uint256)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            uint256 discrepancy = _amount - marketBalance;\n            if (discrepancy > marketBalanceTopup) {\n                marketBalanceTopup = 0;\n            } else {\n                marketBalanceTopup -= discrepancy;\n            }\n            _amount = marketBalance;\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n        /// @dev return the amount just incase it was adjusted\n        return _amount;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        assessForeclosure(_user);\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        assessForeclosure(_user);\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        address _msgSender = msgSender();\n        require(!lockMarketPaused[_msgSender], \"Market is paused\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.safeTransferFrom(_sponsor, address(this), _amount);\n        marketPot[_msgSender] += _amount;\n        totalMarketPots += _amount;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyRole(MARKET)\n    {\n        // update the last rental time\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        // check if this is their first rental (no previous rental calculation)\n        if (user[_user].lastRentCalc == 0) {\n            // we need to start their clock ticking, update their last rental calculation time\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function addMarket(address _market, bool _paused) external override {\n        require(hasRole(FACTORY, msgSender()), \"Not Authorised\");\n        marketPaused[_market] = _paused;\n        AccessControl.grantRole(MARKET, _market);\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice provides the sum total of a users bids across all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyRole(ORDERBOOK) {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !hasRole(MARKET, _newOwner)\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(\n                    user[_newOwner].lastRentCalc,\n                    _timeOwnershipChanged,\n                    _newPrice\n                );\n\n                // they have enough funds, just collect the extra\n                // we can be sure of this because it was checked they can cover the minimum rental\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                    // send an event for the UI to have a timestamp\n                    emit LogAdjustDeposit(_newOwner, 0, false);\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calculation and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calculates the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestamps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /\n                totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +\n                timeLeftOfDeposit;\n\n            if (\n                foreclosureTimeWithoutNewCard > _timeOfNewBid &&\n                _timeOfNewBid != 0\n            ) {\n                // calculate how long they can own the new card for\n                uint256 _rentDifference = rentOwedBetweenTimestamps(\n                    user[_user].lastRentCalc,\n                    _timeOfNewBid,\n                    totalUserDailyRent\n                );\n                uint256 _depositAtTimeOfNewBid = 0;\n\n                if (user[_user].lastRentCalc < _timeOfNewBid) {\n                    // new bid is after user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit -\n                        _rentDifference;\n                } else {\n                    // new bid is before user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit +\n                        _rentDifference;\n                }\n\n                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *\n                    1 days) / (totalUserDailyRent + _newBid);\n\n                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +\n                    _timeLeftOfDepositWithNewBid;\n                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {\n                    return _foreclosureTimeWithNewCard;\n                } else {\n                    // The user couldn't afford to own the new card up to their last\n                    // .. rent calculation, we can't rewind their rent calculation because\n                    // .. of gas limits (there could be many markets having taken rent).\n                    // Therefore unfortunately we can't give any ownership to this user as\n                    // .. this could mean getting caught in a loop we may not be able to\n                    // .. exit because of gas limits (there could be many users in this\n                    // .. situation and we can't leave any unaccounted for).\n                    // This means we return 0 to signify that the user can't afford this\n                    // .. new ownership.\n                    return 0;\n                }\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            if (_newBid == 0) {\n                // if no rentals they'll foreclose after the heat death of the universe\n                return type(uint256).max;\n            } else {\n                return\n                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);\n            }\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        require(_timeToCollectTo != 0, \"Must set collection time\");\n        require(\n            _timeToCollectTo <= block.timestamp,\n            \"Can't collect future rent\"\n        );\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts = ((_timeToCollectTo -\n                    previousCollectionTime) * uint256(user[_user].deposit)) /\n                    rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepositLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets available balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n\n    /// @notice checks if the user should still be foreclosed\n    function assessForeclosure(address _user) public override {\n        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        } else {\n            isForeclosed[_user] = true;\n            emit LogUserForeclosed(_user, true);\n        }\n    }\n\n    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual\n    function checkPermission(bytes32 role, address account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return AccessControl.hasRole(role, account);\n    }\n\n    function grantRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.grantRole(_role, account);\n    }\n\n    function grantRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, true);\n        }\n        AccessControl.grantRole(role, account);\n    }\n\n    function revokeRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.revokeRole(_role, account);\n    }\n\n    function revokeRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, false);\n        }\n        AccessControl.revokeRole(role, account);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\ncontract RCLeaderboard is NativeMetaTransaction, IRCLeaderboard {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    // Contracts and Permissions\n    IRCTreasury public override treasury;\n    IRCMarket public override market;\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n\n    // Leaderboard tracking\n    struct Leaderboard {\n        address next;\n        address prev;\n        address market;\n        uint256 card;\n        uint256 timeHeld;\n    }\n    mapping(address => Leaderboard[]) public leaderboard;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) leaderboardIndex;\n    mapping(address => mapping(uint256 => uint256)) public leaderboardLength;\n    mapping(address => uint256) public override NFTsToAward;\n\n    /// @dev emitted every time an order is added to the orderbook\n    event LogAddToLeaderboard(address _user, address _market, uint256 _card);\n    /// @dev emitted when an order is removed from the orderbook\n    event LogRemoveFromLeaderboard(\n        address _user,\n        address _market,\n        uint256 _card\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CONSTRUCTOR             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(IRCTreasury _treasury) {\n        treasury = _treasury;\n    }\n\n    modifier onlyMarkets() {\n        require(\n            treasury.checkPermission(MARKET, msgSender()),\n            \"Not authorised\"\n        );\n        _;\n    }\n    modifier onlyFactory() {\n        require(\n            treasury.checkPermission(FACTORY, msgSender()),\n            \"Extremely Verboten\"\n        );\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      Leaderboard Tracking       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice adds a new market to the leaderboard\n    /// @param _market the address of the market to add\n    /// @param _cardCount the number of cards in the market\n    /// @param _nftsToAward how many users on the leaderboard can claim an NFT\n    function addMarket(\n        address _market,\n        uint256 _cardCount,\n        uint256 _nftsToAward\n    ) internal {\n        NFTsToAward[_market] = _nftsToAward;\n        for (uint64 i = 0; i < _cardCount; i++) {\n            // create new record for each card that becomes the head&tail of the linked list\n            Leaderboard memory _newRecord;\n            _newRecord.card = i;\n            _newRecord.next = _market;\n            _newRecord.prev = _market;\n            _newRecord.market = _market;\n            _newRecord.timeHeld = type(uint256).max;\n            leaderboardIndex[_market][_market][i] = leaderboard[_market].length;\n            leaderboard[_market].push(_newRecord);\n        }\n    }\n\n    /// @notice update a users timeHeld on the leaderboard\n    /// @param _user the user to update\n    /// @param _card the card number to update\n    /// @param _timeHeld how long (total) the user has held the card\n    function updateLeaderboard(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeld\n    ) external override onlyMarkets {\n        address _market = msgSender();\n\n        // check if the market has been initialised\n        if (!userIsOnLeaderboard(_market, _market, _card)) {\n            uint256 _cardCount = IRCMarket(_market).numberOfCards();\n            uint256 _nftsToAward = IRCMarket(_market).nftsToAward();\n            addMarket(_market, _cardCount, _nftsToAward);\n        }\n\n        // is the leaderboard full yet?\n        if (leaderboardLength[_market][_card] < NFTsToAward[_market]) {\n            // leaderboard isn't full, just add them\n            if (userIsOnLeaderboard(_user, _market, _card)) {\n                // user is already on the leaderboard, remove them first\n                removeFromLeaderboard(_user, _market, _card);\n            }\n            addToLeaderboard(_user, _market, _card, _timeHeld);\n            emit LogAddToLeaderboard(_user, _market, _card);\n        } else {\n            // leaderboard is full\n            address lastUserOnLeaderboard = leaderboard[_market][\n                leaderboardIndex[_market][_market][_card]\n            ].prev;\n            uint256 minimumTimeOnLeaderboard = leaderboard[\n                lastUserOnLeaderboard\n            ][leaderboardIndex[lastUserOnLeaderboard][_market][_card]].timeHeld;\n\n            // does this user deserve to be on the leaderboard?\n            if (_timeHeld > minimumTimeOnLeaderboard) {\n                // user deserves to be on leaderboard\n                if (userIsOnLeaderboard(_user, _market, _card)) {\n                    // user is already on the leaderboard, remove them first\n                    removeFromLeaderboard(_user, _market, _card);\n                } else {\n                    // bump the last user off the leaderboard to make space\n                    removeFromLeaderboard(\n                        lastUserOnLeaderboard,\n                        _market,\n                        _card\n                    );\n                    emit LogRemoveFromLeaderboard(\n                        lastUserOnLeaderboard,\n                        _market,\n                        _card\n                    );\n                }\n                // now add them in the correct position\n                addToLeaderboard(_user, _market, _card, _timeHeld);\n                emit LogAddToLeaderboard(_user, _market, _card);\n            }\n        }\n    }\n\n    /// @dev add a user to the leaderboard\n    function addToLeaderboard(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _timeHeld\n    ) internal {\n        Leaderboard memory _currRecord = leaderboard[_market][\n            leaderboardIndex[_market][_market][_card]\n        ];\n        address _nextUser = _currRecord.next;\n        // find the correct position\n        // TODO would it be better on average to search the leaderboard from the bottom?\n        while (\n            _timeHeld <\n            leaderboard[_nextUser][leaderboardIndex[_nextUser][_market][_card]]\n                .timeHeld &&\n            _nextUser != _market\n        ) {\n            _currRecord = leaderboard[_nextUser][\n                leaderboardIndex[_nextUser][_market][_card]\n            ];\n            _nextUser = _currRecord.next;\n        }\n\n        address _prevUser = leaderboard[_nextUser][\n            leaderboardIndex[_nextUser][_market][_card]\n        ].prev;\n\n        // create new record\n        Leaderboard memory _newRecord;\n        _newRecord.card = _card;\n        _newRecord.market = _market;\n        _newRecord.next = _nextUser;\n        _newRecord.prev = _prevUser;\n        _newRecord.timeHeld = _timeHeld;\n\n        // insert in linked list\n        leaderboard[_nextUser][leaderboardIndex[_nextUser][_market][_card]]\n            .prev = _user;\n        leaderboard[_prevUser][leaderboardIndex[_prevUser][_market][_card]]\n            .next = _user;\n        leaderboard[_user].push(_newRecord);\n\n        //update the index to help find the record later\n        leaderboardIndex[_user][_market][_card] = leaderboard[_user].length - 1;\n\n        leaderboardLength[_market][_card]++;\n    }\n\n    /// @dev remove a user from the leaderboard\n    function removeFromLeaderboard(\n        address _user,\n        address _market,\n        uint256 _card\n    ) internal {\n        uint256 _index = leaderboardIndex[_user][_market][_card];\n        address _nextUser = leaderboard[_user][_index].next;\n        address _prevUser = leaderboard[_user][_index].prev;\n\n        // unlink from list\n        leaderboard[_nextUser][leaderboardIndex[_nextUser][_market][_card]]\n            .prev = _prevUser;\n        leaderboard[_prevUser][leaderboardIndex[_prevUser][_market][_card]]\n            .next = _nextUser;\n\n        // overwrite array element\n        uint256 _lastRecord = leaderboard[_user].length - 1;\n        // no point overwriting itself\n        if (_index != _lastRecord) {\n            leaderboard[_user][_index] = leaderboard[_user][_lastRecord];\n        }\n        leaderboard[_user].pop();\n\n        // update the index to help find the record later\n        leaderboardIndex[_user][_market][_card] = 0;\n        if (leaderboard[_user].length != 0 && _index != _lastRecord) {\n            leaderboardIndex[_user][leaderboard[_user][_index].market][\n                leaderboard[_user][_index].card\n            ] = _index;\n        }\n\n        leaderboardLength[_market][_card]--;\n    }\n\n    /// @notice check if a user is on the leaderboard\n    /// @param _user the user address to check\n    /// @param _market the market address to check\n    /// @param _card the cardId to check\n    function userIsOnLeaderboard(\n        address _user,\n        address _market,\n        uint256 _card\n    ) public view returns (bool) {\n        if (leaderboard[_user].length != 0) {\n            // user is on a leaderboard\n            if (leaderboardIndex[_user][_market][_card] != 0) {\n                // user is on the leaderboard with this card\n                return true;\n            } else {\n                if (\n                    leaderboard[_user][0].market == _market &&\n                    leaderboard[_user][0].card == _card\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /// @notice check if a user is on the leaderboard so they can claim an NFT\n    // TODO the longest owner will never get deleted because they can't call claimNFT\n    function claimNFT(address _user, uint256 _card)\n        external\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        require(\n            userIsOnLeaderboard(_user, _market, _card),\n            \"Not in leaderboard\"\n        );\n        /// @dev we don't need to keep a record now, removing will offset\n        /// @dev .. some of the gas which will be needed for minting.\n        removeFromLeaderboard(_user, _market, _card);\n    }\n\n    /// @notice returns the full leaderboard list\n    /// @dev useful for debugging, uncomment the console.logs\n    function printLeaderboard(address _market, uint256 _card)\n        external\n        view\n        returns (address[] memory)\n    {\n        address[] memory leaderboardList = new address[](\n            leaderboardLength[_market][_card]\n        );\n        Leaderboard memory _currRecord = leaderboard[_market][\n            leaderboardIndex[_market][_market][_card]\n        ];\n        address _nextUser = _currRecord.next;\n        uint256 i = 0;\n        // console.log(\"Market address \", _market);\n        while (_nextUser != _market) {\n            leaderboardList[i] = _nextUser;\n            // console.log(\"Printing orderbook \", _nextUser);\n            _currRecord = leaderboard[_nextUser][\n                leaderboardIndex[_nextUser][_market][_card]\n            ];\n            _nextUser = _currRecord.next;\n            i++;\n        }\n        // console.log(\" done printing orderbook\");\n        return leaderboardList;\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n",
    "bin": []
}