{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/28",
    "external_functions": [
        [
            "PointList"
        ],
        [
            "BatchAuction",
            "IERC20",
            "IPointList"
        ],
        [
            "Crowdsale",
            "IERC20",
            "IPointList"
        ],
        [
            "DutchAuction",
            "IERC20",
            "IPointList"
        ],
        [
            "HyperbolicAuction",
            "IERC20",
            "IPointList"
        ],
        [
            "MISOLauncher",
            "MISOAccessControls",
            "IBentoBoxFactory",
            "IMisoLiquidity",
            "IERC20"
        ],
        [
            "MISOMarket",
            "MISOAccessControls",
            "IMisoMarket",
            "IBentoBoxFactory",
            "IERC20"
        ]
    ],
    "new_contract": "abstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\ncontract DutchAuction is IMisoMarket, MISOAccessControls, BoringBatchable, SafeTransfer, Documents , ReentrancyGuard  {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n    using BoringERC20 for IERC20;\n\n    /// @notice MISOMarket template id for the factory contract.\n    /// @dev For different marketplace types, this must be incremented.\n    uint256 public constant override marketTemplate = 2;\n    /// @dev The placeholder ETH address.\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Main market variables.\n    struct MarketInfo {\n        uint64 startTime;\n        uint64 endTime;\n        uint128 totalTokens;\n    }\n    MarketInfo public marketInfo;\n\n    /// @notice Market price variables.\n    struct MarketPrice {\n        uint128 startPrice;\n        uint128 minimumPrice;\n    }\n    MarketPrice public marketPrice;\n\n    /// @notice Market dynamic variables.\n    struct MarketStatus {\n        uint128 commitmentsTotal;\n        bool finalized;\n        bool usePointList;\n    }\n\n    MarketStatus public marketStatus;\n\n    /// @notice The token being sold.\n    address public auctionToken; \n    /// @notice The currency the auction accepts for payment. Can be ETH or token address.\n    address public paymentCurrency;  \n    /// @notice Where the auction funds will get paid.\n    address payable public wallet;  \n    /// @notice Address that manages auction approvals.\n    address public pointList;\n\n    /// @notice The commited amount of accounts.\n    mapping(address => uint256) public commitments; \n    /// @notice Amount of tokens to claim per address.\n    mapping(address => uint256) public claimed;\n\n    /// @notice Event for updating auction times.  Needs to be before auction starts.\n    event AuctionTimeUpdated(uint256 startTime, uint256 endTime); \n    /// @notice Event for updating auction prices. Needs to be before auction starts.\n    event AuctionPriceUpdated(uint256 startPrice, uint256 minimumPrice); \n    /// @notice Event for updating auction wallet. Needs to be before auction starts.\n    event AuctionWalletUpdated(address wallet); \n\n    /// @notice Event for adding a commitment.\n    event AddedCommitment(address addr, uint256 commitment);   \n    /// @notice Event for finalization of the auction.\n    event AuctionFinalized();\n    /// @notice Event for cancellation of the auction.\n    event AuctionCancelled();\n\n    /**\n     * @notice Initializes main contract variables and transfers funds for the auction.\n     * @dev Init function.\n     * @param _funder The address that funds the token for crowdsale.\n     * @param _token Address of the token being sold.\n     * @param _totalTokens The total number of tokens to sell in auction.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.\n     * @param _startPrice Starting price of the auction.\n     * @param _minimumPrice The minimum auction price.\n     * @param _admin Address that can finalize auction.\n     * @param _pointList Address that will manage auction approvals.\n     * @param _wallet Address where collected funds will be forwarded to.\n     */\n    function initAuction(\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _startPrice,\n        uint256 _minimumPrice,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    ) public {\n        require(_startTime < 10000000000, \"DutchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_endTime < 10000000000, \"DutchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"DutchAuction: start time is before current time\");\n        require(_endTime > _startTime, \"DutchAuction: end time must be older than start price\");\n        require(_totalTokens > 0,\"DutchAuction: total tokens must be greater than zero\");\n        require(_startPrice > _minimumPrice, \"DutchAuction: start price must be higher than minimum price\");\n        require(_minimumPrice > 0, \"DutchAuction: minimum price must be greater than 0\"); \n        require(_admin != address(0), \"DutchAuction: admin is the zero address\");\n        require(_wallet != address(0), \"DutchAuction: wallet is the zero address\");\n        require(IERC20(_token).decimals() == 18, \"DutchAuction: Token does not have 18 decimals\");\n        if (_paymentCurrency != ETH_ADDRESS) {\n            require(IERC20(_paymentCurrency).decimals() > 0, \"DutchAuction: Payment currency is not ERC20\");\n        }\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        marketInfo.totalTokens = BoringMath.to128(_totalTokens);\n\n        marketPrice.startPrice = BoringMath.to128(_startPrice);\n        marketPrice.minimumPrice = BoringMath.to128(_minimumPrice);\n\n        auctionToken = _token;\n        paymentCurrency = _paymentCurrency;\n        wallet = _wallet;\n\n        initAccessControls(_admin);\n\n        _setList(_pointList);\n        _safeTransferFrom(_token, _funder, _totalTokens);\n    }\n\n\n\n    /**\n     Dutch Auction Price Function\n     ============================\n     \n     Start Price -----\n                      \\\n                       \\\n                        \\\n                         \\ ------------ Clearing Price\n                        / \\            = AmountRaised/TokenSupply\n         Token Price  --   \\\n                     /      \\\n                   --        ----------- Minimum Price\n     Amount raised /          End Time\n    */\n\n    /**\n     * @notice Calculates the average price of each token from all commitments.\n     * @return Average token price.\n     */\n    function tokenPrice() public view returns (uint256) {\n        return uint256(marketStatus.commitmentsTotal)\n            .mul(1e18).div(uint256(marketInfo.totalTokens));\n    }\n\n    /**\n     * @notice Returns auction price in any time.\n     * @return Fixed start price or minimum price if outside of auction time, otherwise calculated current price.\n     */\n    function priceFunction() public view returns (uint256) {\n        /// @dev Return Auction Price\n        if (block.timestamp <= uint256(marketInfo.startTime)) {\n            return uint256(marketPrice.startPrice);\n        }\n        if (block.timestamp >= uint256(marketInfo.endTime)) {\n            return uint256(marketPrice.minimumPrice);\n        }\n\n        return _currentPrice();\n    }\n\n    /**\n     * @notice The current clearing price of the Dutch auction.\n     * @return The bigger from tokenPrice and priceFunction.\n     */\n    function clearingPrice() public view returns (uint256) {\n        /// @dev If auction successful, return tokenPrice\n        if (tokenPrice() > priceFunction()) {\n            return tokenPrice();\n        }\n        return priceFunction();\n    }\n\n\n    ///--------------------------------------------------------\n    /// Commit to buying tokens!\n    ///--------------------------------------------------------\n\n    receive() external payable {\n        revertBecauseUserDidNotProvideAgreement();\n    }\n\n    /** \n     * @dev Attribution to the awesome delta.financial contracts\n    */  \n    function marketParticipationAgreement() public pure returns (string memory) {\n        return \"I understand that I'm interacting with a smart contract. I understand that tokens commited are subject to the token issuer and local laws where applicable. I reviewed code of the smart contract and understand it fully. I agree to not hold developers or other people associated with the project liable for any losses or misunderstandings\";\n    }\n    /** \n     * @dev Not using modifiers is a purposeful choice for code readability.\n    */ \n    function revertBecauseUserDidNotProvideAgreement() internal pure {\n        revert(\"No agreement provided, please review the smart contract before interacting with it\");\n    }\n\n    /**\n     * @notice Checks the amount of ETH to commit and adds the commitment. Refunds the buyer if commit is too high.\n     * @param _beneficiary Auction participant ETH address.\n     */\n    function commitEth(\n        address payable _beneficiary,\n        bool readAndAgreedToMarketParticipationAgreement\n    )\n        public payable\n    {\n        require(paymentCurrency == ETH_ADDRESS, \"DutchAuction: payment currency is not ETH address\"); \n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n        // Get ETH able to be committed\n        uint256 ethToTransfer = calculateCommitment(msg.value);\n\n        /// @notice Accept ETH Payments.\n        uint256 ethToRefund = msg.value.sub(ethToTransfer);\n        if (ethToTransfer > 0) {\n            _addCommitment(_beneficiary, ethToTransfer);\n        }\n        /// @notice Return any ETH to be refunded.\n        if (ethToRefund > 0) {\n            _beneficiary.transfer(ethToRefund);\n        }\n\n        /// @notice Revert if commitmentsTotal exceeds the balance\n        require(marketStatus.commitmentsTotal <= address(this).balance, \"DutchAuction: The committed ETH exceeds the balance\");\n    }\n\n    /**\n     * @notice Buy Tokens by commiting approved ERC20 tokens to this contract address.\n     * @param _amount Amount of tokens to commit.\n     */\n    function commitTokens(uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public {\n        commitTokensFrom(msg.sender, _amount, readAndAgreedToMarketParticipationAgreement);\n    }\n\n\n    /**\n     * @notice Checks how much is user able to commit and processes that commitment.\n     * @dev Users must approve contract prior to committing tokens to auction.\n     * @param _from User ERC20 address.\n     * @param _amount Amount of approved ERC20 tokens.\n     */\n    function commitTokensFrom(\n        address _from,\n        uint256 _amount,\n        bool readAndAgreedToMarketParticipationAgreement\n    )\n        public   nonReentrant  \n    {\n        require(address(paymentCurrency) != ETH_ADDRESS, \"DutchAuction: Payment currency is not a token\");\n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n        uint256 tokensToTransfer = calculateCommitment(_amount);\n        if (tokensToTransfer > 0) {\n            _safeTransferFrom(paymentCurrency, msg.sender, tokensToTransfer);\n            _addCommitment(_from, tokensToTransfer);\n        }\n    }\n\n    /**\n     * @notice Calculates the pricedrop factor.\n     * @return Value calculated from auction start and end price difference divided the auction duration.\n     */\n    function priceDrop() public view returns (uint256) {\n        MarketInfo memory _marketInfo = marketInfo;\n        MarketPrice memory _marketPrice = marketPrice;\n\n        uint256 numerator = uint256(_marketPrice.startPrice.sub(_marketPrice.minimumPrice));\n        uint256 denominator = uint256(_marketInfo.endTime.sub(_marketInfo.startTime));\n        return numerator / denominator;\n    }\n\n\n   /**\n     * @notice How many tokens the user is able to claim.\n     * @param _user Auction participant address.\n     * @return claimerCommitment User commitments reduced by already claimed tokens.\n     */\n    function tokensClaimable(address _user) public view returns (uint256 claimerCommitment) {\n        if (commitments[_user] == 0) return 0;\n        uint256 unclaimedTokens = IERC20(auctionToken).balanceOf(address(this));\n\n        claimerCommitment = commitments[_user].mul(uint256(marketInfo.totalTokens)).div(uint256(marketStatus.commitmentsTotal));\n        claimerCommitment = claimerCommitment.sub(claimed[_user]);\n\n        if(claimerCommitment > unclaimedTokens){\n            claimerCommitment = unclaimedTokens;\n        }\n    }\n\n    /**\n     * @notice Calculates total amount of tokens committed at current auction price.\n     * @return Number of tokens commited.\n     */\n    function totalTokensCommitted() public view returns (uint256) {\n        return uint256(marketStatus.commitmentsTotal).mul(1e18).div(clearingPrice());\n    }\n\n    /**\n     * @notice Calculates the amout able to be committed during an auction.\n     * @param _commitment Commitment user would like to make.\n     * @return committed Amount allowed to commit.\n     */\n    function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) {\n        uint256 maxCommitment = uint256(marketInfo.totalTokens).mul(clearingPrice()).div(1e18);\n        if (uint256(marketStatus.commitmentsTotal).add(_commitment) > maxCommitment) {\n            return maxCommitment.sub(uint256(marketStatus.commitmentsTotal));\n        }\n        return _commitment;\n    }\n\n    /**\n     * @notice Checks if the auction is open.\n     * @return True if current time is greater than startTime and less than endTime.\n     */\n    function isOpen() public view returns (bool) {\n        return block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime);\n    }\n\n    /**\n     * @notice Successful if tokens sold equals totalTokens.\n     * @return True if tokenPrice is bigger or equal clearingPrice.\n     */\n    function auctionSuccessful() public view returns (bool) {\n        return tokenPrice() >= clearingPrice();\n    }\n\n    /**\n     * @notice Checks if the auction has ended.\n     * @return True if auction is successful or time has ended.\n     */\n    function auctionEnded() public view returns (bool) {\n        return auctionSuccessful() || block.timestamp > uint256(marketInfo.endTime);\n    }\n\n    /**\n     * @return Returns true if market has been finalized\n     */\n    function finalized() public view returns (bool) {\n        return marketStatus.finalized;\n    }\n\n    /**\n     * @return Returns true if 7 days have passed since the end of the auction\n     */\n    function finalizeTimeExpired() public view returns (bool) {\n        return uint256(marketInfo.endTime) + 7 days < block.timestamp;\n    }\n\n    /**\n     * @notice Calculates price during the auction.\n     * @return Current auction price.\n     */\n    function _currentPrice() private view returns (uint256) {\n        uint256 priceDiff = block.timestamp.sub(uint256(marketInfo.startTime)).mul(priceDrop());\n        return uint256(marketPrice.startPrice).sub(priceDiff);\n    }\n\n    /**\n     * @notice Updates commitment for this address and total commitment of the auction.\n     * @param _addr Bidders address.\n     * @param _commitment The amount to commit.\n     */\n    function _addCommitment(address _addr, uint256 _commitment) internal {\n        require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), \"DutchAuction: outside auction hours\");\n        MarketStatus storage status = marketStatus;\n        \n        uint256 newCommitment = commitments[_addr].add(_commitment);\n        if (status.usePointList) {\n            require(IPointList(pointList).hasPoints(_addr, newCommitment));\n        }\n        \n        commitments[_addr] = newCommitment;\n        status.commitmentsTotal = BoringMath.to128(uint256(status.commitmentsTotal).add(_commitment));\n        emit AddedCommitment(_addr, _commitment);\n    }\n\n\n    //--------------------------------------------------------\n    // Finalize Auction\n    //--------------------------------------------------------\n\n\n    /**\n     * @notice Cancel Auction\n     * @dev Admin can cancel the auction before it starts\n     */\n    function cancelAuction() public   nonReentrant  \n    {\n        require(hasAdminRole(msg.sender));\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"DutchAuction: auction already finalized\");\n        require( uint256(status.commitmentsTotal) == 0, \"DutchAuction: auction already committed\" );\n        _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));\n        status.finalized = true;\n        emit AuctionCancelled();\n    }\n\n    /**\n     * @notice Auction finishes successfully above the reserve.\n     * @dev Transfer contract funds to initialized wallet.\n     */\n    function finalize() public   nonReentrant  \n    {\n\n        require(hasAdminRole(msg.sender) \n                || hasSmartContractRole(msg.sender) \n                || wallet == msg.sender\n                || finalizeTimeExpired(), \"DutchAuction: sender must be an admin\");\n        MarketStatus storage status = marketStatus;\n\n        require(!status.finalized, \"DutchAuction: auction already finalized\");\n        if (auctionSuccessful()) {\n            /// @dev Successful auction\n            /// @dev Transfer contributed tokens to wallet.\n            _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));\n        } else {\n            /// @dev Failed auction\n            /// @dev Return auction tokens back to wallet.\n            require(block.timestamp > uint256(marketInfo.endTime), \"DutchAuction: auction has not finished yet\"); \n            _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));\n        }\n        status.finalized = true;\n        emit AuctionFinalized();\n    }\n\n\n    /// @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.\n    function withdrawTokens() public  {\n        withdrawTokens(msg.sender);\n    }\n\n   /**\n     * @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.\n     * @dev Withdraw tokens only after auction ends.\n     * @param beneficiary Whose tokens will be withdrawn.\n     */\n    function withdrawTokens(address payable beneficiary) public   nonReentrant  {\n        if (auctionSuccessful()) {\n            require(marketStatus.finalized, \"DutchAuction: not finalized\");\n            /// @dev Successful auction! Transfer claimed tokens.\n            uint256 tokensToClaim = tokensClaimable(beneficiary);\n            require(tokensToClaim > 0, \"DutchAuction: No tokens to claim\"); \n            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);\n            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);\n        } else {\n            /// @dev Auction did not meet reserve price.\n            /// @dev Return committed funds back to user.\n            require(block.timestamp > uint256(marketInfo.endTime), \"DutchAuction: auction has not finished yet\");\n            uint256 fundsCommitted = commitments[beneficiary];\n            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas\n            _safeTokenPayment(paymentCurrency, beneficiary, fundsCommitted);\n        }\n    }\n\n\n    //--------------------------------------------------------\n    // Documents\n    //--------------------------------------------------------\n\n    function setDocument(string calldata _name, string calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        _setDocument( _name, _data);\n    }\n\n    function setDocuments(string[] calldata _name, string[] calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        uint256 numDocs = _name.length;\n        for (uint256 i = 0; i < numDocs; i++) {\n            _setDocument( _name[i], _data[i]);\n        }\n    }\n\n    function removeDocument(string calldata _name) external {\n        require(hasAdminRole(msg.sender));\n        _removeDocument(_name);\n    }\n\n\n    //--------------------------------------------------------\n    // Point Lists\n    //--------------------------------------------------------\n\n\n    function setList(address _list) external {\n        require(hasAdminRole(msg.sender));\n        _setList(_list);\n    }\n\n    function enableList(bool _status) external {\n        require(hasAdminRole(msg.sender));\n        marketStatus.usePointList = _status;\n    }\n\n    function _setList(address _pointList) private {\n        if (_pointList != address(0)) {\n            pointList = _pointList;\n            marketStatus.usePointList = true;\n        }\n    }\n\n    //--------------------------------------------------------\n    // Setter Functions\n    //--------------------------------------------------------\n\n    /**\n     * @notice Admin can set start and end time through this function.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     */\n    function setAuctionTime(uint256 _startTime, uint256 _endTime) external {\n        require(hasAdminRole(msg.sender));\n        require(_startTime < 10000000000, \"DutchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_endTime < 10000000000, \"DutchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"DutchAuction: start time is before current time\");\n        require(_endTime > _startTime, \"DutchAuction: end time must be older than start time\");\n        require(marketStatus.commitmentsTotal == 0, \"DutchAuction: auction cannot have already started\");\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        \n        emit AuctionTimeUpdated(_startTime,_endTime);\n    }\n\n    /**\n     * @notice Admin can set start and min price through this function.\n     * @param _startPrice Auction start price.\n     * @param _minimumPrice Auction minimum price.\n     */\n    function setAuctionPrice(uint256 _startPrice, uint256 _minimumPrice) external {\n        require(hasAdminRole(msg.sender));\n        require(_startPrice > _minimumPrice, \"DutchAuction: start price must be higher than minimum price\");\n        require(_minimumPrice > 0, \"DutchAuction: minimum price must be greater than 0\"); \n        require(marketStatus.commitmentsTotal == 0, \"DutchAuction: auction cannot have already started\");\n\n        marketPrice.startPrice = BoringMath.to128(_startPrice);\n        marketPrice.minimumPrice = BoringMath.to128(_minimumPrice);\n\n        emit AuctionPriceUpdated(_startPrice,_minimumPrice);\n    }\n\n    /**\n     * @notice Admin can set the auction wallet through this function.\n     * @param _wallet Auction wallet is where funds will be sent.\n     */\n    function setAuctionWallet(address payable _wallet) external {\n        require(hasAdminRole(msg.sender));\n        require(_wallet != address(0), \"DutchAuction: wallet is the zero address\");\n\n        wallet = _wallet;\n\n        emit AuctionWalletUpdated(_wallet);\n    }\n\n\n   //--------------------------------------------------------\n    // Market Launchers\n    //--------------------------------------------------------\n\n    /**\n     * @notice Decodes and hands auction data to the initAuction function.\n     * @param _data Encoded data for initialization.\n     */\n\n    function init(bytes calldata _data) external override payable {\n\n    }\n\n    function initMarket(\n        bytes calldata _data\n    ) public override {\n        (\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _startPrice,\n        uint256 _minimumPrice,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n        ) = abi.decode(_data, (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            uint256,\n            address,\n            address,\n            address\n        ));\n        initAuction(_funder, _token, _totalTokens, _startTime, _endTime, _paymentCurrency, _startPrice, _minimumPrice, _admin, _pointList, _wallet);\n    }\n\n    /**\n     * @notice Collects data to initialize the auction and encodes them.\n     * @param _funder The address that funds the token for crowdsale.\n     * @param _token Address of the token being sold.\n     * @param _totalTokens The total number of tokens to sell in auction.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.\n     * @param _startPrice Starting price of the auction.\n     * @param _minimumPrice The minimum auction price.\n     * @param _admin Address that can finalize auction.\n     * @param _pointList Address that will manage auction approvals.\n     * @param _wallet Address where collected funds will be forwarded to.\n     * @return _data All the data in bytes format.\n     */\n    function getAuctionInitData(\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _startPrice,\n        uint256 _minimumPrice,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    )\n        external \n        pure\n        returns (bytes memory _data)\n    {\n            return abi.encode(\n                _funder,\n                _token,\n                _totalTokens,\n                _startTime,\n                _endTime,\n                _paymentCurrency,\n                _startPrice,\n                _minimumPrice,\n                _admin,\n                _pointList,\n                _wallet\n            );\n    }\n        \n    function getBaseInformation() external view returns(\n        address, \n        uint64,\n        uint64,\n        bool \n    ) {\n        return (auctionToken, marketInfo.startTime, marketInfo.endTime, marketStatus.finalized);\n    }\n\n    function getTotalTokens() external view returns(uint256) {\n        return uint256(marketInfo.totalTokens);\n    }\n\n}\ncontract MISOAdminAccess is AccessControl {\n\n    /// @dev Whether access is initialised.\n    bool private initAccess;\n\n    /// @notice Events for adding and removing various roles.\n    event AdminRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n\n    event AdminRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n\n\n    /// @notice The deployer is automatically given the admin role which will allow them to then grant roles to other addresses.\n    constructor() public {\n    }\n\n    /**\n     * @notice Initializes access controls.\n     * @param _admin Admins address.\n     */\n    function initAccessControls(address _admin) public {\n        require(!initAccess, \"Already initialised\");\n        require(_admin != address(0), \"Incorrect input\");\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        initAccess = true;\n    }\n\n    /////////////\n    // Lookups //\n    /////////////\n\n    /**\n     * @notice Used to check whether an address has the admin role.\n     * @param _address EOA or contract being checked.\n     * @return bool True if the account has the role or false if it does not.\n     */\n    function hasAdminRole(address _address) public  view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, _address);\n    }\n\n    ///////////////\n    // Modifiers //\n    ///////////////\n\n    /**\n     * @notice Grants the admin role to an address.\n     * @dev The sender must have the admin role.\n     * @param _address EOA or contract receiving the new role.\n     */\n    function addAdminRole(address _address) external {\n        grantRole(DEFAULT_ADMIN_ROLE, _address);\n        emit AdminRoleGranted(_address, _msgSender());\n    }\n\n    /**\n     * @notice Removes the admin role from an address.\n     * @dev The sender must have the admin role.\n     * @param _address EOA or contract affected.\n     */\n    function removeAdminRole(address _address) external {\n        revokeRole(DEFAULT_ADMIN_ROLE, _address);\n        emit AdminRoleRemoved(_address, _msgSender());\n    }\n}\ncontract MISOAccessControls is MISOAdminAccess {\n    /// @notice Role definitions\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant SMART_CONTRACT_ROLE = keccak256(\"SMART_CONTRACT_ROLE\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    /// @notice Events for adding and removing various roles\n\n    event MinterRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n\n    event MinterRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n\n    event OperatorRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n\n    event OperatorRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n\n    event SmartContractRoleGranted(\n        address indexed beneficiary,\n        address indexed caller\n    );\n\n    event SmartContractRoleRemoved(\n        address indexed beneficiary,\n        address indexed caller\n    );\n\n    /**\n     * @notice The deployer is automatically given the admin role which will allow them to then grant roles to other addresses\n     */\n    constructor() public {\n    }\n\n\n    /////////////\n    // Lookups //\n    /////////////\n\n    /**\n     * @notice Used to check whether an address has the minter role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasMinterRole(address _address) public view returns (bool) {\n        return hasRole(MINTER_ROLE, _address);\n    }\n\n    /**\n     * @notice Used to check whether an address has the smart contract role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasSmartContractRole(address _address) public view returns (bool) {\n        return hasRole(SMART_CONTRACT_ROLE, _address);\n    }\n\n    /**\n     * @notice Used to check whether an address has the operator role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasOperatorRole(address _address) public view returns (bool) {\n        return hasRole(OPERATOR_ROLE, _address);\n    }\n\n    ///////////////\n    // Modifiers //\n    ///////////////\n\n    /**\n     * @notice Grants the minter role to an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract receiving the new role\n     */\n    function addMinterRole(address _address) external {\n        grantRole(MINTER_ROLE, _address);\n        emit MinterRoleGranted(_address, _msgSender());\n    }\n\n    /**\n     * @notice Removes the minter role from an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract affected\n     */\n    function removeMinterRole(address _address) external {\n        revokeRole(MINTER_ROLE, _address);\n        emit MinterRoleRemoved(_address, _msgSender());\n    }\n\n    /**\n     * @notice Grants the smart contract role to an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract receiving the new role\n     */\n    function addSmartContractRole(address _address) external {\n        grantRole(SMART_CONTRACT_ROLE, _address);\n        emit SmartContractRoleGranted(_address, _msgSender());\n    }\n\n    /**\n     * @notice Removes the smart contract role from an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract affected\n     */\n    function removeSmartContractRole(address _address) external {\n        revokeRole(SMART_CONTRACT_ROLE, _address);\n        emit SmartContractRoleRemoved(_address, _msgSender());\n    }\n\n    /**\n     * @notice Grants the operator role to an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract receiving the new role\n     */\n    function addOperatorRole(address _address) external {\n        grantRole(OPERATOR_ROLE, _address);\n        emit OperatorRoleGranted(_address, _msgSender());\n    }\n\n    /**\n     * @notice Removes the operator role from an address\n     * @dev The sender must have the admin role\n     * @param _address EOA or contract affected\n     */\n    function removeOperatorRole(address _address) external {\n        revokeRole(OPERATOR_ROLE, _address);\n        emit OperatorRoleRemoved(_address, _msgSender());\n    }\n\n}\ncontract SafeTransfer {\n\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Helper function to handle both ETH and ERC20 payments\n    function _safeTokenPayment(\n        address _token,\n        address payable _to,\n        uint256 _amount\n    ) internal {\n        if (address(_token) == ETH_ADDRESS) {\n            _safeTransferETH(_to,_amount );\n        } else {\n            _safeTransfer(_token, _to, _amount);\n        }\n    }\n\n\n    /// @dev Helper function to handle both ETH and ERC20 payments\n    function _tokenPayment(\n        address _token,\n        address payable _to,\n        uint256 _amount\n    ) internal {\n        if (address(_token) == ETH_ADDRESS) {\n            _to.transfer(_amount);\n        } else {\n            _safeTransfer(_token, _to, _amount);\n        }\n    }\n\n\n    /// @dev Transfer helper from UniswapV2 Router\n    function _safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n\n    /**\n     * There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\n     * Im trying to make it a habit to put external calls last (reentrancy)\n     * You can put this in an internal function if you like.\n     */\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory data) =\n            token.call(\n                // 0xa9059cbb = bytes4(keccak256(\"transfer(address,uint256)\"))\n                abi.encodeWithSelector(0xa9059cbb, to, amount)\n            );\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 Transfer failed\n    }\n\n    function _safeTransferFrom(\n        address token,\n        address from,\n        uint256 amount\n    ) internal virtual {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory data) =\n            token.call(\n                // 0x23b872dd = bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\n                abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\n            );\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 TransferFrom failed\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function _safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n\n\n}\ncontract Documents {\n\n    struct Document {\n        uint32 docIndex;    // Store the document name indexes\n        uint64 lastModified; // Timestamp at which document details was last modified\n        string data; // data of the document that exist off-chain\n    }\n\n    // mapping to store the documents details in the document\n    mapping(string => Document) internal _documents;\n    // mapping to store the document name indexes\n    mapping(string => uint32) internal _docIndexes;\n    // Array use to store all the document name present in the contracts\n    string[] _docNames;\n\n    // Document Events\n    event DocumentRemoved(string indexed _name, string _data);\n    event DocumentUpdated(string indexed _name, string _data);\n\n    /**\n     * @notice Used to attach a new document to the contract, or update the data or hash of an existing attached document\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     * @param _data Off-chain data of the document from where it is accessible to investors/advisors to read.\n     */\n    function _setDocument(string calldata _name, string calldata _data) internal {\n        require(bytes(_name).length > 0, \"Zero name is not allowed\");\n        require(bytes(_data).length > 0, \"Should not be a empty data\");\n        // Document storage document = _documents[_name];\n        if (_documents[_name].lastModified == uint64(0)) {\n            _docNames.push(_name);\n            _documents[_name].docIndex = uint32(_docNames.length);\n        }\n        _documents[_name] = Document(_documents[_name].docIndex, uint64(now), _data);\n        emit DocumentUpdated(_name, _data);\n    }\n\n    /**\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     */\n\n    function _removeDocument(string calldata _name) internal {\n        require(_documents[_name].lastModified != uint64(0), \"Document should exist\");\n        uint32 index = _documents[_name].docIndex - 1;\n        if (index != _docNames.length - 1) {\n            _docNames[index] = _docNames[_docNames.length - 1];\n            _documents[_docNames[index]].docIndex = index + 1; \n        }\n        _docNames.pop();\n        emit DocumentRemoved(_name, _documents[_name].data);\n        delete _documents[_name];\n    }\n\n    /**\n     * @notice Used to return the details of a document with a known name (`string`).\n     * @param _name Name of the document\n     * @return string The data associated with the document.\n     * @return uint256 the timestamp at which the document was last modified.\n     */\n    function getDocument(string calldata _name) external view returns (string memory, uint256) {\n        return (\n            _documents[_name].data,\n            uint256(_documents[_name].lastModified)\n        );\n    }\n\n    /**\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\n     * @return string List of all documents names present in the contract.\n     */\n    function getAllDocuments() external view returns (string[] memory) {\n        return _docNames;\n    }\n\n    /**\n     * @notice Used to retrieve the total documents in the smart contract.\n     * @return uint256 Count of the document names present in the contract.\n     */\n    function getDocumentCount() external view returns (uint256) {\n        return _docNames.length;\n    }\n\n    /**\n     * @notice Used to retrieve the document name from index in the smart contract.\n     * @return string Name of the document name.\n     */\n    function getDocumentName(uint256 _index) external view returns (string memory) {\n        require(_index < _docNames.length, \"Index out of bounds\");\n        return _docNames[_index];\n    }\n\n}\ncontract MISOLauncher is SafeTransfer {\n\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n\n    /// @notice Responsible for access rights to the contract.\n    MISOAccessControls public accessControls;\n    bytes32 public constant LAUNCHER_MINTER_ROLE = keccak256(\"LAUNCHER_MINTER_ROLE\");\n\n    /// @notice Whether launcher has been initialized or not.\n    bool private initialised;\n\n    /// @notice Struct to track Auction template.\n    struct Launcher {\n        bool exists;\n        uint64 templateId;\n        uint128 index;\n    }\n\n    /// @notice All the launchers created using factory.\n    address[] public launchers;\n\n    /// @notice Template id to track respective auction template.\n    uint256 public launcherTemplateId;\n\n    /// @notice Address for Wrapped Ether.\n    address public WETH;\n    IBentoBoxFactory public bentoBox;\n\n    /// @notice Mapping from template id to launcher template address.\n    mapping(uint256 => address) private launcherTemplates;\n\n    /// @notice mapping from launcher template address to launcher template id\n    mapping(address => uint256) private launcherTemplateToId;\n\n    // /// @notice mapping from template type to template id\n    mapping(uint256 => uint256) public currentTemplateId;\n\n    /// @notice Mapping from auction created through this contract to Auction struct.\n    mapping(address => Launcher) public launcherInfo;\n\n    /// @notice Struct to define fees.\n    struct LauncherFees {\n        uint128 minimumFee;\n        uint32 integratorFeePct;\n    }\n\n    /// @notice Minimum fee to create a launcher through the factory.\n    LauncherFees public launcherFees;\n\n    /// @notice Contract locked status. If locked, only minters can deploy\n    bool public locked;\n\n    ///@notice Any donations if set are sent here.\n    address payable public misoDiv;\n\n    /// @notice Event emitted when first intializing the liquidity launcher.\n    event MisoInitLauncher(address sender);\n\n    /// @notice Event emitted when launcher is created using template id.\n    event LauncherCreated(address indexed owner, address indexed addr, address launcherTemplate);\n\n    /// @notice Event emitted when launcher template is added to factory.\n    event LauncherTemplateAdded(address newLauncher, uint256 templateId);\n\n    /// @notice Event emitted when launcher template is removed.\n    event LauncherTemplateRemoved(address launcher, uint256 templateId);\n\n    constructor() public {\n    }\n\n    /**\n     * @notice Single gateway to initialize the MISO Launcher with proper address.\n     * @dev Can only be initialized once.\n     * @param _accessControls Sets address to get the access controls from.\n     */\n    function initMISOLauncher(address _accessControls, address _WETH, address _bentoBox) external {\n        require(!initialised);\n        require(_WETH != address(0), \"initMISOLauncher: WETH cannot be set to zero\");\n        require(_accessControls != address(0), \"initMISOLauncher: accessControls cannot be set to zero\");\n        require(_bentoBox != address(0), \"initMISOLauncher: bentoBox cannot be set to zero\");\n\n        accessControls = MISOAccessControls(_accessControls);\n        bentoBox = IBentoBoxFactory(_bentoBox); \n        WETH = _WETH;\n        locked = true;\n        initialised = true;\n\n        emit MisoInitLauncher(msg.sender);\n    }\n\n    /**\n     * @notice Sets the minimum fee.\n     * @param _amount Fee amount.\n     */\n    function setMinimumFee(uint256 _amount) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOLauncher: Sender must be operator\"\n        );\n        launcherFees.minimumFee = BoringMath.to128(_amount);\n    }\n\n    /**\n     * @notice Sets integrator fee percentage.\n     * @param _amount Percentage amount.\n     */\n    function setIntegratorFeePct(uint256 _amount) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOLauncher: Sender must be operator\"\n        );\n        /// @dev this is out of 1000, ie 25% = 250\n        require(_amount <= 1000, \"MISOLauncher: Percentage is out of 1000\");\n        launcherFees.integratorFeePct = BoringMath.to32(_amount);\n    }\n\n    /**\n     * @notice Sets dividend address.\n     * @param _divaddr Dividend address.\n     */\n    function setDividends(address payable _divaddr) external {\n        require(accessControls.hasAdminRole(msg.sender), \"MISOLauncher.setDev: Sender must be operator\");\n        require(_divaddr != address(0));\n        misoDiv = _divaddr;\n    }\n    /**\n     * @notice Sets the factory to be locked or unlocked.\n     * @param _locked bool.\n     */\n    function setLocked(bool _locked) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOLauncher: Sender must be admin\"\n        );\n        locked = _locked;\n    }\n\n    /**\n     * @notice Sets the current template ID for any type.\n     * @param _templateType Type of template.\n     * @param _templateId The ID of the current template for that type\n     */\n    function setCurrentTemplateId(uint256 _templateType, uint256 _templateId) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOLauncher: Sender must be admin\"\n        );\n        currentTemplateId[_templateType] = _templateId;\n    }\n\n    /**\n     * @notice Used to check whether an address has the minter role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasLauncherMinterRole(address _address) public view returns (bool) {\n        return accessControls.hasRole(LAUNCHER_MINTER_ROLE, _address);\n    }\n\n\n\n    /**\n     * @notice Creates a launcher corresponding to _templateId.\n     * @param _templateId Template id of the launcher to create.\n     * @param _integratorFeeAccount Address to pay the fee to.\n     * @return launcher  Launcher address.\n     */\n    function deployLauncher(\n        uint256 _templateId,\n        address payable _integratorFeeAccount\n    )\n        public payable returns (address launcher)\n    {\n        /// @dev If the contract is locked, only admin and minters can deploy. \n        if (locked) {\n            require(accessControls.hasAdminRole(msg.sender) \n                    || accessControls.hasMinterRole(msg.sender)\n                    || hasLauncherMinterRole(msg.sender),\n                \"MISOLauncher: Sender must be minter if locked\"\n            );\n        }\n\n        LauncherFees memory _launcherFees = launcherFees;\n        address launcherTemplate = launcherTemplates[_templateId];\n        require(msg.value >= uint256(_launcherFees.minimumFee), \"MISOLauncher: Failed to transfer minimumFee\");\n        require(launcherTemplate != address(0), \"MISOLauncher: Launcher template doesn't exist\");\n        uint256 integratorFee = 0;\n        uint256 misoFee = msg.value;\n        if (_integratorFeeAccount != address(0) && _integratorFeeAccount != misoDiv) {\n            integratorFee = misoFee * uint256(_launcherFees.integratorFeePct) / 1000;\n            misoFee = misoFee - integratorFee;\n        }\n        /// @dev Deploy using the BentoBox factory. \n        launcher = bentoBox.deploy(launcherTemplate, \"\", false);\n        launcherInfo[address(launcher)] = Launcher(true, BoringMath.to64(_templateId), BoringMath.to128(launchers.length));\n        launchers.push(address(launcher));\n        emit LauncherCreated(msg.sender, address(launcher), launcherTemplates[_templateId]);\n        if (misoFee > 0) {\n            misoDiv.transfer(misoFee);\n        }\n        if (integratorFee > 0) {\n            _integratorFeeAccount.transfer(integratorFee);\n        }\n    }\n\n\n    /**\n     * @notice Creates a new MISOLauncher using _templateId.\n     * @dev Initializes auction with the parameters passed.\n     * @param _templateId Id of the auction template to create.\n     * @param _token The token address to be sold.\n     * @param _tokenSupply Amount of tokens to be sold at market.\n     * @param _integratorFeeAccount Address to send refferal bonus, if set.\n     * @param _data Data to be sent to template on Init.\n     * @return newLauncher Launcher address.\n     */\n    function createLauncher(\n        uint256 _templateId,\n        address _token,\n        uint256 _tokenSupply,\n        address payable _integratorFeeAccount,\n        bytes calldata _data\n    )\n        external payable returns (address newLauncher)\n    {\n\n        newLauncher = deployLauncher(_templateId, _integratorFeeAccount);\n        if (_tokenSupply > 0) {\n            _safeTransferFrom(_token, msg.sender, _tokenSupply);\n            require(IERC20(_token).approve(newLauncher, _tokenSupply), \"1\");\n        }\n        IMisoLiquidity(newLauncher).initLauncher(_data);\n\n        if (_tokenSupply > 0) {\n            uint256 remainingBalance = IERC20(_token).balanceOf(address(this));\n            if (remainingBalance > 0) {\n                _safeTransfer(_token, msg.sender, remainingBalance);\n            }\n        }\n        return newLauncher;\n    }\n\n\n    /**\n     * @notice Function to add a launcher template to create through factory.\n     * @dev Should have operator access\n     * @param _template Launcher template address.\n    */\n    function addLiquidityLauncherTemplate(address _template) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOLauncher: Sender must be operator\"\n        );\n        uint256 templateType = IMisoLiquidity(_template).liquidityTemplate();\n        require(templateType > 0, \"MISOLauncher: Incorrect template code \");\n        launcherTemplateId++;\n\n        launcherTemplates[launcherTemplateId] = _template;\n        launcherTemplateToId[_template] = launcherTemplateId;\n        currentTemplateId[templateType] = launcherTemplateId;\n        emit LauncherTemplateAdded(_template, launcherTemplateId);\n\n    }\n\n    /**\n     * @dev Function to remove a launcher template from factory.\n     * @dev Should have operator access.\n     * @param _templateId Id of the template to be deleted.\n     */\n    function removeLiquidityLauncherTemplate(uint256 _templateId) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOLauncher: Sender must be operator\"\n        );\n        require(launcherTemplates[_templateId] != address(0));\n        address _template = launcherTemplates[_templateId];\n        launcherTemplates[_templateId] = address(0);\n        delete launcherTemplateToId[_template];\n        emit LauncherTemplateRemoved(_template, _templateId);\n    }\n\n    /**\n     * @notice Get the address based on launcher template ID.\n     * @param _templateId Launcher template ID.\n     * @return address of the required template ID.\n     */\n    function getLiquidityLauncherTemplate(uint256 _templateId) external view returns (address) {\n        return launcherTemplates[_templateId];\n    }\n\n    function getTemplateId(address _launcherTemplate) external view returns (uint256) {\n        return launcherTemplateToId[_launcherTemplate];\n    }\n\n    /**\n     * @notice Get the total number of launchers in the contract.\n     * @return uint256 Launcher count.\n     */\n    function numberOfLiquidityLauncherContracts() external view returns (uint256) {\n        return launchers.length;\n    }\n\n    function minimumFee() external view returns(uint128) {\n        return launcherFees.minimumFee;\n    }\n\n    function getLauncherTemplateId(address _launcher) external view returns(uint64) {\n        return launcherInfo[_launcher].templateId;\n    }\n    function getLaunchers() external view returns(address[] memory) {\n        return launchers;\n    }\n\n\n}\ncontract BoringBatchable is BaseBoringBatchable {\n    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\n    /// Lookup `IERC20.permit`.\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\n    function permitToken(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        token.permit(from, to, amount, deadline, v, r, s);\n    }\n}contract MISOMarket is SafeTransfer {\n\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n\n    /// @notice Responsible for access rights to the contract.\n    MISOAccessControls public accessControls;\n    bytes32 public constant MARKET_MINTER_ROLE = keccak256(\"MARKET_MINTER_ROLE\");\n\n    /// @notice Whether market has been initialized or not.\n    bool private initialised;\n\n    /// @notice Struct to track Auction template.\n    struct Auction {\n        bool exists;\n        uint64 templateId;\n        uint128 index;\n    }\n\n    /// @notice Auctions created using factory.\n    address[] public auctions;\n\n    /// @notice Template id to track respective auction template.\n    uint256 public auctionTemplateId;\n\n    IBentoBoxFactory public bentoBox;\n\n    /// @notice Mapping from market template id to market template address.\n    mapping(uint256 => address) private auctionTemplates;\n\n    /// @notice Mapping from market template address to market template id.\n    mapping(address => uint256) private auctionTemplateToId;\n\n    // /// @notice mapping from template type to template id\n    mapping(uint256 => uint256) public currentTemplateId;\n\n    /// @notice Mapping from auction created through this contract to Auction struct.\n    mapping(address => Auction) public auctionInfo;\n\n    /// @notice Struct to define fees.\n    struct MarketFees {\n        uint128 minimumFee;\n        uint32 integratorFeePct;\n    }\n\n    /// @notice Minimum fee to create a farm through the factory.\n    MarketFees public marketFees;\n\n    /// @notice Contract locked status. If locked, only minters can deploy\n    bool public locked;\n\n    ///@notice Any donations if set are sent here.\n    address payable public misoDiv;\n\n    ///@notice Event emitted when first initializing the Market factory.\n    event MisoInitMarket(address sender);\n\n    /// @notice Event emitted when template is added to factory.\n    event AuctionTemplateAdded(address newAuction, uint256 templateId);\n\n    /// @notice Event emitted when auction template is removed.\n    event AuctionTemplateRemoved(address auction, uint256 templateId);\n\n    /// @notice Event emitted when auction is created using template id.\n    event MarketCreated(address indexed owner, address indexed addr, address marketTemplate);\n\n    constructor() public {\n    }\n\n    /**\n     * @notice Initializes the market with a list of auction templates.\n     * @dev Can only be initialized once.\n     * @param _accessControls Sets address to get the access controls from.\n     * @param _templates Initial array of MISOMarket templates.\n     */\n    function initMISOMarket(address _accessControls, address _bentoBox, address[] memory _templates) external {\n        require(!initialised);\n        require(_accessControls != address(0), \"initMISOMarket: accessControls cannot be set to zero\");\n        require(_bentoBox != address(0), \"initMISOMarket: bentoBox cannot be set to zero\");\n\n        accessControls = MISOAccessControls(_accessControls);\n        bentoBox = IBentoBoxFactory(_bentoBox);\n\n        auctionTemplateId = 0;\n        for(uint i = 0; i < _templates.length; i++) {\n            _addAuctionTemplate(_templates[i]);\n        }\n        locked = true;\n        initialised = true;\n        emit MisoInitMarket(msg.sender);\n    }\n\n    /**\n     * @notice Sets the minimum fee.\n     * @param _amount Fee amount.\n     */\n    function setMinimumFee(uint256 _amount) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        marketFees.minimumFee = BoringMath.to128(_amount);\n    }\n\n    /**\n     * @notice Sets the factory to be locked or unlocked.\n     * @param _locked bool.\n     */\n    function setLocked(bool _locked) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be admin\"\n        );\n        locked = _locked;\n    }\n\n\n    /**\n     * @notice Sets integrator fee percentage.\n     * @param _amount Percentage amount.\n     */\n    function setIntegratorFeePct(uint256 _amount) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        /// @dev this is out of 1000, ie 25% = 250\n        require(_amount <= 1000, \"MISOMarket: Percentage is out of 1000\");\n        marketFees.integratorFeePct = BoringMath.to32(_amount);\n    }\n\n    /**\n     * @notice Sets dividend address.\n     * @param _divaddr Dividend address.\n     */\n    function setDividends(address payable _divaddr) external {\n        require(accessControls.hasAdminRole(msg.sender), \"MISOMarket.setDev: Sender must be operator\");\n        require(_divaddr != address(0));\n        misoDiv = _divaddr;\n    }\n\n    /**\n     * @notice Sets the current template ID for any type.\n     * @param _templateType Type of template.\n     * @param _templateId The ID of the current template for that type\n     */\n    function setCurrentTemplateId(uint256 _templateType, uint256 _templateId) external {\n        require(\n            accessControls.hasAdminRole(msg.sender),\n            \"MISOMarket: Sender must be admin\"\n        );\n        require(auctionTemplates[_templateId] != address(0), \"MISOMarket: incorrect _templateId\");\n        require(IMisoMarket(auctionTemplates[_templateId]).marketTemplate() == _templateType, \"MISOMarket: incorrect _templateType\");\n        currentTemplateId[_templateType] = _templateId;\n    }\n\n\n    /**\n     * @notice Used to check whether an address has the minter role\n     * @param _address EOA or contract being checked\n     * @return bool True if the account has the role or false if it does not\n     */\n    function hasMarketMinterRole(address _address) public view returns (bool) {\n        return accessControls.hasRole(MARKET_MINTER_ROLE, _address);\n    }\n\n\n    /**\n     * @notice Creates a new MISOMarket from template _templateId and transfers fees.\n     * @param _templateId Id of the crowdsale template to create.\n     * @param _integratorFeeAccount Address to pay the fee to.\n     * @return newMarket Market address.\n     */\n    function deployMarket(\n        uint256 _templateId,\n        address payable _integratorFeeAccount\n    )\n        public payable returns (address newMarket)\n    {\n        /// @dev If the contract is locked, only admin and minters can deploy. \n        if (locked) {\n            require(accessControls.hasAdminRole(msg.sender) \n                    || accessControls.hasMinterRole(msg.sender)\n                    || hasMarketMinterRole(msg.sender),\n                \"MISOMarket: Sender must be minter if locked\"\n            );\n        }\n\n        MarketFees memory _marketFees = marketFees;\n        address auctionTemplate = auctionTemplates[_templateId];\n        require(msg.value >= uint256(_marketFees.minimumFee), \"MISOMarket: Failed to transfer minimumFee\");\n        require(auctionTemplate != address(0), \"MISOMarket: Auction template doesn't exist\");\n        uint256 integratorFee = 0;\n        uint256 misoFee = msg.value;\n        if (_integratorFeeAccount != address(0) && _integratorFeeAccount != misoDiv) {\n            integratorFee = misoFee * uint256(_marketFees.integratorFeePct) / 1000;\n            misoFee = misoFee - integratorFee;\n        }\n\n        /// @dev Deploy using the BentoBox factory. \n        newMarket = bentoBox.deploy(auctionTemplate, \"\", false);\n        auctionInfo[newMarket] = Auction(true, BoringMath.to64(_templateId), BoringMath.to128(auctions.length));\n        auctions.push(newMarket);\n        emit MarketCreated(msg.sender, newMarket, auctionTemplate);\n        if (misoFee > 0) {\n            misoDiv.transfer(misoFee);\n        }\n        if (integratorFee > 0) {\n            _integratorFeeAccount.transfer(integratorFee);\n        }\n    }\n\n    /**\n     * @notice Creates a new MISOMarket using _templateId.\n     * @dev Initializes auction with the parameters passed.\n     * @param _templateId Id of the auction template to create.\n     * @param _token The token address to be sold.\n     * @param _tokenSupply Amount of tokens to be sold at market.\n     * @param _integratorFeeAccount Address to send refferal bonus, if set.\n     * @param _data Data to be sent to template on Init.\n     * @return newMarket Market address.\n     */\n    function createMarket(\n        uint256 _templateId,\n        address _token,\n        uint256 _tokenSupply,\n        address payable _integratorFeeAccount,\n        bytes calldata _data\n    )\n        external payable returns (address newMarket)\n    {\n        newMarket = deployMarket(_templateId, _integratorFeeAccount);\n        if (_tokenSupply > 0) {\n            _safeTransferFrom(_token, msg.sender, _tokenSupply);\n            require(IERC20(_token).approve(newMarket, _tokenSupply), \"1\");\n        }\n        IMisoMarket(newMarket).initMarket(_data);\n\n        if (_tokenSupply > 0) {\n            uint256 remainingBalance = IERC20(_token).balanceOf(address(this));\n            if (remainingBalance > 0) {\n                _safeTransfer(_token, msg.sender, remainingBalance);\n            }\n        }\n        return newMarket;\n    }\n\n    /**\n     * @notice Function to add an auction template to create through factory.\n     * @dev Should have operator access.\n     * @param _template Auction template to create an auction.\n     */\n    function addAuctionTemplate(address _template) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        _addAuctionTemplate(_template);    \n    }\n\n    /**\n     * @dev Function to remove an auction template.\n     * @dev Should have operator access.\n     * @param _templateId Refers to template that is to be deleted.\n     */\n    function removeAuctionTemplate(uint256 _templateId) external {\n        require(\n            accessControls.hasAdminRole(msg.sender) ||\n            accessControls.hasOperatorRole(msg.sender),\n            \"MISOMarket: Sender must be operator\"\n        );\n        address template = auctionTemplates[_templateId];\n        uint256 templateType = IMisoMarket(template).marketTemplate();\n        if (currentTemplateId[templateType] == _templateId) {\n            delete currentTemplateId[templateType];\n        }   \n        auctionTemplates[_templateId] = address(0);\n        delete auctionTemplateToId[template];\n        emit AuctionTemplateRemoved(template, _templateId);\n    }\n\n    /**\n     * @notice Function to add an auction template to create through factory.\n     * @param _template Auction template address to create an auction.\n     */\n    function _addAuctionTemplate(address _template) internal {\n        require(_template != address(0), \"MISOMarket: Incorrect template\");\n        require(auctionTemplateToId[_template] == 0, \"MISOMarket: Template already added\");\n        uint256 templateType = IMisoMarket(_template).marketTemplate();\n        require(templateType > 0, \"MISOMarket: Incorrect template code \");\n        auctionTemplateId++;\n\n        auctionTemplates[auctionTemplateId] = _template;\n        auctionTemplateToId[_template] = auctionTemplateId;\n        currentTemplateId[templateType] = auctionTemplateId;\n        emit AuctionTemplateAdded(_template, auctionTemplateId);\n    }\n\n    /**\n     * @notice Get the address based on template ID.\n     * @param _templateId Auction template ID.\n     * @return Address of the required template ID.\n     */\n    function getAuctionTemplate(uint256 _templateId) external view returns (address) {\n        return auctionTemplates[_templateId];\n    }\n\n    /**\n     * @notice Get the ID based on template address.\n     * @param _auctionTemplate Auction template address.\n     * @return ID of the required template address.\n     */\n    function getTemplateId(address _auctionTemplate) external view returns (uint256) {\n        return auctionTemplateToId[_auctionTemplate];\n    }\n\n    /**\n     * @notice Get the total number of auctions in the factory.\n     * @return Auction count.\n     */\n    function numberOfAuctions() external view returns (uint) {\n        return auctions.length;\n    }\n\n    function minimumFee() external view returns(uint128) {\n        return marketFees.minimumFee;\n    }\n\n    function getMarkets() external view returns(address[] memory) {\n        return auctions;\n    }\n\n    function getMarketTemplateId(address _auction) external view returns(uint64) {\n        return auctionInfo[_auction].templateId;\n    }\n}\ncontract BatchAuction is  IMisoMarket, MISOAccessControls, BoringBatchable, SafeTransfer, Documents, ReentrancyGuard  {\n\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n    using BoringERC20 for IERC20;\n\n    /// @notice MISOMarket template id for the factory contract.\n    /// @dev For different marketplace types, this must be incremented.\n    uint256 public constant override marketTemplate = 3;\n\n    /// @dev The placeholder ETH address.\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Main market variables.\n    struct MarketInfo {\n        uint64 startTime;\n        uint64 endTime; \n        uint128 totalTokens;\n    }\n    MarketInfo public marketInfo;\n\n    /// @notice Market dynamic variables.\n    struct MarketStatus {\n        uint128 commitmentsTotal;\n        uint128 minimumCommitmentAmount;\n        bool finalized;\n        bool usePointList;\n    }\n\n    MarketStatus public marketStatus;\n\n    address public auctionToken;\n    /// @notice The currency the crowdsale accepts for payment. Can be ETH or token address.\n    address public paymentCurrency;\n    /// @notice Address that manages auction approvals.\n    address public pointList;\n    address payable public wallet; // Where the auction funds will get paid\n\n    mapping(address => uint256) public commitments;\n    /// @notice Amount of tokens to claim per address.\n    mapping(address => uint256) public claimed;\n\n    /// @notice Event for updating auction times.  Needs to be before auction starts.\n    event AuctionTimeUpdated(uint256 startTime, uint256 endTime); \n    /// @notice Event for updating auction prices. Needs to be before auction starts.\n    event AuctionPriceUpdated(uint256 minimumCommitmentAmount); \n    /// @notice Event for updating auction wallet. Needs to be before auction starts.\n    event AuctionWalletUpdated(address wallet); \n\n    /// @notice Event for adding a commitment.\n    event AddedCommitment(address addr, uint256 commitment);\n    /// @notice Event for finalization of the auction.\n    event AuctionFinalized();\n    /// @notice Event for cancellation of the auction.\n    event AuctionCancelled();\n\n    /**\n     * @notice Initializes main contract variables and transfers funds for the auction.\n     * @dev Init function.\n     * @param _funder The address that funds the token for crowdsale.\n     * @param _token Address of the token being sold.\n     * @param _totalTokens The total number of tokens to sell in auction.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.\n     * @param _minimumCommitmentAmount Minimum amount collected at which the auction will be successful.\n     * @param _admin Address that can finalize auction.\n     * @param _wallet Address where collected funds will be forwarded to.\n     */\n    function initAuction(\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _minimumCommitmentAmount,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    ) public {\n        require(_startTime < 10000000000, \"BatchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_endTime < 10000000000, \"BatchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"BatchAuction: start time is before current time\");\n        require(_endTime > _startTime, \"BatchAuction: end time must be older than start time\");\n        require(_totalTokens > 0,\"BatchAuction: total tokens must be greater than zero\");\n        require(_admin != address(0), \"BatchAuction: admin is the zero address\");\n        require(_wallet != address(0), \"BatchAuction: wallet is the zero address\");\n        require(IERC20(_token).decimals() == 18, \"BatchAuction: Token does not have 18 decimals\");\n        if (_paymentCurrency != ETH_ADDRESS) {\n            require(IERC20(_paymentCurrency).decimals() > 0, \"BatchAuction: Payment currency is not ERC20\");\n        }\n\n        marketStatus.minimumCommitmentAmount = BoringMath.to128(_minimumCommitmentAmount);\n        \n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        marketInfo.totalTokens = BoringMath.to128(_totalTokens);\n\n        auctionToken = _token;\n        paymentCurrency = _paymentCurrency;\n        wallet = _wallet;\n\n        initAccessControls(_admin);\n\n        _setList(_pointList);\n        _safeTransferFrom(auctionToken, _funder, _totalTokens);\n    }\n\n\n    ///--------------------------------------------------------\n    /// Commit to buying tokens!\n    ///--------------------------------------------------------\n\n    receive() external payable {\n        revertBecauseUserDidNotProvideAgreement();\n    }\n    \n    /** \n     * @dev Attribution to the awesome delta.financial contracts\n    */  \n    function marketParticipationAgreement() public pure returns (string memory) {\n        return \"I understand that I am interacting with a smart contract. I understand that tokens commited are subject to the token issuer and local laws where applicable. I have reviewed the code of this smart contract and understand it fully. I agree to not hold developers or other people associated with the project liable for any losses or misunderstandings\";\n    }\n    /** \n     * @dev Not using modifiers is a purposeful choice for code readability.\n    */ \n    function revertBecauseUserDidNotProvideAgreement() internal pure {\n        revert(\"No agreement provided, please review the smart contract before interacting with it\");\n    }\n\n    /**\n     * @notice Commit ETH to buy tokens on auction.\n     * @param _beneficiary Auction participant ETH address.\n     */\n    function commitEth(address payable _beneficiary, bool readAndAgreedToMarketParticipationAgreement) public payable {\n        require(paymentCurrency == ETH_ADDRESS, \"BatchAuction: payment currency is not ETH\");\n\n        require(msg.value > 0, \"BatchAuction: Value must be higher than 0\");\n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n        _addCommitment(_beneficiary, msg.value);\n\n        /// @notice Revert if commitmentsTotal exceeds the balance\n        require(marketStatus.commitmentsTotal <= address(this).balance, \"DutchAuction: The committed ETH exceeds the balance\");\n    }\n\n    /**\n     * @notice Buy Tokens by commiting approved ERC20 tokens to this contract address.\n     * @param _amount Amount of tokens to commit.\n     */\n    function commitTokens(uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public {\n        commitTokensFrom(msg.sender, _amount, readAndAgreedToMarketParticipationAgreement);\n    }\n\n    /**\n     * @notice Checks if amout not 0 and makes the transfer and adds commitment.\n     * @dev Users must approve contract prior to committing tokens to auction.\n     * @param _from User ERC20 address.\n     * @param _amount Amount of approved ERC20 tokens.\n     */\n    function commitTokensFrom(address _from, uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public   nonReentrant  {\n        require(paymentCurrency != ETH_ADDRESS, \"BatchAuction: Payment currency is not a token\");\n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n        require(_amount> 0, \"BatchAuction: Value must be higher than 0\");\n        _safeTransferFrom(paymentCurrency, msg.sender, _amount);\n        _addCommitment(_from, _amount);\n\n    }\n\n\n    /// @notice Commits to an amount during an auction\n    /**\n     * @notice Updates commitment for this address and total commitment of the auction.\n     * @param _addr Auction participant address.\n     * @param _commitment The amount to commit.\n     */\n    function _addCommitment(address _addr, uint256 _commitment) internal {\n        require(block.timestamp >= marketInfo.startTime && block.timestamp <= marketInfo.endTime, \"BatchAuction: outside auction hours\"); \n\n        uint256 newCommitment = commitments[_addr].add(_commitment);\n        if (marketStatus.usePointList) {\n            require(IPointList(pointList).hasPoints(_addr, newCommitment));\n        }\n        commitments[_addr] = newCommitment;\n        marketStatus.commitmentsTotal = BoringMath.to128(uint256(marketStatus.commitmentsTotal).add(_commitment));\n        emit AddedCommitment(_addr, _commitment);\n    }\n\n    /**\n     * @notice Calculates amount of auction tokens for user to receive.\n     * @param amount Amount of tokens to commit.\n     * @return Auction token amount.\n     */\n    function _getTokenAmount(uint256 amount) internal view returns (uint256) { \n        if (marketStatus.commitmentsTotal == 0) return 0;\n        return amount.mul(1e18).div(tokenPrice());\n    }\n\n    /**\n     * @notice Calculates the price of each token from all commitments.\n     * @return Token price.\n     */\n    function tokenPrice() public view returns (uint256) {\n        return uint256(marketStatus.commitmentsTotal)\n            .mul(1e18).div(uint256(marketInfo.totalTokens));\n    }\n\n\n    ///--------------------------------------------------------\n    /// Finalize Auction\n    ///--------------------------------------------------------\n\n    /// @notice Auction finishes successfully above the reserve\n    /// @dev Transfer contract funds to initialized wallet.\n    function finalize() public    nonReentrant \n    {\n        require(hasAdminRole(msg.sender) \n                || wallet == msg.sender\n                || hasSmartContractRole(msg.sender) \n                || finalizeTimeExpired(),  \"BatchAuction: Sender must be admin\");\n        require(!marketStatus.finalized, \"BatchAuction: Auction has already finalized\");\n        require(block.timestamp > marketInfo.endTime, \"BatchAuction: Auction has not finished yet\");\n        if (auctionSuccessful()) {\n            /// @dev Successful auction\n            /// @dev Transfer contributed tokens to wallet.\n            _safeTokenPayment(paymentCurrency, wallet, uint256(marketStatus.commitmentsTotal));\n        } else {\n            /// @dev Failed auction\n            /// @dev Return auction tokens back to wallet.\n            _safeTokenPayment(auctionToken, wallet, marketInfo.totalTokens);\n        }\n        marketStatus.finalized = true;\n        emit AuctionFinalized();\n    }\n\n    /**\n     * @notice Cancel Auction\n     * @dev Admin can cancel the auction before it starts\n     */\n    function cancelAuction() public   nonReentrant  \n    {\n        require(hasAdminRole(msg.sender));\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"Crowdsale: already finalized\");\n        require( uint256(status.commitmentsTotal) == 0, \"Crowdsale: Funds already raised\" );\n\n        _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));\n\n        status.finalized = true;\n        emit AuctionCancelled();\n    }\n\n    /// @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.\n    function withdrawTokens() public  {\n        withdrawTokens(msg.sender);\n    }\n\n    /// @notice Withdraw your tokens once the Auction has ended.\n    function withdrawTokens(address payable beneficiary) public   nonReentrant  {\n        if (auctionSuccessful()) {\n            require(marketStatus.finalized, \"BatchAuction: not finalized\");\n            /// @dev Successful auction! Transfer claimed tokens.\n            uint256 tokensToClaim = tokensClaimable(beneficiary);\n            require(tokensToClaim > 0, \"BatchAuction: No tokens to claim\");\n            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);\n\n            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);\n        } else {\n            /// @dev Auction did not meet reserve price.\n            /// @dev Return committed funds back to user.\n            require(block.timestamp > marketInfo.endTime, \"BatchAuction: Auction has not finished yet\");\n            uint256 fundsCommitted = commitments[beneficiary];\n            require(fundsCommitted > 0, \"BatchAuction: No funds committed\");\n            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas\n            _safeTokenPayment(paymentCurrency, beneficiary, fundsCommitted);\n        }\n    }\n\n\n    /**\n     * @notice How many tokens the user is able to claim.\n     * @param _user Auction participant address.\n     * @return  claimerCommitment Tokens left to claim.\n     */\n    function tokensClaimable(address _user) public view returns (uint256 claimerCommitment) {\n        if (commitments[_user] == 0) return 0;\n        uint256 unclaimedTokens = IERC20(auctionToken).balanceOf(address(this));\n        claimerCommitment = _getTokenAmount(commitments[_user]);\n        claimerCommitment = claimerCommitment.sub(claimed[_user]);\n\n        if(claimerCommitment > unclaimedTokens){\n            claimerCommitment = unclaimedTokens;\n        }\n    }\n    \n    /**\n     * @notice Checks if raised more than minimum amount.\n     * @return True if tokens sold greater than or equals to the minimum commitment amount.\n     */\n    function auctionSuccessful() public view returns (bool) {\n        return uint256(marketStatus.commitmentsTotal) >= uint256(marketStatus.minimumCommitmentAmount) && uint256(marketStatus.commitmentsTotal) > 0;\n    }\n\n    /**\n     * @notice Checks if the auction has ended.\n     * @return bool True if current time is greater than auction end time.\n     */\n    function auctionEnded() public view returns (bool) {\n        return block.timestamp > marketInfo.endTime;\n    }\n\n    /**\n     * @notice Checks if the auction has been finalised.\n     * @return bool True if auction has been finalised.\n     */\n    function finalized() public view returns (bool) {\n        return marketStatus.finalized;\n    }\n\n    /// @notice Returns true if 7 days have passed since the end of the auction\n    function finalizeTimeExpired() public view returns (bool) {\n        return uint256(marketInfo.endTime) + 7 days < block.timestamp;\n    }\n\n\n    //--------------------------------------------------------\n    // Documents\n    //--------------------------------------------------------\n\n    function setDocument(string calldata _name, string calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        _setDocument( _name, _data);\n    }\n\n    function setDocuments(string[] calldata _name, string[] calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        uint256 numDocs = _name.length;\n        for (uint256 i = 0; i < numDocs; i++) {\n            _setDocument( _name[i], _data[i]);\n        }\n    }\n\n    function removeDocument(string calldata _name) external {\n        require(hasAdminRole(msg.sender));\n        _removeDocument(_name);\n    }\n\n\n    //--------------------------------------------------------\n    // Point Lists\n    //--------------------------------------------------------\n\n\n    function setList(address _list) external {\n        require(hasAdminRole(msg.sender));\n        _setList(_list);\n    }\n\n    function enableList(bool _status) external {\n        require(hasAdminRole(msg.sender));\n        marketStatus.usePointList = _status;\n    }\n\n    function _setList(address _pointList) private {\n        if (_pointList != address(0)) {\n            pointList = _pointList;\n            marketStatus.usePointList = true;\n        }\n    }\n\n    //--------------------------------------------------------\n    // Setter Functions\n    //--------------------------------------------------------\n\n    /**\n     * @notice Admin can set start and end time through this function.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     */\n    function setAuctionTime(uint256 _startTime, uint256 _endTime) external {\n        require(hasAdminRole(msg.sender));\n        require(_startTime < 10000000000, \"BatchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_endTime < 10000000000, \"BatchAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"BatchAuction: start time is before current time\");\n        require(_endTime > _startTime, \"BatchAuction: end time must be older than start price\");\n\n        require(marketStatus.commitmentsTotal == 0, \"BatchAuction: auction cannot have already started\");\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        \n        emit AuctionTimeUpdated(_startTime,_endTime);\n    }\n\n    /**\n     * @notice Admin can set start and min price through this function.\n     * @param _minimumCommitmentAmount Auction minimum raised target.\n     */\n    function setAuctionPrice(uint256 _minimumCommitmentAmount) external {\n        require(hasAdminRole(msg.sender));\n\n        require(marketStatus.commitmentsTotal == 0, \"BatchAuction: auction cannot have already started\");\n\n        marketStatus.minimumCommitmentAmount = BoringMath.to128(_minimumCommitmentAmount);\n\n        emit AuctionPriceUpdated(_minimumCommitmentAmount);\n    }\n\n    /**\n     * @notice Admin can set the auction wallet through this function.\n     * @param _wallet Auction wallet is where funds will be sent.\n     */\n    function setAuctionWallet(address payable _wallet) external {\n        require(hasAdminRole(msg.sender));\n        require(_wallet != address(0), \"BatchAuction: wallet is the zero address\");\n\n        wallet = _wallet;\n\n        emit AuctionWalletUpdated(_wallet);\n    }\n\n\n    //--------------------------------------------------------\n    // Market Launchers\n    //--------------------------------------------------------\n\n    function init(bytes calldata _data) external override payable {\n    }\n\n    function initMarket(\n        bytes calldata _data\n    ) public override {\n        (\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _minimumCommitmentAmount,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n        ) = abi.decode(_data, (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            address,\n            address,\n            address\n        ));\n        initAuction(_funder, _token, _totalTokens, _startTime, _endTime, _paymentCurrency, _minimumCommitmentAmount, _admin, _pointList,  _wallet);\n    }\n\n     function getBatchAuctionInitData(\n       address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _minimumCommitmentAmount,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    )\n        external\n        pure\n        returns (bytes memory _data)\n    {\n        return abi.encode(\n            _funder,\n            _token,\n            _totalTokens,\n            _startTime,\n            _endTime,\n            _paymentCurrency,\n            _minimumCommitmentAmount,\n            _admin,\n            _pointList,\n            _wallet\n            );\n    }\n\n    function getBaseInformation() external view returns(\n        address token, \n        uint64 startTime,\n        uint64 endTime,\n        bool marketFinalized\n    ) {\n        return (auctionToken, marketInfo.startTime, marketInfo.endTime, marketStatus.finalized);\n    }\n\n    function getTotalTokens() external view returns(uint256) {\n        return uint256(marketInfo.totalTokens);\n    }\n\n}\ncontract Crowdsale is IMisoMarket, MISOAccessControls, BoringBatchable, SafeTransfer, Documents , ReentrancyGuard  {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n    using BoringERC20 for IERC20;\n\n    /// @notice MISOMarket template id for the factory contract.\n    /// @dev For different marketplace types, this must be incremented.\n    uint256 public constant override marketTemplate = 1;\n\n    /// @notice The placeholder ETH address.\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The decimals of the auction token.\n    uint256 private constant AUCTION_TOKEN_DECIMALS = 1e18;\n\n    /** \n    * @notice rate - How many token units a buyer gets per token or wei.\n    * The rate is the conversion between wei and the smallest and indivisible token unit.\n    * So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\n    * 1 wei will give you 1 unit, or 0.001 TOK.\n    */\n    /// @notice goal - Minimum amount of funds to be raised in weis or tokens.\n    struct MarketPrice {\n        uint128 rate;\n        uint128 goal; \n    }\n    MarketPrice public marketPrice;\n\n    /// @notice Starting time of crowdsale.\n    /// @notice Ending time of crowdsale.\n    /// @notice Total number of tokens to sell.\n    struct MarketInfo {\n        uint64 startTime;\n        uint64 endTime; \n        uint128 totalTokens;\n    }\n    MarketInfo public marketInfo;\n\n    /// @notice Amount of wei raised.\n    /// @notice Whether crowdsale has been initialized or not.\n    /// @notice Whether crowdsale has been finalized or not.\n    struct MarketStatus {\n        uint128 commitmentsTotal;\n        bool finalized;\n        bool usePointList;\n    }\n    MarketStatus public marketStatus;\n\n    /// @notice The token being sold.\n    address public auctionToken;\n    /// @notice Address where funds are collected.\n    address payable public wallet;\n    /// @notice The currency the crowdsale accepts for payment. Can be ETH or token address.\n    address public paymentCurrency;\n    /// @notice Address that manages auction approvals.\n    address public pointList;\n\n    /// @notice The commited amount of accounts.\n    mapping(address => uint256) public commitments;\n    /// @notice Amount of tokens to claim per address.\n    mapping(address => uint256) public claimed;\n\n    /// @notice Event for updating auction times.  Needs to be before auction starts.\n    event AuctionTimeUpdated(uint256 startTime, uint256 endTime); \n    /// @notice Event for updating auction prices. Needs to be before auction starts.\n    event AuctionPriceUpdated(uint256 rate, uint256 goal); \n    /// @notice Event for updating auction wallet. Needs to be before auction starts.\n    event AuctionWalletUpdated(address wallet); \n\n    /// @notice Event for adding a commitment.\n    event AddedCommitment(address addr, uint256 commitment);\n    \n    /// @notice Event for finalization of the crowdsale\n    event AuctionFinalized();\n    /// @notice Event for cancellation of the auction.\n    event AuctionCancelled();\n\n    /**\n     * @notice Initializes main contract variables and transfers funds for the sale.\n     * @dev Init function.\n     * @param _funder The address that funds the token for crowdsale.\n     * @param _token Address of the token being sold.\n     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.\n     * @param _totalTokens The total number of tokens to sell in crowdsale.\n     * @param _startTime Crowdsale start time.\n     * @param _endTime Crowdsale end time.\n     * @param _rate Number of token units a buyer gets per wei or token.\n     * @param _goal Minimum amount of funds to be raised in weis or tokens.\n     * @param _admin Address that can finalize auction.\n     * @param _pointList Address that will manage auction approvals.\n     * @param _wallet Address where collected funds will be forwarded to.\n     */\n    function initCrowdsale(\n        address _funder,\n        address _token,\n        address _paymentCurrency,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _rate,\n        uint256 _goal,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    ) public {\n        require(_startTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");\n        require(_endTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"Crowdsale: start time is before current time\");\n        require(_endTime > _startTime, \"Crowdsale: start time is not before end time\");\n        require(_rate > 0, \"Crowdsale: rate is 0\");\n        require(_wallet != address(0), \"Crowdsale: wallet is the zero address\");\n        require(_admin != address(0), \"Crowdsale: admin is the zero address\");\n        require(_totalTokens > 0, \"Crowdsale: total tokens is 0\");\n        require(_goal > 0, \"Crowdsale: goal is 0\");\n        require(IERC20(_token).decimals() == 18, \"Crowdsale: Token does not have 18 decimals\");\n        if (_paymentCurrency != ETH_ADDRESS) {\n            require(IERC20(_paymentCurrency).decimals() > 0, \"Crowdsale: Payment currency is not ERC20\");\n        }\n\n        marketPrice.rate = BoringMath.to128(_rate);\n        marketPrice.goal = BoringMath.to128(_goal);\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        marketInfo.totalTokens = BoringMath.to128(_totalTokens);\n\n        auctionToken = _token;\n        paymentCurrency = _paymentCurrency;\n        wallet = _wallet;\n\n        initAccessControls(_admin);\n\n        _setList(_pointList);\n        \n        require(_getTokenAmount(_goal) <= _totalTokens, \"Crowdsale: goal should be equal to or lower than total tokens\");\n\n        _safeTransferFrom(_token, _funder, _totalTokens);\n    }\n\n\n    ///--------------------------------------------------------\n    /// Commit to buying tokens!\n    ///--------------------------------------------------------\n\n    receive() external payable {\n        revertBecauseUserDidNotProvideAgreement();\n    }\n\n    /** \n     * @dev Attribution to the awesome delta.financial contracts\n    */  \n    function marketParticipationAgreement() public pure returns (string memory) {\n        return \"I understand that I am interacting with a smart contract. I understand that tokens commited are subject to the token issuer and local laws where applicable. I reviewed code of the smart contract and understand it fully. I agree to not hold developers or other people associated with the project liable for any losses or misunderstandings\";\n    }\n    /** \n     * @dev Not using modifiers is a purposeful choice for code readability.\n    */ \n    function revertBecauseUserDidNotProvideAgreement() internal pure {\n        revert(\"No agreement provided, please review the smart contract before interacting with it\");\n    }\n\n    /**\n     * @notice Checks the amount of ETH to commit and adds the commitment. Refunds the buyer if commit is too high.\n     * @dev low level token purchase with ETH ***DO NOT OVERRIDE***\n     * This function has a non-reentrancy guard, so it should not be called by\n     * another `nonReentrant` function.\n     * @param _beneficiary Recipient of the token purchase.\n     */\n    function commitEth(\n        address payable _beneficiary,\n        bool readAndAgreedToMarketParticipationAgreement\n    ) \n        public payable   nonReentrant    \n    {\n        require(paymentCurrency == ETH_ADDRESS, \"Crowdsale: Payment currency is not ETH\"); \n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n\n        /// @dev Get ETH able to be committed.\n        uint256 ethToTransfer = calculateCommitment(msg.value);\n\n        /// @dev Accept ETH Payments.\n        uint256 ethToRefund = msg.value.sub(ethToTransfer);\n        if (ethToTransfer > 0) {\n            _addCommitment(_beneficiary, ethToTransfer);\n        }\n\n        /// @dev Return any ETH to be refunded.\n        if (ethToRefund > 0) {\n            _beneficiary.transfer(ethToRefund);\n        }\n\n        /// @notice Revert if commitmentsTotal exceeds the balance\n        require(marketStatus.commitmentsTotal <= address(this).balance, \"DutchAuction: The committed ETH exceeds the balance\");\n    }\n\n    /**\n     * @notice Buy Tokens by commiting approved ERC20 tokens to this contract address.\n     * @param _amount Amount of tokens to commit.\n     */\n    function commitTokens(uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public {\n        commitTokensFrom(msg.sender, _amount, readAndAgreedToMarketParticipationAgreement);\n    }\n\n    /**\n     * @notice Checks how much is user able to commit and processes that commitment.\n     * @dev Users must approve contract prior to committing tokens to auction.\n     * @param _from User ERC20 address.\n     * @param _amount Amount of approved ERC20 tokens.\n     */\n    function commitTokensFrom(\n        address _from,\n        uint256 _amount,\n        bool readAndAgreedToMarketParticipationAgreement\n    ) \n        public   nonReentrant  \n    {\n        require(address(paymentCurrency) != ETH_ADDRESS, \"Crowdsale: Payment currency is not a token\");\n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n        uint256 tokensToTransfer = calculateCommitment(_amount);\n        if (tokensToTransfer > 0) {\n            _safeTransferFrom(paymentCurrency, msg.sender, tokensToTransfer);\n            _addCommitment(_from, tokensToTransfer);\n        }\n    }\n\n    /**\n     * @notice Checks if the commitment does not exceed the goal of this sale.\n     * @param _commitment Number of tokens to be commited.\n     * @return committed The amount able to be purchased during a sale.\n     */\n    function calculateCommitment(uint256 _commitment)\n        public\n        view\n        returns (uint256 committed)\n    {\n        uint256 tokens = _getTokenAmount(_commitment);\n        uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));\n        if ( tokensCommited.add(tokens) > uint256(marketInfo.totalTokens)) {\n            return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));\n        }\n        return _commitment;\n    }\n\n    /**\n     * @notice Updates commitment of the buyer and the amount raised, emits an event.\n     * @param _addr Recipient of the token purchase.\n     * @param _commitment Value in wei or token involved in the purchase.\n     */\n    function _addCommitment(address _addr, uint256 _commitment) internal {\n        require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), \"Crowdsale: outside auction hours\");\n        require(_addr != address(0), \"Crowdsale: beneficiary is the zero address\");\n\n        uint256 newCommitment = commitments[_addr].add(_commitment);\n        if (marketStatus.usePointList) {\n            require(IPointList(pointList).hasPoints(_addr, newCommitment));\n        }\n\n        commitments[_addr] = newCommitment;\n\n        /// @dev Update state.\n        marketStatus.commitmentsTotal = BoringMath.to128(uint256(marketStatus.commitmentsTotal).add(_commitment));\n\n        emit AddedCommitment(_addr, _commitment);\n    }\n\n    function withdrawTokens() public  {\n        withdrawTokens(msg.sender);\n    }\n\n    /**\n     * @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.\n     * @dev Withdraw tokens only after crowdsale ends.\n     * @param beneficiary Whose tokens will be withdrawn.\n     */\n    function withdrawTokens(address payable beneficiary) public   nonReentrant  {    \n        if (auctionSuccessful()) {\n            require(marketStatus.finalized, \"Crowdsale: not finalized\");\n            /// @dev Successful auction! Transfer claimed tokens.\n            uint256 tokensToClaim = tokensClaimable(beneficiary);\n            require(tokensToClaim > 0, \"Crowdsale: no tokens to claim\"); \n            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);\n            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);\n        } else {\n            /// @dev Auction did not meet reserve price.\n            /// @dev Return committed funds back to user.\n            require(block.timestamp > uint256(marketInfo.endTime), \"Crowdsale: auction has not finished yet\");\n            uint256 accountBalance = commitments[beneficiary];\n            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas\n            _safeTokenPayment(paymentCurrency, beneficiary, accountBalance);\n        }\n    }\n\n    /**\n     * @notice Adjusts users commitment depending on amount already claimed and unclaimed tokens left.\n     * @return claimerCommitment How many tokens the user is able to claim.\n     */\n    function tokensClaimable(address _user) public view returns (uint256 claimerCommitment) {\n        uint256 unclaimedTokens = IERC20(auctionToken).balanceOf(address(this));\n        claimerCommitment = _getTokenAmount(commitments[_user]);\n        claimerCommitment = claimerCommitment.sub(claimed[_user]);\n\n        if(claimerCommitment > unclaimedTokens){\n            claimerCommitment = unclaimedTokens;\n        }\n    }\n    \n    //--------------------------------------------------------\n    // Finalize Auction\n    //--------------------------------------------------------\n    \n    /**\n     * @notice Manually finalizes the Crowdsale.\n     * @dev Must be called after crowdsale ends, to do some extra finalization work.\n     * Calls the contracts finalization function.\n     */\n    function finalize() public nonReentrant {\n        require(            \n            hasAdminRole(msg.sender) \n            || wallet == msg.sender\n            || hasSmartContractRole(msg.sender) \n            || finalizeTimeExpired(),\n            \"Crowdsale: sender must be an admin\"\n        );\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"Crowdsale: already finalized\");\n        MarketInfo storage info = marketInfo;\n        require(auctionEnded(), \"Crowdsale: Has not finished yet\"); \n\n        if (auctionSuccessful()) {\n            /// @dev Successful auction\n            /// @dev Transfer contributed tokens to wallet.\n            _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));\n            /// @dev Transfer unsold tokens to wallet.\n            uint256 soldTokens = _getTokenAmount(uint256(status.commitmentsTotal));\n            uint256 unsoldTokens = uint256(info.totalTokens).sub(soldTokens);\n            if(unsoldTokens > 0) {\n                _safeTokenPayment(auctionToken, wallet, unsoldTokens);\n            }\n        } else {\n            /// @dev Failed auction\n            /// @dev Return auction tokens back to wallet.\n            _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));\n        }\n\n        status.finalized = true;\n\n        emit AuctionFinalized();\n    }\n\n    /**\n     * @notice Cancel Auction\n     * @dev Admin can cancel the auction before it starts\n     */\n    function cancelAuction() public   nonReentrant  \n    {\n        require(hasAdminRole(msg.sender));\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"Crowdsale: already finalized\");\n        require( uint256(status.commitmentsTotal) == 0, \"Crowdsale: Funds already raised\" );\n\n        _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));\n\n        status.finalized = true;\n        emit AuctionCancelled();\n    }\n\n    function tokenPrice() public view returns (uint256) {\n        return uint256(marketPrice.rate); \n    }\n\n    function _getTokenPrice(uint256 _amount) internal view returns (uint256) {\n        return _amount.mul(uint256(marketPrice.rate)).div(AUCTION_TOKEN_DECIMALS);   \n    }\n\n    function getTokenAmount(uint256 _amount) public view returns (uint256) {\n        _getTokenAmount(_amount);\n    }\n\n    /**\n     * @notice Calculates the number of tokens to purchase.\n     * @dev Override to extend the way in which ether is converted to tokens.\n     * @param _amount Value in wei or token to be converted into tokens.\n     * @return tokenAmount Number of tokens that can be purchased with the specified amount.\n     */\n    function _getTokenAmount(uint256 _amount) internal view returns (uint256) {\n        return _amount.mul(AUCTION_TOKEN_DECIMALS).div(uint256(marketPrice.rate));\n    }\n\n    /**\n     * @notice Checks if the sale is open.\n     * @return isOpen True if the crowdsale is open, false otherwise.\n     */\n    function isOpen() public view returns (bool) {\n        return block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime);\n    }\n\n    /**\n     * @notice Checks if the sale minimum amount was raised.\n     * @return auctionSuccessful True if the commitmentsTotal is equal or higher than goal.\n     */\n    function auctionSuccessful() public view returns (bool) {\n        return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal);\n    }\n\n    /**\n     * @notice Checks if the sale has ended.\n     * @return auctionEnded True if sold out or time has ended.\n     */\n    function auctionEnded() public view returns (bool) {\n        return block.timestamp > uint256(marketInfo.endTime) || \n        _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens);\n    }\n\n    /**\n     * @notice Checks if the sale has been finalised.\n     * @return bool True if sale has been finalised.\n     */\n    function finalized() public view returns (bool) {\n        return marketStatus.finalized;\n    }\n\n    /**\n     * @return True if 7 days have passed since the end of the auction\n    */\n    function finalizeTimeExpired() public view returns (bool) {\n        return uint256(marketInfo.endTime) + 7 days < block.timestamp;\n    }\n    \n\n    //--------------------------------------------------------\n    // Documents\n    //--------------------------------------------------------\n\n    function setDocument(string calldata _name, string calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        _setDocument( _name, _data);\n    }\n\n    function setDocuments(string[] calldata _name, string[] calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        uint256 numDocs = _name.length;\n        for (uint256 i = 0; i < numDocs; i++) {\n            _setDocument( _name[i], _data[i]);\n        }\n    }\n\n    function removeDocument(string calldata _name) external {\n        require(hasAdminRole(msg.sender));\n        _removeDocument(_name);\n    }\n\n    //--------------------------------------------------------\n    // Point Lists\n    //--------------------------------------------------------\n\n\n    function setList(address _list) external {\n        require(hasAdminRole(msg.sender));\n        _setList(_list);\n    }\n\n    function enableList(bool _status) external {\n        require(hasAdminRole(msg.sender));\n        marketStatus.usePointList = _status;\n    }\n\n    function _setList(address _pointList) private {\n        if (_pointList != address(0)) {\n            pointList = _pointList;\n            marketStatus.usePointList = true;\n        }\n    }\n\n    //--------------------------------------------------------\n    // Setter Functions\n    //--------------------------------------------------------\n\n    /**\n     * @notice Admin can set start and end time through this function.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     */\n    function setAuctionTime(uint256 _startTime, uint256 _endTime) external {\n        require(hasAdminRole(msg.sender));\n        require(_startTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");\n        require(_endTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"Crowdsale: start time is before current time\");\n        require(_endTime > _startTime, \"Crowdsale: end time must be older than start price\");\n\n        require(marketStatus.commitmentsTotal == 0, \"Crowdsale: auction cannot have already started\");\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        \n        emit AuctionTimeUpdated(_startTime,_endTime);\n    }\n\n    /**\n     * @notice Admin can set auction price through this function.\n     * @param _rate Price per token.\n     * @param _goal Minimum amount raised and goal for the auction.\n     */\n    function setAuctionPrice(uint256 _rate, uint256 _goal) external {\n        require(hasAdminRole(msg.sender));\n        require(_goal > 0, \"Crowdsale: goal is 0\");\n        require(_rate > 0, \"Crowdsale: rate is 0\");\n        require(marketStatus.commitmentsTotal == 0, \"Crowdsale: auction cannot have already started\");\n        marketPrice.rate = BoringMath.to128(_rate);\n        marketPrice.goal = BoringMath.to128(_goal);\n        require(_getTokenAmount(_goal) <= uint256(marketInfo.totalTokens), \"Crowdsale: minimum target exceeds hard cap\");\n\n        emit AuctionPriceUpdated(_rate,_goal);\n    }\n\n    /**\n     * @notice Admin can set the auction wallet through this function.\n     * @param _wallet Auction wallet is where funds will be sent.\n     */\n    function setAuctionWallet(address payable _wallet) external {\n        require(hasAdminRole(msg.sender));\n        require(_wallet != address(0), \"Crowdsale: wallet is the zero address\");\n        wallet = _wallet;\n\n        emit AuctionWalletUpdated(_wallet);\n    }\n\n\n    //--------------------------------------------------------\n    // Market Launchers\n    //--------------------------------------------------------\n\n    function init(bytes calldata _data) external override payable {\n\n    }\n\n    /**\n     * @notice Decodes and hands Crowdsale data to the initCrowdsale function.\n     * @param _data Encoded data for initialization.\n     */\n    function initMarket(bytes calldata _data) public override {\n        (\n        address _funder,\n        address _token,\n        address _paymentCurrency,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _rate,\n        uint256 _goal,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n        ) = abi.decode(_data, (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            address,\n            address\n            )\n        );\n    \n        initCrowdsale(_funder, _token, _paymentCurrency, _totalTokens, _startTime, _endTime, _rate, _goal, _admin, _pointList, _wallet);\n    }\n\n    /**\n     * @notice Collects data to initialize the crowd sale.\n     * @param _funder The address that funds the token for crowdsale.\n     * @param _token Address of the token being sold.\n     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.\n     * @param _totalTokens The total number of tokens to sell in crowdsale.\n     * @param _startTime Crowdsale start time.\n     * @param _endTime Crowdsale end time.\n     * @param _rate Number of token units a buyer gets per wei or token.\n     * @param _goal Minimum amount of funds to be raised in weis or tokens.\n     * @param _admin Address that can finalize crowdsale.\n     * @param _pointList Address that will manage auction approvals.\n     * @param _wallet Address where collected funds will be forwarded to.\n     * @return _data All the data in bytes format.\n     */\n    function getCrowdsaleInitData(\n        address _funder,\n        address _token,\n        address _paymentCurrency,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _rate,\n        uint256 _goal,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    )\n        external pure returns (bytes memory _data)\n    {\n        return abi.encode(\n            _funder,\n            _token,\n            _paymentCurrency,\n            _totalTokens,\n            _startTime,\n            _endTime,\n            _rate,\n            _goal,\n            _admin,\n            _pointList,\n            _wallet\n            );\n    }\n    \n    function getBaseInformation() external view returns(\n        address, \n        uint64,\n        uint64,\n        bool \n    ) {\n        return (auctionToken, marketInfo.startTime, marketInfo.endTime, marketStatus.finalized);\n    }\n\n    function getTotalTokens() external view returns(uint256) {\n        return uint256(marketInfo.totalTokens);\n    }\n}\ncontract PointList is IPointList, MISOAccessControls {\n    using SafeMath for uint;\n\n    /// @notice Maping an address to a number fo points.\n    mapping(address => uint256) public points;\n\n    /// @notice Number of total points.\n    uint256 public totalPoints;\n\n    /// @notice Event emitted when points are updated.\n    event PointsUpdated(address indexed account, uint256 oldPoints, uint256 newPoints);\n\n\n    constructor() public {\n    }\n\n    /**\n     * @notice Initializes point list with admin address.\n     * @param _admin Admins address.\n     */\n    function initPointList(address _admin) public override {\n        initAccessControls(_admin);\n    }\n\n    /**\n     * @notice Checks if account address is in the list (has any points).\n     * @param _account Account address.\n     * @return bool True or False.\n     */\n    function isInList(address _account) public view override returns (bool) {\n        return points[_account] > 0 ;\n    }\n\n    /**\n     * @notice Checks if account has more or equal points as the number given.\n     * @param _account Account address.\n     * @param _amount Desired amount of points.\n     * @return bool True or False.\n     */\n    function hasPoints(address _account, uint256 _amount) public view override returns (bool) {\n        return points[_account] >= _amount ;\n    }\n\n    /**\n     * @notice Sets points to accounts in one batch.\n     * @param _accounts An array of accounts.\n     * @param _amounts An array of corresponding amounts.\n     */\n    function setPoints(address[] memory _accounts, uint256[] memory _amounts) external override {\n        require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PointList.setPoints: Sender must be operator\");\n        require(_accounts.length != 0, \"PointList.setPoints: empty array\");\n        require(_accounts.length == _amounts.length, \"PointList.setPoints: incorrect array length\");\n        for (uint i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            uint256 amount = _amounts[i];\n            uint256 previousPoints = points[account];\n\n            if (amount != previousPoints) {\n                points[account] = amount;\n                totalPoints = totalPoints.sub(previousPoints).add(amount);\n                emit PointsUpdated(account, previousPoints, amount);\n            }\n        }\n    }\n}\ncontract HyperbolicAuction is IMisoMarket, MISOAccessControls, BoringBatchable, SafeTransfer, Documents , ReentrancyGuard  {\n    using BoringERC20 for IERC20;\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n\n    // MISOMarket template id.\n    /// @dev For different marketplace types, this must be incremented.\n    uint256 public constant override marketTemplate = 4;\n    /// @dev The placeholder ETH address.\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Main market variables.\n    struct MarketInfo {\n        uint64 startTime;\n        uint64 endTime;\n        uint128 totalTokens;\n    }\n    MarketInfo public marketInfo;\n\n    /// @notice Market price variables.\n    struct MarketPrice {\n        uint128 minimumPrice;\n        uint128 alpha;\n        // GP: Can be added later as exponent factor\n        // uint16 factor;\n    }\n    MarketPrice public marketPrice;\n\n    /// @notice Market dynamic variables.\n    struct MarketStatus {\n        uint128 commitmentsTotal;\n        bool finalized;\n        bool usePointList;\n\n    }\n    MarketStatus public marketStatus;\n\n    /// @notice The token being sold.\n    address public auctionToken; \n    /// @notice The currency the auction accepts for payment. Can be ETH or token address.\n    address public paymentCurrency;  \n    /// @notice Where the auction funds will get paid.\n    address payable public wallet;  \n    /// @notice Address that manages auction approvals.\n    address public pointList;\n\n    /// @notice The commited amount of accounts.\n    mapping(address => uint256) public commitments;\n    /// @notice Amount of tokens to claim per address.\n    mapping(address => uint256) public claimed;\n\n    /// @notice Event for updating auction times.  Needs to be before auction starts.\n    event AuctionTimeUpdated(uint256 startTime, uint256 endTime); \n    /// @notice Event for updating auction prices. Needs to be before auction starts.\n    event AuctionPriceUpdated( uint256 minimumPrice); \n    /// @notice Event for updating auction wallet. Needs to be before auction starts.\n    event AuctionWalletUpdated(address wallet); \n\n    event AddedCommitment(address addr, uint256 commitment);\n\n    /// @notice Event for finalization of the auction.\n    event AuctionFinalized();\n    /// @notice Event for cancellation of the auction.\n    event AuctionCancelled();\n\n    /**\n     * @notice Initializes main contract variables and transfers funds for the auction.\n     * @dev Init function\n     * @param _funder The address that funds the token for crowdsale\n     * @param _token Address of the token being sold\n     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address\n     * @param _totalTokens The total number of tokens to sell in auction\n     * @param _startTime Auction start time\n     * @param _endTime Auction end time\n     * @param _factor Inflection point of the auction\n     * @param _minimumPrice The minimum auction price\n     * @param _admin Address that can finalize auction.\n     * @param _pointList Address that will manage auction approvals.\n     * @param _wallet Address where collected funds will be forwarded to\n     */\n    function initAuction(\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _factor,\n        uint256 _minimumPrice,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    ) public {\n        require(_startTime < 10000000000, \"HyperbolicAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_endTime < 10000000000, \"HyperbolicAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"HyperbolicAuction: start time is before current time\");\n        require(_totalTokens > 0,\"HyperbolicAuction: total tokens must be greater than zero\");\n        require(_endTime > _startTime, \"HyperbolicAuction: end time must be older than start time\");\n        require(_minimumPrice > 0, \"HyperbolicAuction: minimum price must be greater than 0\"); \n        require(_wallet != address(0), \"HyperbolicAuction: wallet is the zero address\");\n        require(_admin != address(0), \"HyperbolicAuction: admin is the zero address\");\n        require(_token != address(0), \"HyperbolicAuction: token is the zero address\");\n        require(IERC20(_token).decimals() == 18, \"HyperbolicAuction: Token does not have 18 decimals\");\n        if (_paymentCurrency != ETH_ADDRESS) {\n            require(IERC20(_paymentCurrency).decimals() > 0, \"HyperbolicAuction: Payment currency is not ERC20\");\n        }\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n        marketInfo.totalTokens = BoringMath.to128(_totalTokens);\n\n        marketPrice.minimumPrice = BoringMath.to128(_minimumPrice);\n\n        auctionToken = _token;\n        paymentCurrency = _paymentCurrency;\n        wallet = _wallet;\n\n        initAccessControls(_admin);\n        \n        _setList(_pointList);\n\n         // factor = exponent which can later be used to alter the curve\n        uint256 _duration = _endTime - _startTime;\n        uint256 _alpha = _duration.mul(_minimumPrice);\n        marketPrice.alpha = BoringMath.to128(_alpha);\n\n        _safeTransferFrom(_token, _funder, _totalTokens);\n    }\n\n\n    ///--------------------------------------------------------\n    /// Auction Pricing\n    ///--------------------------------------------------------\n\n    /**\n     * @notice Calculates the average price of each token from all commitments.\n     * @return Average token price.\n     */\n    function tokenPrice() public view returns (uint256) {\n        return uint256(marketStatus.commitmentsTotal)\n            .mul(1e18).div(uint256(marketInfo.totalTokens));\n    }\n\n    /**\n     * @notice Returns auction price in any time.\n     * @return Fixed start price or minimum price if outside of auction time, otherwise calculated current price.\n     */\n    function priceFunction() public view returns (uint256) {\n        /// @dev Return Auction Price\n        if (block.timestamp <= uint256(marketInfo.startTime)) {\n            return uint256(-1);\n        }\n        if (block.timestamp >= uint256(marketInfo.endTime)) {\n            return uint256(marketPrice.minimumPrice);\n        }\n        return _currentPrice();\n    }\n\n    /// @notice The current clearing price of the Hyperbolic auction\n    function clearingPrice() public view returns (uint256) {\n        /// @dev If auction successful, return tokenPrice\n        if (tokenPrice() > priceFunction()) {\n            return tokenPrice();\n        }\n        return priceFunction();\n    }\n\n    /**\n     * @notice Calculates price during the auction.\n     * @return Current auction price.\n     */\n    function _currentPrice() private view returns (uint256) {\n        uint256 elapsed = block.timestamp.sub(uint256(marketInfo.startTime));\n        uint256 currentPrice = uint256(marketPrice.alpha).div(elapsed);\n        return currentPrice;\n    }\n\n    ///--------------------------------------------------------\n    /// Commit to buying tokens!\n    ///--------------------------------------------------------\n\n    /**\n     * @notice Buy Tokens by committing ETH to this contract address\n     * @dev Needs sufficient gas limit for additional state changes\n     */\n    receive() external payable {\n        revertBecauseUserDidNotProvideAgreement();\n    }\n\n    /** \n     * @dev Attribution to the awesome delta.financial contracts\n    */  \n    function marketParticipationAgreement() public pure returns (string memory) {\n        return \"I understand that I'm interacting with a smart contract. I understand that tokens commited are subject to the token issuer and local laws where applicable. I reviewed code of the smart contract and understand it fully. I agree to not hold developers or other people associated with the project liable for any losses or misunderstandings\";\n    }\n    /** \n     * @dev Not using modifiers is a purposeful choice for code readability.\n    */ \n    function revertBecauseUserDidNotProvideAgreement() internal pure {\n        revert(\"No agreement provided, please review the smart contract before interacting with it\");\n    }\n\n    /**\n     * @notice Checks the amount of ETH to commit and adds the commitment. Refunds the buyer if commit is too high.\n     * @param _beneficiary Auction participant ETH address.\n     */\n    function commitEth(\n        address payable _beneficiary,\n        bool readAndAgreedToMarketParticipationAgreement\n    ) \n        public payable\n    {\n        require(paymentCurrency == ETH_ADDRESS, \"HyperbolicAuction: payment currency is not ETH address\"); \n        // Get ETH able to be committed\n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n        require(msg.value > 0, \"HyperbolicAuction: Value must be higher than 0\");\n        uint256 ethToTransfer = calculateCommitment(msg.value);\n\n        /// @notice Accept ETH Payments.\n        uint256 ethToRefund = msg.value.sub(ethToTransfer);\n        if (ethToTransfer > 0) {\n            _addCommitment(_beneficiary, ethToTransfer);\n        }\n        /// @notice Return any ETH to be refunded.\n        if (ethToRefund > 0) {\n            _beneficiary.transfer(ethToRefund);\n        }\n\n        /// @notice Revert if commitmentsTotal exceeds the balance\n        require(marketStatus.commitmentsTotal <= address(this).balance, \"DutchAuction: The committed ETH exceeds the balance\");\n    }\n\n    /**\n     * @notice Buy Tokens by commiting approved ERC20 tokens to this contract address.\n     * @param _amount Amount of tokens to commit.\n     */\n    function commitTokens(uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public {\n        commitTokensFrom(msg.sender, _amount, readAndAgreedToMarketParticipationAgreement);\n    }\n\n    /// @dev Users must approve contract prior to committing tokens to auction\n    function commitTokensFrom(\n        address _from,\n        uint256 _amount,\n        bool readAndAgreedToMarketParticipationAgreement\n    )\n        public   nonReentrant  \n    {\n        require(paymentCurrency != ETH_ADDRESS, \"HyperbolicAuction: payment currency is not a token\");\n        if(readAndAgreedToMarketParticipationAgreement == false) {\n            revertBecauseUserDidNotProvideAgreement();\n        }\n        uint256 tokensToTransfer = calculateCommitment(_amount);\n        if (tokensToTransfer > 0) {\n            _safeTransferFrom(paymentCurrency, msg.sender, tokensToTransfer);\n            _addCommitment(_from, tokensToTransfer);\n        }\n    }\n\n    /**\n     * @notice Calculates total amount of tokens committed at current auction price.\n     * @return Number of tokens commited.\n     */\n    function totalTokensCommitted() public view returns (uint256) {\n        return uint256(marketStatus.commitmentsTotal).mul(1e18).div(clearingPrice());\n    }\n\n    /**\n     * @notice Calculates the amout able to be committed during an auction.\n     * @param _commitment Commitment user would like to make.\n     * @return Amount allowed to commit.\n     */\n    function calculateCommitment(uint256 _commitment) public view returns (uint256 ) {\n        uint256 maxCommitment = uint256(marketInfo.totalTokens).mul(clearingPrice()).div(1e18);\n        if (uint256(marketStatus.commitmentsTotal).add(_commitment) > maxCommitment) {\n            return maxCommitment.sub(uint256(marketStatus.commitmentsTotal));\n        }\n        return _commitment;\n    }\n\n\n    /**\n     * @notice Updates commitment for this address and total commitment of the auction.\n     * @param _addr Bidders address.\n     * @param _commitment The amount to commit.\n     */\n    function _addCommitment(address _addr, uint256 _commitment) internal {\n        require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), \"HyperbolicAuction: outside auction hours\"); \n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"HyperbolicAuction: auction already finalized\");\n\n        uint256 newCommitment = commitments[_addr].add(_commitment);\n        if (status.usePointList) {\n            require(IPointList(pointList).hasPoints(_addr, newCommitment));\n        }\n\n        commitments[_addr] = newCommitment;\n        status.commitmentsTotal = BoringMath.to128(uint256(status.commitmentsTotal).add(_commitment));\n        emit AddedCommitment(_addr, _commitment);\n    }\n\n\n    ///--------------------------------------------------------\n    /// Finalize Auction\n    ///--------------------------------------------------------\n\n    /**\n     * @notice Successful if tokens sold equals totalTokens.\n     * @return True if tokenPrice is bigger or equal clearingPrice.\n     */\n    function auctionSuccessful() public view returns (bool) {\n        return tokenPrice() >= clearingPrice();\n    }\n\n    /**\n     * @notice Checks if the auction has ended.\n     * @return True if auction is successful or time has ended.\n     */\n    function auctionEnded() public view returns (bool) {\n        return auctionSuccessful() || block.timestamp > uint256(marketInfo.endTime);\n    }\n\n    /**\n     * @return Returns true if market has been finalized\n     */\n    function finalized() public view returns (bool) {\n        return marketStatus.finalized;\n    }\n\n    /**\n     * @return Returns true if 7 days have passed since the end of the auction\n     */\n    function finalizeTimeExpired() public view returns (bool) {\n        return uint256(marketInfo.endTime) + 7 days < block.timestamp;\n    }\n\n    /**\n     * @notice Auction finishes successfully above the reserve\n     * @dev Transfer contract funds to initialized wallet.\n     */\n    function finalize()\n        public   nonReentrant \n    {\n        require(hasAdminRole(msg.sender) \n                || wallet == msg.sender\n                || hasSmartContractRole(msg.sender) \n                || finalizeTimeExpired(), \"HyperbolicAuction: sender must be an admin\");\n        MarketStatus storage status = marketStatus;\n        MarketInfo storage info = marketInfo;\n\n        require(!status.finalized, \"HyperbolicAuction: auction already finalized\");\n        if (auctionSuccessful()) {\n            /// @dev Successful auction\n            /// @dev Transfer contributed tokens to wallet.\n            _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));\n        } else {\n            /// @dev Failed auction\n            /// @dev Return auction tokens back to wallet.\n            require(block.timestamp > uint256(info.endTime), \"HyperbolicAuction: auction has not finished yet\"); \n            _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));\n        }\n        status.finalized = true;\n        emit AuctionFinalized();\n    }\n\n    /**\n     * @notice Cancel Auction\n     * @dev Admin can cancel the auction before it starts\n     */\n    function cancelAuction() public   nonReentrant  \n    {\n        require(hasAdminRole(msg.sender));\n        MarketStatus storage status = marketStatus;\n        require(!status.finalized, \"HyperbolicAuction: auction already finalized\");\n        require( uint256(status.commitmentsTotal) == 0, \"HyperbolicAuction: auction already committed\" );\n\n        _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));\n\n        status.finalized = true;\n        emit AuctionCancelled();\n    }\n\n    /** \n     * @notice How many tokens the user is able to claim.\n     * @param _user Auction participant address.\n     * @return claimerCommitment User commitments reduced by already claimed tokens.\n     */\n    function tokensClaimable(address _user) public view returns (uint256 claimerCommitment) {\n        if (commitments[_user] == 0) return 0;\n        uint256 unclaimedTokens = IERC20(auctionToken).balanceOf(address(this));\n        claimerCommitment = commitments[_user].mul(uint256(marketInfo.totalTokens)).div(uint256(marketStatus.commitmentsTotal));\n        claimerCommitment = claimerCommitment.sub(claimed[_user]);\n\n        if(claimerCommitment > unclaimedTokens){\n            claimerCommitment = unclaimedTokens;\n        }\n    }\n\n\n   /// @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.\n    function withdrawTokens() public  {\n        withdrawTokens(msg.sender);\n    }\n\n    /// @notice Withdraw your tokens once the Auction has ended.\n    function withdrawTokens(address payable beneficiary) \n        public   nonReentrant \n    {\n        if (auctionSuccessful()) {\n            require(marketStatus.finalized, \"HyperbolicAuction: not finalized\");\n            /// @dev Successful auction! Transfer claimed tokens.\n            uint256 tokensToClaim = tokensClaimable(beneficiary);\n            require(tokensToClaim > 0, \"HyperbolicAuction: no tokens to claim\"); \n            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);\n\n            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);\n        } else {\n            /// @dev Auction did not meet reserve price.\n            /// @dev Return committed funds back to user.\n            require(block.timestamp > uint256(marketInfo.endTime), \"HyperbolicAuction: auction has not finished yet\");\n            uint256 fundsCommitted = commitments[beneficiary];\n            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas\n            _safeTokenPayment(paymentCurrency, beneficiary, fundsCommitted);\n        }\n    }\n\n\n    //--------------------------------------------------------\n    // Documents\n    //--------------------------------------------------------\n\n    function setDocument(string calldata _name, string calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        _setDocument( _name, _data);\n    }\n\n    function setDocuments(string[] calldata _name, string[] calldata _data) external {\n        require(hasAdminRole(msg.sender) );\n        uint256 numDocs = _name.length;\n        for (uint256 i = 0; i < numDocs; i++) {\n            _setDocument( _name[i], _data[i]);\n        }\n    }\n\n    function removeDocument(string calldata _name) external {\n        require(hasAdminRole(msg.sender));\n        _removeDocument(_name);\n    }\n\n\n    //--------------------------------------------------------\n    // Point Lists\n    //--------------------------------------------------------\n\n\n    function setList(address _list) external {\n        require(hasAdminRole(msg.sender));\n        _setList(_list);\n    }\n\n    function enableList(bool _status) external {\n        require(hasAdminRole(msg.sender));\n        marketStatus.usePointList = _status;\n    }\n\n    function _setList(address _pointList) private {\n        if (_pointList != address(0)) {\n            pointList = _pointList;\n            marketStatus.usePointList = true;\n        }\n    }\n\n    //--------------------------------------------------------\n    // Setter Functions\n    //--------------------------------------------------------\n\n    /**\n     * @notice Admin can set start and end time through this function.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     */\n    function setAuctionTime(uint256 _startTime, uint256 _endTime) external {\n        require(hasAdminRole(msg.sender));\n        require(_startTime < 10000000000, \"HyperbolicAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_endTime < 10000000000, \"HyperbolicAuction: enter an unix timestamp in seconds, not miliseconds\");\n        require(_startTime >= block.timestamp, \"HyperbolicAuction: start time is before current time\");\n        require(_endTime > _startTime, \"HyperbolicAuction: end time must be older than start price\");\n        require(marketStatus.commitmentsTotal == 0, \"HyperbolicAuction: auction cannot have already started\");\n\n        marketInfo.startTime = BoringMath.to64(_startTime);\n        marketInfo.endTime = BoringMath.to64(_endTime);\n\n        uint64 _duration = marketInfo.endTime - marketInfo.startTime;        \n        uint256 _alpha = uint256(_duration).mul(uint256(marketPrice.minimumPrice));\n        marketPrice.alpha = BoringMath.to128(_alpha);\n        \n        emit AuctionTimeUpdated(_startTime,_endTime);\n    }\n\n    /**\n     * @notice Admin can set start and min price through this function.\n     * @param _minimumPrice Auction minimum price.\n     */\n    function setAuctionPrice( uint256 _minimumPrice) external {\n        require(hasAdminRole(msg.sender));\n        require(_minimumPrice > 0, \"HyperbolicAuction: minimum price must be greater than 0\"); \n        require(marketStatus.commitmentsTotal == 0, \"HyperbolicAuction: auction cannot have already started\");\n\n        marketPrice.minimumPrice = BoringMath.to128(_minimumPrice);\n\n        uint64 _duration = marketInfo.endTime - marketInfo.startTime;        \n        uint256 _alpha = uint256(_duration).mul(uint256(marketPrice.minimumPrice));\n        marketPrice.alpha = BoringMath.to128(_alpha);\n\n        emit AuctionPriceUpdated(_minimumPrice);\n    }\n\n    /**\n     * @notice Admin can set the auction wallet through this function.\n     * @param _wallet Auction wallet is where funds will be sent.\n     */\n    function setAuctionWallet(address payable _wallet) external {\n        require(hasAdminRole(msg.sender));\n        require(_wallet != address(0), \"HyperbolicAuction: wallet is the zero address\");\n\n        wallet = _wallet;\n\n        emit AuctionWalletUpdated(_wallet);\n    }\n\n\n\n    ///--------------------------------------------------------\n    /// Market Launchers\n    ///--------------------------------------------------------\n\n    function init(bytes calldata _data) external override payable {\n    }\n\n    /**\n     * @notice Decodes and hands auction data to the initAuction function.\n     * @param _data Encoded data for initialization.\n     */\n    function initMarket(bytes calldata _data) public override {\n        (\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _factor,\n        uint256 _minimumPrice,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n        ) = abi.decode(_data, (\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            uint256,\n            address,\n            address,\n            address\n        ));\n        initAuction(_funder, _token, _totalTokens, _startTime, _endTime, _paymentCurrency, _factor, _minimumPrice, _admin, _pointList, _wallet);\n    }\n\n    /**\n     * @notice Collects data to initialize the auction and encodes them.\n     * @param _funder The address that funds the token for crowdsale.\n     * @param _token Address of the token being sold.\n     * @param _totalTokens The total number of tokens to sell in auction.\n     * @param _startTime Auction start time.\n     * @param _endTime Auction end time.\n     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.\n     * @param _factor Inflection point of the auction.\n     * @param _minimumPrice The minimum auction price.\n     * @param _wallet Address where collected funds will be forwarded to.\n     * @return _data All the data in bytes format.\n     */\n    function getAuctionInitData(\n        address _funder,\n        address _token,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime,\n        address _paymentCurrency,\n        uint256 _factor,\n        uint256 _minimumPrice,\n        address _admin,\n        address _pointList,\n        address payable _wallet\n    )\n        external pure returns (bytes memory _data) {\n            return abi.encode(\n                _funder,\n                _token,\n                _totalTokens,\n                _startTime,\n                _endTime,\n                _paymentCurrency,\n                _factor,\n                _minimumPrice,\n                _admin,\n                _pointList,\n                _wallet\n            );\n        }\n\n    function getBaseInformation() external view returns(\n        address , \n        uint64 ,\n        uint64 ,\n        bool \n    ) {\n        return (auctionToken, marketInfo.startTime, marketInfo.endTime, marketStatus.finalized);\n    }\n    \n    function getTotalTokens() external view returns(uint256) {\n        return uint256(marketInfo.totalTokens);\n    }\n}\ncontract BaseBoringBatchable {\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param calls An array of inputs for each call.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.\n    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n    // C3: The length of the loop is fully under user control, so can't be exploited\n    // C7: Delegatecall is only used on the same contract, so it's safe\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = result;\n        }\n    }\n}\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n",
    "bin": []
}