{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/34/v4-core",
    "external_functions": [
        [
            "DrawBeacon",
            "RNGInterface",
            "IDrawBuffer"
        ],
        [
            "DrawBuffer"
        ],
        [
            "DrawCalculator",
            "IPrizeDistributionBuffer",
            "IDrawBuffer",
            "ITicket"
        ],
        [
            "PrizeDistributor",
            "IDrawCalculator"
        ],
        [
            "Reserve",
            "IERC20"
        ],
        [
            "PrizeSplitStrategy",
            "IPrizePool"
        ]
    ],
    "new_contract": "contract DrawBeacon is IDrawBeacon, Ownable {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ============ Variables ============ */\n\n    /// @notice RNG contract interface\n    RNGInterface internal rng;\n\n    /// @notice Current RNG Request\n    RngRequest internal rngRequest;\n\n    /// @notice DrawBuffer address\n    IDrawBuffer internal drawBuffer;\n\n    /**\n     * @notice RNG Request Timeout.  In fact, this is really a \"complete draw\" timeout.\n     * @dev If the rng completes the award can still be cancelled.\n     */\n    uint32 internal rngTimeout;\n\n    /// @notice Seconds between beacon period request\n    uint32 internal beaconPeriodSeconds;\n\n    /// @notice Epoch timestamp when beacon period can start\n    uint64 internal beaconPeriodStartedAt;\n\n    /**\n     * @notice Next Draw ID to use when pushing a Draw onto DrawBuffer\n     * @dev Starts at 1. This way we know that no Draw has been recorded at 0.\n     */\n    uint32 internal nextDrawId;\n\n    /* ============ Structs ============ */\n\n    /**\n     * @notice RNG Request\n     * @param id          RNG request ID\n     * @param lockBlock   Block number that the RNG request is locked\n     * @param requestedAt Time when RNG is requested\n     */\n    struct RngRequest {\n        uint32 id;\n        uint32 lockBlock;\n        uint64 requestedAt;\n    }\n\n    /* ============ Events ============ */\n\n    /**\n     * @notice Emit when the DrawBeacon is deployed.\n     * @param nextDrawId Draw ID at which the DrawBeacon should start. Can't be inferior to 1.\n     * @param beaconPeriodStartedAt Timestamp when beacon period starts.\n     */\n    event Deployed(\n        uint32 nextDrawId,\n        uint64 beaconPeriodStartedAt\n    );\n\n    /* ============ Modifiers ============ */\n\n    modifier requireDrawNotStarted() {\n        _requireDrawNotStarted();\n        _;\n    }\n\n    modifier requireCanStartDraw() {\n        require(_isBeaconPeriodOver(), \"DrawBeacon/beacon-period-not-over\");\n        require(!isRngRequested(), \"DrawBeacon/rng-already-requested\");\n        _;\n    }\n\n    modifier requireCanCompleteRngRequest() {\n        require(isRngRequested(), \"DrawBeacon/rng-not-requested\");\n        require(isRngCompleted(), \"DrawBeacon/rng-not-complete\");\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Deploy the DrawBeacon smart contract.\n     * @param _owner Address of the DrawBeacon owner\n     * @param _drawBuffer The address of the draw buffer to push draws to\n     * @param _rng The RNG service to use\n     * @param _nextDrawId Draw ID at which the DrawBeacon should start. Can't be inferior to 1.\n     * @param _beaconPeriodStart The starting timestamp of the beacon period.\n     * @param _beaconPeriodSeconds The duration of the beacon period in seconds\n     */\n    constructor(\n        address _owner,\n        IDrawBuffer _drawBuffer,\n        RNGInterface _rng,\n        uint32 _nextDrawId,\n        uint64 _beaconPeriodStart,\n        uint32 _beaconPeriodSeconds,\n        uint32 _rngTimeout\n    ) Ownable(_owner) {\n        require(_beaconPeriodStart > 0, \"DrawBeacon/beacon-period-greater-than-zero\");\n        require(address(_rng) != address(0), \"DrawBeacon/rng-not-zero\");\n        require(_nextDrawId >= 1, \"DrawBeacon/next-draw-id-gte-one\");\n\n        beaconPeriodStartedAt = _beaconPeriodStart;\n        nextDrawId = _nextDrawId;\n\n        _setBeaconPeriodSeconds(_beaconPeriodSeconds);\n        _setDrawBuffer(_drawBuffer);\n        _setRngService(_rng);\n        _setRngTimeout(_rngTimeout);\n\n        emit Deployed(_nextDrawId, _beaconPeriodStart);\n        emit BeaconPeriodStarted(_beaconPeriodStart);\n    }\n\n    /* ============ Public Functions ============ */\n\n    /**\n     * @notice Returns whether the random number request has completed.\n     * @return True if a random number request has completed, false otherwise.\n     */\n    function isRngCompleted() public view override returns (bool) {\n        return rng.isRequestComplete(rngRequest.id);\n    }\n\n    /**\n     * @notice Returns whether a random number has been requested\n     * @return True if a random number has been requested, false otherwise.\n     */\n    function isRngRequested() public view override returns (bool) {\n        return rngRequest.id != 0;\n    }\n\n    /**\n     * @notice Returns whether the random number request has timed out.\n     * @return True if a random number request has timed out, false otherwise.\n     */\n    function isRngTimedOut() public view override returns (bool) {\n        if (rngRequest.requestedAt == 0) {\n            return false;\n        } else {\n            return rngTimeout + rngRequest.requestedAt < _currentTime();\n        }\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IDrawBeacon\n    function canStartDraw() external view override returns (bool) {\n        return _isBeaconPeriodOver() && !isRngRequested();\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function canCompleteDraw() external view override returns (bool) {\n        return isRngRequested() && isRngCompleted();\n    }\n\n    /// @notice Calculates the next beacon start time, assuming all beacon periods have occurred between the last and now.\n    /// @return The next beacon period start time\n    function calculateNextBeaconPeriodStartTimeFromCurrentTime() external view returns (uint64) {\n        return\n            _calculateNextBeaconPeriodStartTime(\n                beaconPeriodStartedAt,\n                beaconPeriodSeconds,\n                _currentTime()\n            );\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function calculateNextBeaconPeriodStartTime(uint256 _time)\n        external\n        view\n        override\n        returns (uint64)\n    {\n        return\n            _calculateNextBeaconPeriodStartTime(\n                beaconPeriodStartedAt,\n                beaconPeriodSeconds,\n                uint64(_time)\n            );\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function cancelDraw() external override {\n        require(isRngTimedOut(), \"DrawBeacon/rng-not-timedout\");\n        uint32 requestId = rngRequest.id;\n        uint32 lockBlock = rngRequest.lockBlock;\n        delete rngRequest;\n        emit DrawCancelled(requestId, lockBlock);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function completeDraw() external override requireCanCompleteRngRequest {\n        uint256 randomNumber = rng.randomNumber(rngRequest.id);\n        uint32 _nextDrawId = nextDrawId;\n        uint64 _beaconPeriodStartedAt = beaconPeriodStartedAt;\n        uint32 _beaconPeriodSeconds = beaconPeriodSeconds;\n        uint64 _time = _currentTime();\n\n        // create Draw struct\n        IDrawBeacon.Draw memory _draw = IDrawBeacon.Draw({\n            winningRandomNumber: randomNumber,\n            drawId: _nextDrawId,\n            timestamp: rngRequest.requestedAt, // must use the startAward() timestamp to prevent front-running\n            beaconPeriodStartedAt: _beaconPeriodStartedAt,\n            beaconPeriodSeconds: _beaconPeriodSeconds\n        });\n\n        drawBuffer.pushDraw(_draw);\n\n        // to avoid clock drift, we should calculate the start time based on the previous period start time.\n        uint64 nextBeaconPeriodStartedAt = _calculateNextBeaconPeriodStartTime(\n            _beaconPeriodStartedAt,\n            _beaconPeriodSeconds,\n            _time\n        );\n        beaconPeriodStartedAt = nextBeaconPeriodStartedAt;\n        nextDrawId = _nextDrawId + 1;\n\n        // Reset the rngReqeust state so Beacon period can start again.\n        delete rngRequest;\n\n        emit DrawCompleted(randomNumber);\n        emit BeaconPeriodStarted(nextBeaconPeriodStartedAt);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function beaconPeriodRemainingSeconds() external view override returns (uint64) {\n        return _beaconPeriodRemainingSeconds();\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function beaconPeriodEndAt() external view override returns (uint64) {\n        return _beaconPeriodEndAt();\n    }\n\n    function getBeaconPeriodSeconds() external view returns (uint32) {\n        return beaconPeriodSeconds;\n    }\n\n    function getBeaconPeriodStartedAt() external view returns (uint64) {\n        return beaconPeriodStartedAt;\n    }\n\n    function getDrawBuffer() external view returns (IDrawBuffer) {\n        return drawBuffer;\n    }\n\n    function getNextDrawId() external view returns (uint32) {\n        return nextDrawId;\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function getLastRngLockBlock() external view override returns (uint32) {\n        return rngRequest.lockBlock;\n    }\n\n    function getLastRngRequestId() external view override returns (uint32) {\n        return rngRequest.id;\n    }\n\n    function getRngService() external view returns (RNGInterface) {\n        return rng;\n    }\n\n    function getRngTimeout() external view returns (uint32) {\n        return rngTimeout;\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function isBeaconPeriodOver() external view override returns (bool) {\n        return _isBeaconPeriodOver();\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setDrawBuffer(IDrawBuffer newDrawBuffer)\n        external\n        override\n        onlyOwner\n        returns (IDrawBuffer)\n    {\n        return _setDrawBuffer(newDrawBuffer);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function startDraw() external override requireCanStartDraw {\n        (address feeToken, uint256 requestFee) = rng.getRequestFee();\n\n        if (feeToken != address(0) && requestFee > 0) {\n            IERC20(feeToken).safeApprove(address(rng), requestFee);\n        }\n\n        (uint32 requestId, uint32 lockBlock) = rng.requestRandomNumber();\n        rngRequest.id = requestId;\n        rngRequest.lockBlock = lockBlock;\n        rngRequest.requestedAt = _currentTime();\n\n        emit DrawStarted(requestId, lockBlock);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setBeaconPeriodSeconds(uint32 _beaconPeriodSeconds)\n        external\n        override\n        onlyOwner\n        requireDrawNotStarted\n    {\n        _setBeaconPeriodSeconds(_beaconPeriodSeconds);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setRngTimeout(uint32 _rngTimeout) external override onlyOwner requireDrawNotStarted {\n        _setRngTimeout(_rngTimeout);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setRngService(RNGInterface _rngService)\n        external\n        override\n        onlyOwner\n        requireDrawNotStarted\n    {\n        _setRngService(_rngService);\n    }\n\n    /**\n     * @notice Sets the RNG service that the Prize Strategy is connected to\n     * @param _rngService The address of the new RNG service interface\n     */\n    function _setRngService(RNGInterface _rngService) internal\n    {\n        rng = _rngService;\n        emit RngServiceUpdated(_rngService);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Calculates when the next beacon period will start\n     * @param _beaconPeriodStartedAt The timestamp at which the beacon period started\n     * @param _beaconPeriodSeconds The duration of the beacon period in seconds\n     * @param _time The timestamp to use as the current time\n     * @return The timestamp at which the next beacon period would start\n     */\n    function _calculateNextBeaconPeriodStartTime(\n        uint64 _beaconPeriodStartedAt,\n        uint32 _beaconPeriodSeconds,\n        uint64 _time\n    ) internal pure returns (uint64) {\n        uint64 elapsedPeriods = (_time - _beaconPeriodStartedAt) / _beaconPeriodSeconds;\n        return _beaconPeriodStartedAt + (elapsedPeriods * _beaconPeriodSeconds);\n    }\n\n    /**\n     * @notice returns the current time.  Used for testing.\n     * @return The current time (block.timestamp)\n     */\n    function _currentTime() internal view virtual returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * @notice Returns the timestamp at which the beacon period ends\n     * @return The timestamp at which the beacon period ends\n     */\n    function _beaconPeriodEndAt() internal view returns (uint64) {\n        return beaconPeriodStartedAt + beaconPeriodSeconds;\n    }\n\n    /**\n     * @notice Returns the number of seconds remaining until the prize can be awarded.\n     * @return The number of seconds remaining until the prize can be awarded.\n     */\n    function _beaconPeriodRemainingSeconds() internal view returns (uint64) {\n        uint64 endAt = _beaconPeriodEndAt();\n        uint64 time = _currentTime();\n\n        if (endAt <= time) {\n            return 0;\n        }\n\n        return endAt - time;\n    }\n\n    /**\n     * @notice Returns whether the beacon period is over.\n     * @return True if the beacon period is over, false otherwise\n     */\n    function _isBeaconPeriodOver() internal view returns (bool) {\n        return _beaconPeriodEndAt() <= _currentTime();\n    }\n\n    /**\n     * @notice Check to see draw is in progress.\n     */\n    function _requireDrawNotStarted() internal view {\n        uint256 currentBlock = block.number;\n\n        require(\n            rngRequest.lockBlock == 0 || currentBlock < rngRequest.lockBlock,\n            \"DrawBeacon/rng-in-flight\"\n        );\n    }\n\n    /**\n     * @notice Set global DrawBuffer variable.\n     * @dev    All subsequent Draw requests/completions will be pushed to the new DrawBuffer.\n     * @param _newDrawBuffer  DrawBuffer address\n     * @return DrawBuffer\n     */\n    function _setDrawBuffer(IDrawBuffer _newDrawBuffer) internal returns (IDrawBuffer) {\n        IDrawBuffer _previousDrawBuffer = drawBuffer;\n        require(address(_newDrawBuffer) != address(0), \"DrawBeacon/draw-history-not-zero-address\");\n\n        require(\n            address(_newDrawBuffer) != address(_previousDrawBuffer),\n            \"DrawBeacon/existing-draw-history-address\"\n        );\n\n        drawBuffer = _newDrawBuffer;\n\n        emit DrawBufferUpdated(_newDrawBuffer);\n\n        return _newDrawBuffer;\n    }\n\n    /**\n     * @notice Sets the beacon period in seconds.\n     * @param _beaconPeriodSeconds The new beacon period in seconds.  Must be greater than zero.\n     */\n    function _setBeaconPeriodSeconds(uint32 _beaconPeriodSeconds) internal {\n        require(_beaconPeriodSeconds > 0, \"DrawBeacon/beacon-period-greater-than-zero\");\n        beaconPeriodSeconds = _beaconPeriodSeconds;\n\n        emit BeaconPeriodSecondsUpdated(_beaconPeriodSeconds);\n    }\n\n    /**\n     * @notice Sets the RNG request timeout in seconds.  This is the time that must elapsed before the RNG request can be cancelled and the pool unlocked.\n     * @param _rngTimeout The RNG request timeout in seconds.\n     */\n    function _setRngTimeout(uint32 _rngTimeout) internal {\n        require(_rngTimeout > 60, \"DrawBeacon/rng-timeout-gt-60-secs\");\n        rngTimeout = _rngTimeout;\n\n        emit RngTimeoutSet(_rngTimeout);\n    }\n}\ncontract Reserve is IReserve, Manageable {\n    using SafeERC20 for IERC20;\n\n    /// @notice ERC20 token\n    IERC20 public immutable token;\n\n    /// @notice Total withdraw amount from reserve\n    uint224 public withdrawAccumulator;\n\n    /// @notice The maximum number of twab entries\n    uint24 internal constant MAX_CARDINALITY = 16777215; // 2**24\n\n    ObservationLib.Observation[MAX_CARDINALITY] internal reserveAccumulators;\n\n    uint24 internal cardinality;\n\n    /* ============ Events ============ */\n\n    event Deployed(IERC20 indexed token);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructs Ticket with passed parameters.\n     * @param _owner Owner address\n     * @param _token ERC20 address\n     */\n    constructor(address _owner, IERC20 _token) Ownable(_owner) {\n        token = _token;\n        emit Deployed(_token);\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IReserve\n    function checkpoint() external override {\n        _checkpoint();\n    }\n\n    /// @inheritdoc IReserve\n    function getToken() external view override returns (IERC20) {\n        return token;\n    }\n\n    /// @inheritdoc IReserve\n    function getReserveAccumulatedBetween(uint32 _startTimestamp, uint32 _endTimestamp)\n        external\n        view\n        override\n        returns (uint224)\n    {\n        require(_startTimestamp < _endTimestamp, \"Reserve/start-less-then-end\");\n        uint24 _cardinality = cardinality;\n\n        ObservationLib.Observation memory _newestObservation;\n\n        if (_cardinality > 0) {\n            _newestObservation = reserveAccumulators[_cardinality - 1];\n        }\n\n        ObservationLib.Observation memory _oldestObservation = reserveAccumulators[0];\n\n        uint224 _start = _getReserveAccumulatedAt(\n            _newestObservation,\n            _oldestObservation,\n            _cardinality,\n            _startTimestamp\n        );\n\n        uint224 _end = _getReserveAccumulatedAt(\n            _newestObservation,\n            _oldestObservation,\n            _cardinality,\n            _endTimestamp\n        );\n\n        return _end - _start;\n    }\n\n    /// @inheritdoc IReserve\n    function withdrawTo(address _recipient, uint256 _amount) external override onlyManagerOrOwner {\n        _checkpoint();\n\n        withdrawAccumulator += uint224(_amount);\n        \n        token.safeTransfer(_recipient, _amount);\n\n        emit Withdrawn(_recipient, _amount);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Find optimal observation checkpoint using target timestamp\n     * @dev    Uses binary search if target timestamp is within ring buffer range.\n     * @param _newestObservation ObservationLib.Observation\n     * @param _oldestObservation ObservationLib.Observation\n     * @param _cardinality       RingBuffer Range\n     * @param _timestamp          Timestamp target\n     *\n     * @return Optimal reserveAccumlator for timestamp.\n     */\n    function _getReserveAccumulatedAt(\n        ObservationLib.Observation memory _newestObservation,\n        ObservationLib.Observation memory _oldestObservation,\n        uint24 _cardinality,\n        uint32 _timestamp\n    ) internal view returns (uint224) {\n        uint32 timeNow = uint32(block.timestamp);\n\n        // IF empty ring buffer exit early.\n        if (_cardinality == 0) return 0;\n\n        /**\n         * Ring Buffer Search Optimization\n         * Before performing binary search on the ring buffer check\n         * to see if timestamp is within range of [o T n] by comparing\n         * the target timestamp to the oldest/newest observation.timestamps\n         * IF the timestamp is out of the ring buffer range avoid starting\n         * a binary search, because we can return NULL or oldestObservation.amount\n         */\n\n        /**\n         * IF oldestObservation.timestamp is after timestamp: T[old ]\n         * the Reserve did NOT have a balance or the ring buffer\n         * no longer contains that timestamp checkpoint.\n         */\n        if (_oldestObservation.timestamp > _timestamp) {\n            return 0;\n        }\n\n        /**\n         * IF newestObservation.timestamp is before timestamp: [ new]T\n         * return _newestObservation.amount since observation\n         * contains the highest checkpointed reserveAccumulator.\n         */\n        if (_newestObservation.timestamp <= _timestamp) {\n            return _newestObservation.amount;\n        }\n\n        // IF the timestamp is witin range of ring buffer start/end: [new T old]\n        // FIND the closest observation to the left(or exact) of timestamp: [OT ]\n        (\n            ObservationLib.Observation memory beforeOrAt,\n            ObservationLib.Observation memory atOrAfter\n        ) = ObservationLib.binarySearch(\n                reserveAccumulators,\n                _cardinality - 1,\n                0,\n                _timestamp,\n                _cardinality,\n                timeNow\n            );\n\n        // IF target timestamp is EXACT match for atOrAfter.timestamp observation return amount.\n        // NOT having an exact match with atOrAfter means values will contain accumulator value AFTER the searchable range.\n        // ELSE return observation.totalDepositedAccumulator closest to LEFT of target timestamp.\n        if (atOrAfter.timestamp == _timestamp) {\n            return atOrAfter.amount;\n        } else {\n            return beforeOrAt.amount;\n        }\n    }\n\n    /// @notice Records the currently accrued reserve amount.\n    function _checkpoint() internal {\n        uint24 _cardinality = cardinality;\n        uint256 _balanceOfReserve = token.balanceOf(address(this));\n        uint224 _withdrawAccumulator = withdrawAccumulator; //sload\n        ObservationLib.Observation memory _newestObservation = _getNewestObservation(_cardinality);\n\n        /**\n         * IF tokens have been deposited into Reserve contract since the last checkpoint\n         * create a new Reserve balance checkpoint. The will will update multiple times in a single block.\n         */\n        if (_balanceOfReserve + _withdrawAccumulator > _newestObservation.amount) {\n            uint32 nowTime = uint32(block.timestamp);\n\n            // checkpointAccumulator = currentBalance + totalWithdraws\n            uint224 newReserveAccumulator = uint224(_balanceOfReserve) + _withdrawAccumulator;\n\n            // IF _newestObservation IS NOT in the current block.\n            // CREATE observation in the accumulators ring buffer.\n            if (_newestObservation.timestamp != nowTime) {\n                reserveAccumulators[_cardinality] = ObservationLib.Observation({\n                    amount: newReserveAccumulator,\n                    timestamp: nowTime\n                });\n\n                cardinality++;\n            }\n            // ELSE IF _newestObservation IS in the current block.\n            // UPDATE the checkpoint previously created in block history.\n            else {\n                reserveAccumulators[_cardinality - 1] = ObservationLib.Observation({\n                    amount: newReserveAccumulator,\n                    timestamp: nowTime\n                });\n            }\n\n            emit Checkpoint(newReserveAccumulator, _withdrawAccumulator);\n        }\n    }\n\n    /// @notice Retrieves the newest observation\n    function _getNewestObservation(uint24 _cardinality)\n        internal\n        view\n        returns (ObservationLib.Observation memory _observation)\n    {\n        if (_cardinality > 0) _observation = reserveAccumulators[_cardinality - 1];\n    }\n}\ncontract DrawBuffer is IDrawBuffer, Manageable {\n    using DrawRingBufferLib for DrawRingBufferLib.Buffer;\n\n    /// @notice Draws ring buffer max length.\n    uint16 public constant MAX_CARDINALITY = 256;\n\n    /// @notice Draws ring buffer array.\n    IDrawBeacon.Draw[MAX_CARDINALITY] private _draws;\n\n    /// @notice Holds ring buffer information\n    DrawRingBufferLib.Buffer internal drawRingBuffer;\n\n    /* ============ Deploy ============ */\n\n    /**\n     * @notice Deploy DrawBuffer smart contract.\n     * @param _owner Address of the owner of the DrawBuffer.\n     * @param _cardinality Draw ring buffer cardinality.\n     */\n    constructor(address _owner, uint8 _cardinality) Ownable(_owner) {\n        drawRingBuffer.cardinality = _cardinality;\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IDrawBuffer\n    function getBufferCardinality() external view override returns (uint32) {\n        return drawRingBuffer.cardinality;\n    }\n\n    /// @inheritdoc IDrawBuffer\n    function getDraw(uint32 drawId) external view override returns (IDrawBeacon.Draw memory) {\n        return _draws[_drawIdToDrawIndex(drawRingBuffer, drawId)];\n    }\n\n    /// @inheritdoc IDrawBuffer\n    function getDraws(uint32[] calldata _drawIds)\n        external\n        view\n        override\n        returns (IDrawBeacon.Draw[] memory)\n    {\n        IDrawBeacon.Draw[] memory draws = new IDrawBeacon.Draw[](_drawIds.length);\n        DrawRingBufferLib.Buffer memory buffer = drawRingBuffer;\n\n        for (uint256 index = 0; index < _drawIds.length; index++) {\n            draws[index] = _draws[_drawIdToDrawIndex(buffer, _drawIds[index])];\n        }\n\n        return draws;\n    }\n\n    /// @inheritdoc IDrawBuffer\n    function getDrawCount() external view override returns (uint32) {\n        DrawRingBufferLib.Buffer memory buffer = drawRingBuffer;\n\n        if (buffer.lastDrawId == 0) {\n            return 0;\n        }\n\n        uint32 bufferNextIndex = buffer.nextIndex;\n\n        if (_draws[bufferNextIndex].timestamp != 0) {\n            return buffer.cardinality;\n        } else {\n            return bufferNextIndex;\n        }\n    }\n\n    /// @inheritdoc IDrawBuffer\n    function getNewestDraw() external view override returns (IDrawBeacon.Draw memory) {\n        return _getNewestDraw(drawRingBuffer);\n    }\n\n    /// @inheritdoc IDrawBuffer\n    function getOldestDraw() external view override returns (IDrawBeacon.Draw memory) {\n        // oldest draw should be next available index, otherwise it's at 0\n        DrawRingBufferLib.Buffer memory buffer = drawRingBuffer;\n        IDrawBeacon.Draw memory draw = _draws[buffer.nextIndex];\n\n        if (draw.timestamp == 0) {\n            // if draw is not init, then use draw at 0\n            draw = _draws[0];\n        }\n\n        return draw;\n    }\n\n    /// @inheritdoc IDrawBuffer\n    function pushDraw(IDrawBeacon.Draw memory _draw)\n        external\n        override\n        onlyManagerOrOwner\n        returns (uint32)\n    {\n        return _pushDraw(_draw);\n    }\n\n    /// @inheritdoc IDrawBuffer\n    function setDraw(IDrawBeacon.Draw memory _newDraw) external override onlyOwner returns (uint32) {\n        DrawRingBufferLib.Buffer memory buffer = drawRingBuffer;\n        uint32 index = buffer.getIndex(_newDraw.drawId);\n        _draws[index] = _newDraw;\n        emit DrawSet(_newDraw.drawId, _newDraw);\n        return _newDraw.drawId;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Convert a Draw.drawId to a Draws ring buffer index pointer.\n     * @dev    The getNewestDraw.drawId() is used to calculate a Draws ID delta position.\n     * @param _drawId Draw.drawId\n     * @return Draws ring buffer index pointer\n     */\n    function _drawIdToDrawIndex(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)\n        internal\n        pure\n        returns (uint32)\n    {\n        return _buffer.getIndex(_drawId);\n    }\n\n    /**\n     * @notice Read newest Draw from the draws ring buffer.\n     * @dev    Uses the lastDrawId to calculate the most recently added Draw.\n     * @param _buffer Draw ring buffer\n     * @return IDrawBeacon.Draw\n     */\n    function _getNewestDraw(DrawRingBufferLib.Buffer memory _buffer)\n        internal\n        view\n        returns (IDrawBeacon.Draw memory)\n    {\n        return _draws[_buffer.getIndex(_buffer.lastDrawId)];\n    }\n\n    /**\n     * @notice Push Draw onto draws ring buffer history.\n     * @dev    Push new draw onto draws list via authorized manager or owner.\n     * @param _newDraw IDrawBeacon.Draw\n     * @return Draw.drawId\n     */\n    function _pushDraw(IDrawBeacon.Draw memory _newDraw) internal returns (uint32) {\n        DrawRingBufferLib.Buffer memory _buffer = drawRingBuffer;\n        _draws[_buffer.nextIndex] = _newDraw;\n        drawRingBuffer = _buffer.push(_newDraw.drawId);\n\n        emit DrawSet(_newDraw.drawId, _newDraw);\n\n        return _newDraw.drawId;\n    }\n}\ncontract PrizeSplitStrategy is PrizeSplit, IStrategy {\n    /**\n     * @notice PrizePool address\n     */\n    IPrizePool internal prizePool;\n\n    /**\n     * @notice Deployed Event\n     * @param owner Contract owner\n     * @param prizePool Linked PrizePool contract\n     */\n    event Deployed(address indexed owner, IPrizePool prizePool);\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Deploy the PrizeSplitStrategy smart contract.\n     * @param _owner     Owner address\n     * @param _prizePool PrizePool address\n     */\n    constructor(address _owner, IPrizePool _prizePool) Ownable(_owner) {\n        require(\n            address(_prizePool) != address(0),\n            \"PrizeSplitStrategy/prize-pool-not-zero-address\"\n        );\n        prizePool = _prizePool;\n        emit Deployed(_owner, _prizePool);\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IStrategy\n    function distribute() external override returns (uint256) {\n        uint256 prize = prizePool.captureAwardBalance();\n\n        if (prize == 0) return 0;\n\n        _distributePrizeSplits(prize);\n\n        emit Distributed(prize);\n\n        return prize;\n    }\n\n    /// @inheritdoc IPrizeSplit\n    function getPrizePool() external view override returns (IPrizePool) {\n        return prizePool;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Award ticket tokens to prize split recipient.\n     * @dev Award ticket tokens to prize split recipient via the linked PrizePool contract.\n     * @param _to Recipient of minted tokens.\n     * @param _amount Amount of minted tokens.\n     */\n    function _awardPrizeSplitAmount(address _to, uint256 _amount) internal override {\n        IControlledToken _ticket = prizePool.getTicket();\n        prizePool.award(_to, _amount);\n        emit PrizeSplitAwarded(_to, _amount, _ticket);\n    }\n}\ncontract PrizeDistributor is IPrizeDistributor, Ownable {\n    using SafeERC20 for IERC20;\n\n    /* ============ Global Variables ============ */\n\n    /// @notice DrawCalculator address\n    IDrawCalculator internal drawCalculator;\n\n    /// @notice Token address\n    IERC20 internal immutable token;\n\n    /// @notice Maps users => drawId => paid out balance\n    mapping(address => mapping(uint256 => uint256)) internal userDrawPayouts;\n\n    /* ============ Initialize ============ */\n\n    /**\n     * @notice Initialize PrizeDistributor smart contract.\n     * @param _owner          Owner address\n     * @param _token          Token address\n     * @param _drawCalculator DrawCalculator address\n     */\n    constructor(\n        address _owner,\n        IERC20 _token,\n        IDrawCalculator _drawCalculator\n    ) Ownable(_owner) {\n        _setDrawCalculator(_drawCalculator);\n        require(address(_token) != address(0), \"PrizeDistributor/token-not-zero-address\");\n        token = _token;\n        emit TokenSet(_token);\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IPrizeDistributor\n    function claim(\n        address _user,\n        uint32[] calldata _drawIds,\n        bytes calldata _data\n    ) external override returns (uint256) {\n        \n        uint256 totalPayout;\n        \n        (uint256[] memory drawPayouts, ) = drawCalculator.calculate(_user, _drawIds, _data); // neglect the prizeCounts since we are not interested in them here\n\n        for (uint256 payoutIndex = 0; payoutIndex < drawPayouts.length; payoutIndex++) {\n            uint32 drawId = _drawIds[payoutIndex];\n            uint256 payout = drawPayouts[payoutIndex];\n            uint256 oldPayout = _getDrawPayoutBalanceOf(_user, drawId);\n            uint256 payoutDiff = 0;\n\n            if (payout > oldPayout) {\n                payoutDiff = payout - oldPayout;\n                _setDrawPayoutBalanceOf(_user, drawId, payout);\n            }\n\n            // helpfully short-circuit, in case the user screwed something up.\n            require(payoutDiff > 0, \"PrizeDistributor/zero-payout\");\n\n            totalPayout += payoutDiff;\n\n            emit ClaimedDraw(_user, drawId, payoutDiff);\n        }\n\n        _awardPayout(_user, totalPayout);\n\n        return totalPayout;\n    }\n\n    /// @inheritdoc IPrizeDistributor\n    function withdrawERC20(\n        IERC20 _erc20Token,\n        address _to,\n        uint256 _amount\n    ) external override onlyOwner returns (bool) {\n        require(_to != address(0), \"PrizeDistributor/recipient-not-zero-address\");\n        require(address(_erc20Token) != address(0), \"PrizeDistributor/ERC20-not-zero-address\");\n\n        _erc20Token.safeTransfer(_to, _amount);\n\n        emit ERC20Withdrawn(_erc20Token, _to, _amount);\n\n        return true;\n    }\n\n    /// @inheritdoc IPrizeDistributor\n    function getDrawCalculator() external view override returns (IDrawCalculator) {\n        return drawCalculator;\n    }\n\n    /// @inheritdoc IPrizeDistributor\n    function getDrawPayoutBalanceOf(address _user, uint32 _drawId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getDrawPayoutBalanceOf(_user, _drawId);\n    }\n\n    /// @inheritdoc IPrizeDistributor\n    function getToken() external view override returns (IERC20) {\n        return token;\n    }\n\n    /// @inheritdoc IPrizeDistributor\n    function setDrawCalculator(IDrawCalculator _newCalculator)\n        external\n        override\n        onlyOwner\n        returns (IDrawCalculator)\n    {\n        _setDrawCalculator(_newCalculator);\n        return _newCalculator;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _getDrawPayoutBalanceOf(address _user, uint32 _drawId)\n        internal\n        view\n        returns (uint256)\n    {\n        return userDrawPayouts[_user][_drawId];\n    }\n\n    function _setDrawPayoutBalanceOf(\n        address _user,\n        uint32 _drawId,\n        uint256 _payout\n    ) internal {\n        userDrawPayouts[_user][_drawId] = _payout;\n    }\n\n    /**\n     * @notice Sets DrawCalculator reference for individual draw id.\n     * @param _newCalculator  DrawCalculator address\n     */\n    function _setDrawCalculator(IDrawCalculator _newCalculator) internal {\n        require(address(_newCalculator) != address(0), \"PrizeDistributor/calc-not-zero\");\n        drawCalculator = _newCalculator;\n\n        emit DrawCalculatorSet(_newCalculator);\n    }\n\n    /**\n     * @notice Transfer claimed draw(s) total payout to user.\n     * @param _to      User address\n     * @param _amount  Transfer amount\n     */\n    function _awardPayout(address _to, uint256 _amount) internal {\n        token.safeTransfer(_to, _amount);\n    }\n\n}\nabstract contract PrizeSplit is IPrizeSplit, Ownable {\n    /* ============ Global Variables ============ */\n    PrizeSplitConfig[] internal _prizeSplits;\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IPrizeSplit\n    function getPrizeSplit(uint256 _prizeSplitIndex)\n        external\n        view\n        override\n        returns (PrizeSplitConfig memory)\n    {\n        return _prizeSplits[_prizeSplitIndex];\n    }\n\n    /// @inheritdoc IPrizeSplit\n    function getPrizeSplits() external view override returns (PrizeSplitConfig[] memory) {\n        return _prizeSplits;\n    }\n\n    /// @inheritdoc IPrizeSplit\n    function setPrizeSplits(PrizeSplitConfig[] calldata _newPrizeSplits)\n        external\n        override\n        onlyOwner\n    {\n        uint256 newPrizeSplitsLength = _newPrizeSplits.length;\n\n        // Add and/or update prize split configs using _newPrizeSplits PrizeSplitConfig structs array.\n        for (uint256 index = 0; index < newPrizeSplitsLength; index++) {\n            PrizeSplitConfig memory split = _newPrizeSplits[index];\n\n            // REVERT when setting the canonical burn address.\n            require(split.target != address(0), \"PrizeSplit/invalid-prizesplit-target\");\n\n            // IF the CURRENT prizeSplits length is below the NEW prizeSplits\n            // PUSH the PrizeSplit struct to end of the list.\n            if (_prizeSplits.length <= index) {\n                _prizeSplits.push(split);\n            } else {\n                // ELSE update an existing PrizeSplit struct with new parameters\n                PrizeSplitConfig memory currentSplit = _prizeSplits[index];\n\n                // IF new PrizeSplit DOES NOT match the current PrizeSplit\n                // WRITE to STORAGE with the new PrizeSplit\n                if (\n                    split.target != currentSplit.target ||\n                    split.percentage != currentSplit.percentage\n                ) {\n                    _prizeSplits[index] = split;\n                } else {\n                    continue;\n                }\n            }\n\n            // Emit the added/updated prize split config.\n            emit PrizeSplitSet(split.target, split.percentage, index);\n        }\n\n        // Remove old prize splits configs. Match storage _prizesSplits.length with the passed newPrizeSplits.length\n        while (_prizeSplits.length > newPrizeSplitsLength) {\n            uint256 _index = _prizeSplits.length - 1;\n            _prizeSplits.pop();\n            emit PrizeSplitRemoved(_index);\n        }\n\n        // Total prize split do not exceed 100%\n        uint256 totalPercentage = _totalPrizeSplitPercentageAmount();\n        require(totalPercentage <= 1000, \"PrizeSplit/invalid-prizesplit-percentage-total\");\n    }\n\n    /// @inheritdoc IPrizeSplit\n    function setPrizeSplit(PrizeSplitConfig memory _prizeSplit, uint8 _prizeSplitIndex)\n        external\n        override\n        onlyOwner\n    {\n        require(_prizeSplitIndex < _prizeSplits.length, \"PrizeSplit/nonexistent-prizesplit\");\n        require(_prizeSplit.target != address(0), \"PrizeSplit/invalid-prizesplit-target\");\n\n        // Update the prize split config\n        _prizeSplits[_prizeSplitIndex] = _prizeSplit;\n\n        // Total prize split do not exceed 100%\n        uint256 totalPercentage = _totalPrizeSplitPercentageAmount();\n        require(totalPercentage <= 1000, \"PrizeSplit/invalid-prizesplit-percentage-total\");\n\n        // Emit updated prize split config\n        emit PrizeSplitSet(\n            _prizeSplit.target,\n            _prizeSplit.percentage,\n            _prizeSplitIndex\n        );\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Calculate single prize split distribution amount.\n     * @dev Calculate single prize split distribution amount using the total prize amount and prize split percentage.\n     * @param _amount Total prize award distribution amount\n     * @param _percentage Percentage with single decimal precision using 0-1000 ranges\n     */\n    function _getPrizeSplitAmount(uint256 _amount, uint16 _percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_amount * _percentage) / 1000;\n    }\n\n    /**\n     * @notice Calculates total prize split percentage amount.\n     * @dev Calculates total PrizeSplitConfig percentage(s) amount. Used to check the total does not exceed 100% of award distribution.\n     * @return Total prize split(s) percentage amount\n     */\n    function _totalPrizeSplitPercentageAmount() internal view returns (uint256) {\n        uint256 _tempTotalPercentage;\n        uint256 prizeSplitsLength = _prizeSplits.length;\n\n        for (uint8 index = 0; index < prizeSplitsLength; index++) {\n            PrizeSplitConfig memory split = _prizeSplits[index];\n            _tempTotalPercentage = _tempTotalPercentage + split.percentage;\n        }\n\n        return _tempTotalPercentage;\n    }\n\n    /**\n     * @notice Distributes prize split(s).\n     * @dev Distributes prize split(s) by awarding ticket or sponsorship tokens.\n     * @param _prize Starting prize award amount\n     * @return Total prize award distribution amount exlcuding the awarded prize split(s)\n     */\n    function _distributePrizeSplits(uint256 _prize) internal returns (uint256) {\n        // Store temporary total prize amount for multiple calculations using initial prize amount.\n        uint256 _prizeTemp = _prize;\n        uint256 prizeSplitsLength = _prizeSplits.length;\n        for (uint256 index = 0; index < prizeSplitsLength; index++) {\n            PrizeSplitConfig memory split = _prizeSplits[index];\n            uint256 _splitAmount = _getPrizeSplitAmount(_prize, split.percentage);\n\n            // Award the prize split distribution amount.\n            _awardPrizeSplitAmount(split.target, _splitAmount);\n\n            // Update the remaining prize amount after distributing the prize split percentage.\n            _prizeTemp = _prizeTemp - _splitAmount;\n        }\n\n        return _prize;\n    }\n\n    /**\n     * @notice Mints ticket or sponsorship tokens to prize split recipient.\n     * @dev Mints ticket or sponsorship tokens to prize split recipient via the linked PrizePool contract.\n     * @param _target Recipient of minted tokens\n     * @param _amount Amount of minted tokens\n     */\n    function _awardPrizeSplitAmount(address _target, uint256 _amount) internal virtual;\n}\ncontract DrawCalculator is IDrawCalculator, Ownable {\n\n    /// @notice DrawBuffer address\n    IDrawBuffer public immutable drawBuffer;\n\n    /// @notice Ticket associated with DrawCalculator\n    ITicket public immutable ticket;\n\n    /// @notice The stored history of draw settings.  Stored as ring buffer.\n    IPrizeDistributionBuffer public immutable prizeDistributionBuffer;\n\n    /// @notice The tiers array length\n    uint8 public constant TIERS_LENGTH = 16;\n\n    /* ============ Constructor ============ */\n\n    /// @notice Constructor for DrawCalculator\n    /// @param _owner Address of the DrawCalculator owner\n    /// @param _ticket Ticket associated with this DrawCalculator\n    /// @param _drawBuffer The address of the draw buffer to push draws to\n    /// @param _prizeDistributionBuffer PrizeDistributionBuffer address\n    constructor(\n        address _owner,\n        ITicket _ticket,\n        IDrawBuffer _drawBuffer,\n        IPrizeDistributionBuffer _prizeDistributionBuffer\n    ) Ownable(_owner) {\n        require(address(_ticket) != address(0), \"DrawCalc/ticket-not-zero\");\n        require(address(_prizeDistributionBuffer) != address(0), \"DrawCalc/pdb-not-zero\");\n        require(address(_drawBuffer) != address(0), \"DrawCalc/dh-not-zero\");\n\n        ticket = _ticket;\n        drawBuffer = _drawBuffer;\n        prizeDistributionBuffer = _prizeDistributionBuffer;\n\n        emit Deployed(_ticket, _drawBuffer, _prizeDistributionBuffer);\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IDrawCalculator\n    function calculate(\n        address _user,\n        uint32[] calldata _drawIds,\n        bytes calldata _pickIndicesForDraws\n    ) external view override returns (uint256[] memory, bytes memory) {\n        uint64[][] memory pickIndices = abi.decode(_pickIndicesForDraws, (uint64 [][]));\n        require(pickIndices.length == _drawIds.length, \"DrawCalc/invalid-pick-indices-length\");\n\n        // READ list of IDrawBeacon.Draw using the drawIds from drawBuffer\n        IDrawBeacon.Draw[] memory draws = drawBuffer.getDraws(_drawIds);\n\n        // READ list of IPrizeDistributionBuffer.PrizeDistribution using the drawIds\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = prizeDistributionBuffer\n            .getPrizeDistributions(_drawIds);\n\n        // The userBalances are fractions representing their portion of the liquidity for a draw.\n        uint256[] memory userBalances = _getNormalizedBalancesAt(_user, draws, _prizeDistributions);\n\n        // The users address is hashed once.\n        bytes32 _userRandomNumber = keccak256(abi.encodePacked(_user));\n\n        return _calculatePrizesAwardable(\n                userBalances,\n                _userRandomNumber,\n                draws,\n                pickIndices,\n                _prizeDistributions\n            );\n    }\n\n    /// @inheritdoc IDrawCalculator\n    function getDrawBuffer() external view override returns (IDrawBuffer) {\n        return drawBuffer;\n    }\n\n    /// @inheritdoc IDrawCalculator\n    function getPrizeDistributionBuffer()\n        external\n        view\n        override\n        returns (IPrizeDistributionBuffer)\n    {\n        return prizeDistributionBuffer;\n    }\n\n    /// @inheritdoc IDrawCalculator\n    function getNormalizedBalancesForDrawIds(address _user, uint32[] calldata _drawIds)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        IDrawBeacon.Draw[] memory _draws = drawBuffer.getDraws(_drawIds);\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = prizeDistributionBuffer\n            .getPrizeDistributions(_drawIds);\n\n        return _getNormalizedBalancesAt(_user, _draws, _prizeDistributions);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Calculates the prizes awardable for each Draw passed.\n     * @param _normalizedUserBalances Fractions representing the user's portion of the liquidity for each draw.\n     * @param _userRandomNumber       Random number of the user to consider over draws\n     * @param _draws                  List of Draws\n     * @param _pickIndicesForDraws    Pick indices for each Draw\n     * @param _prizeDistributions     PrizeDistribution for each Draw\n\n     */\n    function _calculatePrizesAwardable(\n        uint256[] memory _normalizedUserBalances,\n        bytes32 _userRandomNumber,\n        IDrawBeacon.Draw[] memory _draws,\n        uint64[][] memory _pickIndicesForDraws,\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions\n    ) internal pure returns (uint256[] memory prizesAwardable, bytes memory prizeCounts) {\n        \n        uint256[] memory _prizesAwardable = new uint256[](_normalizedUserBalances.length);\n        uint256[][] memory _prizeCounts = new uint256[][](_normalizedUserBalances.length);\n\n        // calculate prizes awardable for each Draw passed\n        for (uint32 drawIndex = 0; drawIndex < _draws.length; drawIndex++) {\n            uint64 totalUserPicks = _calculateNumberOfUserPicks(\n                _prizeDistributions[drawIndex],\n                _normalizedUserBalances[drawIndex]\n            );\n\n            (_prizesAwardable[drawIndex], _prizeCounts[drawIndex]) = _calculate(\n                _draws[drawIndex].winningRandomNumber,\n                totalUserPicks,\n                _userRandomNumber,\n                _pickIndicesForDraws[drawIndex],\n                _prizeDistributions[drawIndex]\n            );\n        }\n        prizeCounts = abi.encode(_prizeCounts);\n        prizesAwardable = _prizesAwardable;\n    }\n\n    /**\n     * @notice Calculates the number of picks a user gets for a Draw, considering the normalized user balance and the PrizeDistribution.\n     * @dev Divided by 1e18 since the normalized user balance is stored as a fixed point 18 number\n     * @param _prizeDistribution The PrizeDistribution to consider\n     * @param _normalizedUserBalance The normalized user balances to consider\n     * @return The number of picks a user gets for a Draw\n     */\n    function _calculateNumberOfUserPicks(\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,\n        uint256 _normalizedUserBalance\n    ) internal pure returns (uint64) {\n        return uint64((_normalizedUserBalance * _prizeDistribution.numberOfPicks) / 1 ether);\n    }\n\n    /**\n     * @notice Calculates the normalized balance of a user against the total supply for timestamps\n     * @param _user The user to consider\n     * @param _draws The draws we are looking at\n     * @param _prizeDistributions The prize tiers to consider (needed for draw timestamp offsets)\n     * @return An array of normalized balances\n     */\n    function _getNormalizedBalancesAt(\n        address _user,\n        IDrawBeacon.Draw[] memory _draws,\n        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions\n    ) internal view returns (uint256[] memory) {\n        uint64[] memory _timestampsWithStartCutoffTimes = new uint64[](_draws.length);\n        uint64[] memory _timestampsWithEndCutoffTimes = new uint64[](_draws.length);\n\n        // generate timestamps with draw cutoff offsets included\n        for (uint32 i = 0; i < _draws.length; i++) {\n            unchecked {\n                _timestampsWithStartCutoffTimes[i] =\n                    _draws[i].timestamp - _prizeDistributions[i].startTimestampOffset;\n                _timestampsWithEndCutoffTimes[i] =\n                    _draws[i].timestamp - _prizeDistributions[i].endTimestampOffset;\n            }\n        }\n\n        uint256[] memory balances = ticket.getAverageBalancesBetween(\n            _user,\n            _timestampsWithStartCutoffTimes,\n            _timestampsWithEndCutoffTimes\n        );\n\n        uint256[] memory totalSupplies = ticket.getAverageTotalSuppliesBetween(\n            _timestampsWithStartCutoffTimes,\n            _timestampsWithEndCutoffTimes\n        );\n\n        uint256[] memory normalizedBalances = new uint256[](_draws.length);\n\n        // divide balances by total supplies (normalize)\n        for (uint256 i = 0; i < _draws.length; i++) {\n            require(totalSupplies[i] > 0, \"DrawCalc/total-supply-zero\");\n            normalizedBalances[i] = (balances[i] * 1 ether) / totalSupplies[i];\n        }\n\n        return normalizedBalances;\n    }\n\n    /**\n     * @notice Calculates the prize amount for a PrizeDistribution over given picks\n     * @param _winningRandomNumber Draw's winningRandomNumber\n     * @param _totalUserPicks      number of picks the user gets for the Draw\n     * @param _userRandomNumber    users randomNumber for that draw\n     * @param _picks               users picks for that draw\n     * @param _prizeDistribution   PrizeDistribution for that draw\n     * @return prize (if any), prizeCounts (if any)\n     */\n    function _calculate(\n        uint256 _winningRandomNumber,\n        uint256 _totalUserPicks,\n        bytes32 _userRandomNumber,\n        uint64[] memory _picks,\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution\n    ) internal pure returns (uint256 prize, uint256[] memory prizeCounts) {\n        \n        // create bitmasks for the PrizeDistribution\n        uint256[] memory masks = _createBitMasks(_prizeDistribution);\n        uint32 picksLength = uint32(_picks.length);\n        uint256[] memory _prizeCounts = new uint256[](_prizeDistribution.tiers.length);\n\n        uint8 maxWinningTierIndex = 0;\n\n        require(\n            picksLength <= _prizeDistribution.maxPicksPerUser,\n            \"DrawCalc/exceeds-max-user-picks\"\n        );\n\n        // for each pick, find number of matching numbers and calculate prize distributions index\n        for (uint32 index = 0; index < picksLength; index++) {\n            require(_picks[index] < _totalUserPicks, \"DrawCalc/insufficient-user-picks\");\n\n            if (index > 0) {\n                require(_picks[index] > _picks[index - 1], \"DrawCalc/picks-ascending\");\n            }\n\n            // hash the user random number with the pick value\n            uint256 randomNumberThisPick = uint256(\n                keccak256(abi.encode(_userRandomNumber, _picks[index]))\n            );\n\n            uint8 tiersIndex = _calculateTierIndex(\n                randomNumberThisPick,\n                _winningRandomNumber,\n                masks\n            );\n\n            // there is prize for this tier index\n            if (tiersIndex < TIERS_LENGTH) {\n                if (tiersIndex > maxWinningTierIndex) {\n                    maxWinningTierIndex = tiersIndex;\n                }\n                _prizeCounts[tiersIndex]++;\n            }\n        }\n\n        // now calculate prizeFraction given prizeCounts\n        uint256 prizeFraction = 0;\n        uint256[] memory prizeTiersFractions = _calculatePrizeTierFractions(\n            _prizeDistribution,\n            maxWinningTierIndex\n        );\n\n        // multiple the fractions by the prizeCounts and add them up\n        for (\n            uint256 prizeCountIndex = 0;\n            prizeCountIndex <= maxWinningTierIndex;\n            prizeCountIndex++\n        ) {\n            if (_prizeCounts[prizeCountIndex] > 0) {\n                prizeFraction +=\n                    prizeTiersFractions[prizeCountIndex] *\n                    _prizeCounts[prizeCountIndex];\n            }\n        }\n\n        // return the absolute amount of prize awardable\n        // div by 1e9 as prize tiers are base 1e9\n        prize = (prizeFraction * _prizeDistribution.prize) / 1e9; \n        prizeCounts = _prizeCounts;\n    }\n\n    ///@notice Calculates the tier index given the random numbers and masks\n    ///@param _randomNumberThisPick users random number for this Pick\n    ///@param _winningRandomNumber The winning number for this draw\n    ///@param _masks The pre-calculate bitmasks for the prizeDistributions\n    ///@return The position within the prize tier array (0 = top prize, 1 = runner-up prize, etc)\n    function _calculateTierIndex(\n        uint256 _randomNumberThisPick,\n        uint256 _winningRandomNumber,\n        uint256[] memory _masks\n    ) internal pure returns (uint8) {\n        uint8 numberOfMatches = 0;\n        uint8 masksLength = uint8(_masks.length);\n\n        // main number matching loop\n        for (uint8 matchIndex = 0; matchIndex < masksLength; matchIndex++) {\n            uint256 mask = _masks[matchIndex];\n\n            if ((_randomNumberThisPick & mask) != (_winningRandomNumber & mask)) {\n                // there are no more sequential matches since this comparison is not a match\n                return masksLength - numberOfMatches;\n            }\n\n            // else there was a match\n            numberOfMatches++;\n        }\n\n        return masksLength - numberOfMatches;\n    }\n\n    /**\n     * @notice Create an array of bitmasks equal to the PrizeDistribution.matchCardinality length\n     * @param _prizeDistribution The PrizeDistribution to use to calculate the masks\n     * @return An array of bitmasks\n     */\n    function _createBitMasks(IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory masks = new uint256[](_prizeDistribution.matchCardinality);\n        uint256 _bitRangeMaskValue = (2**_prizeDistribution.bitRangeSize) - 1; // get a decimal representation of bitRangeSize\n\n        for (uint8 maskIndex = 0; maskIndex < _prizeDistribution.matchCardinality; maskIndex++) {\n            // create mask of width bitRangeSize bits at index\n            uint256 _matchIndexOffset = uint256(maskIndex) * uint256(_prizeDistribution.bitRangeSize);\n            // shift mask bits to correct position and insert in result mask array\n            masks[maskIndex] = _bitRangeMaskValue << _matchIndexOffset;\n        }\n\n        return masks;\n    }\n\n    /**\n     * @notice Calculates the expected prize fraction per PrizeDistributions and distributionIndex\n     * @param _prizeDistribution prizeDistribution struct for Draw\n     * @param _prizeTierIndex Index of the prize tiers array to calculate\n     * @return returns the fraction of the total prize (base 1e18)\n     */\n    function _calculatePrizeTierFraction(\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,\n        uint256 _prizeTierIndex\n    ) internal pure returns (uint256) {\n         // get the prize fraction at that index\n        uint256 prizeFraction = _prizeDistribution.tiers[_prizeTierIndex];\n\n        // calculate number of prizes for that index\n        uint256 numberOfPrizesForIndex = _numberOfPrizesForIndex(\n            _prizeDistribution.bitRangeSize,\n            _prizeTierIndex\n        );\n\n        return prizeFraction / numberOfPrizesForIndex;\n    }\n\n    /**\n     * @notice Generates an array of prize tiers fractions\n     * @param _prizeDistribution prizeDistribution struct for Draw\n     * @param maxWinningTierIndex Max length of the prize tiers array\n     * @return returns an array of prize tiers fractions\n     */\n    function _calculatePrizeTierFractions(\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,\n        uint8 maxWinningTierIndex\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory prizeDistributionFractions = new uint256[](\n            maxWinningTierIndex + 1\n        );\n\n        for (uint8 i = 0; i <= maxWinningTierIndex; i++) {\n            prizeDistributionFractions[i] = _calculatePrizeTierFraction(\n                _prizeDistribution,\n                i\n            );\n        }\n\n        return prizeDistributionFractions;\n    }\n\n    /**\n     * @notice Calculates the number of prizes for a given prizeDistributionIndex\n     * @param _bitRangeSize Bit range size for Draw\n     * @param _prizeTierIndex Index of the prize tier array to calculate\n     * @return returns the fraction of the total prize (base 1e18)\n     */\n    function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);\n        uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;\n\n        while (_prizeTierIndex > 0) {\n            numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);\n            _prizeTierIndex--;\n        }\n\n        return numberOfPrizesForIndex;\n    }\n}\n",
    "bin": []
}