{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/45",
    "external_functions": [
        [
            "UToken",
            "IBeaconUpgradeable",
            "IInterestRateModel",
            "IUErc20",
            "IUserManager",
            "IAssetManager"
        ],
        [
            "UserManager",
            "IBeaconUpgradeable",
            "ICreditLimitModel",
            "IUToken",
            "IUnionToken",
            "IAssetManager",
            "IComptroller",
            "IERC20Upgradeable",
            "IDai"
        ]
    ],
    "new_contract": "contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Member {\n        bool isMember;\n        CreditLine creditLine;\n    }\n\n    //address: member address, uint256: trustAmount\n    struct CreditLine {\n        mapping(address => uint256) borrowers;\n        address[] borrowerAddresses;\n        mapping(address => uint256) stakers;\n        address[] stakerAddresses;\n        mapping(address => uint256) lockedAmount;\n    }\n\n    struct TrustInfo {\n        address[] stakerAddresses;\n        address[] borrowerAddresses;\n        uint256 effectiveCount;\n        address staker;\n        uint256 vouchingAmount;\n        uint256 stakingAmount;\n        uint256 availableStakingAmount;\n        uint256 lockedStake;\n        uint256 totalLockedStake;\n    }\n\n    uint256 public constant MAX_TRUST_LIMIT = 100;\n    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;\n    address public stakingToken;\n    address public unionToken;\n    address public assetManager;\n    IUToken public uToken;\n    ICreditLimitModel public creditLimitModel;\n    IComptroller public comptroller;\n    uint256 public newMemberFee; // New member application fee\n\n    // slither-disable-next-line constable-states\n    uint256 public override totalStaked;\n    // slither-disable-next-line constable-states\n    uint256 public override totalFrozen;\n    mapping(address => Member) private members;\n    // slither-disable-next-line uninitialized-state\n    mapping(address => uint256) public stakers; //1 user address 2 amount\n    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount\n\n    modifier onlyMember(address account) {\n        require(checkIsMember(account), \"UserManager: caller does not have the Member role\");\n        _;\n    }\n\n    modifier onlyMarketOrAdmin() {\n        require(\n            address(uToken) == msg.sender || isAdmin(msg.sender),\n            \"UserManager: caller does not the market or admin\"\n        );\n        _;\n    }\n\n    /**\n     *  @dev Update new credit limit model event\n     *  @param newCreditLimitModel New credit limit model address\n     */\n    event LogNewCreditLimitModel(address newCreditLimitModel);\n\n    /**\n     *  @dev Add new member event\n     *  @param member New member address\n     */\n    event LogAddMember(address member);\n\n    /**\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /**\n     *  @dev New member application event\n     *  @param account New member's voucher address\n     *  @param borrower New member address\n     */\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Cancel vouching for other member event\n     *  @param account New member's voucher address\n     *  @param borrower The address gets vouched for\n     */\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Stake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev Unstake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to unstake\n     */\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev DebtWriteOff event\n     *  @param staker The staker's address\n     *  @param borrower The borrower's address\n     *  @param amount The amount of write off\n     */\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address creditLimitModel_,\n        address comptroller_,\n        address admin_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        _setCreditLimitModel(creditLimitModel_);\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 10**18; // Set the default membership fee\n    }\n\n    function setUToken(address uToken_) public onlyAdmin {\n        uToken = IUToken(uToken_);\n    }\n\n    function setNewMemberFee(uint256 amount) public onlyAdmin {\n        newMemberFee = amount;\n    }\n\n    /**\n     *  @dev Change the credit limit model\n     *  Accept claims only from the admin\n     *  @param newCreditLimitModel New credit limit model address\n     */\n    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {\n        _setCreditLimitModel(newCreditLimitModel);\n    }\n\n    function _setCreditLimitModel(address newCreditLimitModel) private {\n        require(\n            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),\n            \"MemberMnager: new model is not a creditLimitModel\"\n        );\n        creditLimitModel = ICreditLimitModel(newCreditLimitModel);\n\n        emit LogNewCreditLimitModel(newCreditLimitModel);\n    }\n\n    /**\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     */\n    function checkIsMember(address account) public view override returns (bool) {\n        return members[account].isMember;\n    }\n\n    /**\n     *  @dev Get member borrowerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getBorrowerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.borrowerAddresses;\n    }\n\n    /**\n     *  @dev Get member stakerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getStakerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.stakerAddresses;\n    }\n\n    /**\n     *  @dev Get member backer asset\n     *  @param account Member address\n     *  @param borrower Borrower address\n     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount\n     */\n    function getBorrowerAsset(address account, address borrower)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.borrowers[borrower];\n        lockedStake = getLockedStake(account, borrower);\n        vouchingAmount = getVouchingAmount(account, borrower);\n    }\n\n    /**\n     *  @dev Get member stakers asset\n     *  @param account Member address\n     *  @param staker Staker address\n     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake\n     */\n    function getStakerAsset(address account, address staker)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.stakers[staker];\n        lockedStake = getLockedStake(staker, account);\n        vouchingAmount = getVouchingAmount(staker, account);\n    }\n\n    /**\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     */\n    function getLockedStake(address staker, address borrower) public view returns (uint256) {\n        return members[staker].creditLine.lockedAmount[borrower];\n    }\n\n    /**\n     *  @dev Get the user's locked stake from all his backed loans\n     *  @param staker Staker address\n     *  @return LockedStake\n     */\n    function getTotalLockedStake(address staker) public view override returns (uint256) {\n        uint256 totalLockedStake = 0;\n        uint256 stakingAmount = stakers[staker];\n        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        address borrower;\n        for (uint256 i = 0; i < borrowerAddresses.length; i++) {\n            borrower = borrowerAddresses[i];\n            totalLockedStake += getLockedStake(staker, borrower);\n        }\n\n        if (stakingAmount >= totalLockedStake) {\n            return totalLockedStake;\n        } else {\n            return stakingAmount;\n        }\n    }\n\n    /**\n     *  @dev Get staker's defaulted / frozen staked token amount\n     *  @param staker Staker address\n     *  @return Frozen token amount\n     */\n    function getTotalFrozenAmount(address staker) public view override returns (uint256) {\n        TrustInfo memory trustInfo;\n        uint256 totalFrozenAmount = 0;\n        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        trustInfo.stakingAmount = stakers[staker];\n\n        address borrower;\n        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {\n            borrower = trustInfo.borrowerAddresses[i];\n            if (uToken.checkIsOverdue(borrower)) {\n                totalFrozenAmount += getLockedStake(staker, borrower);\n            }\n        }\n\n        if (trustInfo.stakingAmount >= totalFrozenAmount) {\n            return totalFrozenAmount;\n        } else {\n            return trustInfo.stakingAmount;\n        }\n    }\n\n    /**\n     *  @dev Get the member's available credit line\n     *  @param borrower Member address\n     *  @return Credit line amount\n     */\n    function getCreditLimit(address borrower) public view override returns (int256) {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        // Get the number of effective vouchee, first\n        trustInfo.effectiveCount = 0;\n        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);\n\n        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit\n            if (trustInfo.vouchingAmount > 0) {\n                //availableStakingAmount is staker\u2018s free stake amount\n                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);\n\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount;\n                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);\n                if (trustInfo.stakingAmount <= totalLockedStake) {\n                    trustInfo.availableStakingAmount = 0;\n                } else {\n                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;\n                }\n\n                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n\n                require(\n                    trustInfo.vouchingAmount >= trustInfo.lockedStake,\n                    \"UserManager: vouchingAmount or lockedStake data error\"\n                );\n\n                //The actual effective guarantee amount cannot exceed availableStakingAmount,\n                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {\n                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;\n                } else {\n                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {\n                        limits[trustInfo.effectiveCount] = 0;\n                    } else {\n                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;\n                    }\n                }\n                trustInfo.effectiveCount += 1;\n            }\n        }\n\n        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);\n        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {\n            creditlimits[j] = limits[j];\n        }\n\n        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));\n    }\n\n    /**\n     *  @dev Get vouching amount\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     */\n    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {\n        uint256 totalStake = stakers[staker];\n        uint256 trustAmount = members[borrower].creditLine.stakers[staker];\n        if (trustAmount > totalStake) {\n            return totalStake;\n        } else {\n            return trustAmount;\n        }\n    }\n\n    /**\n     *  @dev Get the user's deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) public view override returns (uint256) {\n        return stakers[account];\n    }\n\n    /**\n     *  @dev Add member\n     *  Accept claims only from the admin\n     *  @param account Member address\n     */\n    function addMember(address account) public override onlyAdmin {\n        require(!checkIsMember(account), \"UserManager: address is already member\");\n        members[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /**\n     *  @dev Update the trust amount for exisitng members.\n     *  @param borrower_ Account address\n     *  @param trustAmount Trust amount\n     */\n    function updateTrust(address borrower_, uint256 trustAmount)\n        external\n        override\n        onlyMember(msg.sender)\n        whenNotPaused\n    {\n        require(borrower_ != address(0), \"borrower cannot be zero\");\n        address borrower = borrower_;\n\n        TrustInfo memory trustInfo;\n        trustInfo.staker = msg.sender;\n        require(trustInfo.staker != borrower, \"UserManager: Can't vouch for self\");\n        require(\n            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&\n                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,\n            \"UserManager: trust reach limit\"\n        );\n        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n        require(\n            trustAmount >= trustInfo.lockedStake,\n            \"UserManager: trust amount cannot be less than the locked amount \"\n        );\n        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        for (uint256 i = 0; i < borrowerCount; i++) {\n            if (trustInfo.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n            }\n        }\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        for (uint256 i = 0; i < stakerCount; i++) {\n            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {\n                stakerExist = true;\n            }\n        }\n\n        if (!borrowerExist) {\n            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);\n        }\n\n        if (!stakerExist) {\n            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);\n        }\n\n        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;\n        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;\n        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);\n    }\n\n    /**\n     *  @dev Stop vouch for other member.\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {\n        require(\n            msg.sender == staker || msg.sender == borrower,\n            \"UserManager: Accept claims only from the staker or borrower\"\n        );\n\n        require(getLockedStake(staker, borrower) == 0, \"UserManager: LockedStake is not zero\");\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        uint256 stakerIndex = 0;\n        for (uint256 i = 0; i < stakerCount; i++) {\n            if (members[borrower].creditLine.stakerAddresses[i] == staker) {\n                stakerExist = true;\n                stakerIndex = i;\n            }\n        }\n\n        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        uint256 borrowerIndex = 0;\n        for (uint256 i = 0; i < borrowerCount; i++) {\n            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n                borrowerIndex = i;\n            }\n        }\n\n        //delete address\n        if (borrowerExist) {\n            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[\n                borrowerCount - 1\n            ];\n            members[staker].creditLine.borrowerAddresses.pop();\n        }\n\n        if (stakerExist) {\n            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[\n                stakerCount - 1\n            ];\n            members[borrower].creditLine.stakerAddresses.pop();\n        }\n\n        delete members[staker].creditLine.borrowers[borrower];\n        delete members[borrower].creditLine.stakers[staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /**\n     *  @dev Apply for membership, and burn UnionToken as application fees\n     *  @param newMember New member address\n     */\n    function registerMember(address newMember) public override whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        require(!checkIsMember(newMember), \"UserManager: address is already member\");\n        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, \"UserManager: balance not enough\");\n\n        uint256 effectiveStakerNumber = 0;\n        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {\n            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];\n            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)\n                effectiveStakerNumber += 1;\n        }\n\n        require(\n            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),\n            \"UserManager: not enough effective stakers\"\n        );\n\n        members[newMember].isMember = true;\n\n        unionTokenContract.burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    function updateLockedData(\n        address borrower,\n        uint256 amount,\n        bool isBorrow\n    ) external override onlyMarketOrAdmin {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n\n        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](\n            trustInfo.stakerAddresses.length\n        );\n\n        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {\n            ICreditLimitModel.LockedInfo memory lockedInfo;\n\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);\n            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {\n                trustInfo.availableStakingAmount = 0;\n            } else {\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;\n            }\n\n            lockedInfo.staker = trustInfo.staker;\n            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;\n            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);\n            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;\n\n            lockedInfoList[i] = lockedInfo;\n        }\n\n        for (uint256 i = 0; i < lockedInfoList.length; i++) {\n            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(\n                lockedInfoList,\n                lockedInfoList[i].staker,\n                amount,\n                isBorrow\n            );\n        }\n    }\n\n    /**\n     *  @dev Stake\n     *  @param amount Amount\n     */\n    function stake(uint256 amount) public override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 balance = stakers[msg.sender];\n\n        require(balance + amount <= MAX_STAKE_AMOUNT, \"UserManager: Stake limit hit\");\n\n        stakers[msg.sender] = balance + amount;\n        totalStaked += amount;\n\n        require(\n            erc20Token.allowance(msg.sender, address(this)) >= amount,\n            \"UserManager: not enough allowance to stake\"\n        );\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        require(IAssetManager(assetManager).deposit(stakingToken, amount), \"UserManager: Deposit failed\");\n\n        emit LogStake(msg.sender, amount);\n    }\n\n    /**\n     *  @dev stakeWithPermit\n     *  @param amount Amount\n     */\n    function stakeWithPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IDai erc20Token = IDai(stakingToken);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        stake(amount);\n    }\n\n    /**\n     *  @dev Unstake\n     *  @param amount Amount\n     */\n    function unstake(uint256 amount) external override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n        uint256 stakingAmount = stakers[msg.sender];\n        require(\n            stakingAmount - getTotalLockedStake(msg.sender) >= amount,\n            \"UserManager: unstake balance is insufficient\"\n        );\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        stakers[msg.sender] = stakingAmount - amount;\n        totalStaked -= amount;\n\n        require(\n            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),\n            \"UserManager: withdraw failed\"\n        );\n\n        erc20Token.safeTransfer(msg.sender, amount);\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);\n        require(rewards > 0, \"UserManager: not enough rewards\");\n    }\n\n    /**\n     *  @dev Repay user's loan overdue, called only from the lending market\n     *  @param account User address\n     *  @param token The asset token repaying to\n     *  @param lastRepay Last repay block number\n     */\n    function repayLoanOverdue(\n        address account,\n        address token,\n        uint256 lastRepay\n    ) external override whenNotPaused onlyMarketOrAdmin {\n        address[] memory stakerAddresses = getStakerAddresses(account);\n        for (uint256 i = 0; i < stakerAddresses.length; i++) {\n            address staker = stakerAddresses[i];\n            (, , uint256 lockedStake) = getStakerAsset(account, staker);\n\n            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);\n        }\n    }\n\n    //Only supports sumOfTrust\n    function debtWriteOff(address borrower, uint256 amount) public {\n        require(amount > 0, \"UserManager: amount can not be zero\");\n        require(totalStaked >= amount, \"UserManager: amount exceeds the totalStaked\");\n        require(uToken.checkIsOverdue(borrower), \"UserManager: only call when borrower is overdue\");\n        uint256 lockedAmount = getLockedStake(msg.sender, borrower);\n        require(lockedAmount >= amount, \"UserManager: amount exceeds the locked amount\");\n\n        _updateTotalFrozen(borrower, true);\n        require(totalFrozen >= amount, \"UserManager: amount exceeds the totalFrozen\");\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge\n\n        stakers[msg.sender] -= amount;\n        totalStaked -= amount;\n        totalFrozen -= amount;\n        if (memberFrozen[borrower] >= amount) {\n            memberFrozen[borrower] -= amount;\n        } else {\n            memberFrozen[borrower] = 0;\n        }\n        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;\n        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];\n        uint256 newTrustAmount = trustAmount - amount;\n        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;\n        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;\n        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);\n        uToken.debtWriteOff(borrower, amount);\n        emit LogDebtWriteOff(msg.sender, borrower, amount);\n    }\n\n    /**\n     *  @dev Update total frozen\n     *  @param account borrower address\n     *  @param isOverdue account is overdue\n     */\n    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {\n        require(totalStaked >= totalFrozen, \"UserManager: total stake amount error\");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        _updateTotalFrozen(account, isOverdue);\n    }\n\n    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)\n        external\n        override\n        onlyMarketOrAdmin\n        whenNotPaused\n    {\n        require(accounts.length == isOverdues.length, \"UserManager: params length error\");\n        require(totalStaked >= totalFrozen, \"UserManager: total stake amount error\");\n        uint256 effectiveTotalStaked = totalStaked - totalFrozen;\n        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);\n        for (uint256 i = 0; i < accounts.length; i++) {\n            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);\n        }\n    }\n\n    function _updateTotalFrozen(address account, bool isOverdue) private {\n        if (isOverdue) {\n            //isOverdue = true, user overdue needs to increase totalFrozen\n\n            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated\n            uint256 amount;\n            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {\n                address staker = members[account].creditLine.stakerAddresses[i];\n                uint256 lockedStake = getLockedStake(staker, account);\n                amount += lockedStake;\n            }\n\n            if (memberFrozen[account] == 0) {\n                //I haven\u2019t updated the frozen amount about this borrower before, just increase the amount directly\n                totalFrozen += amount;\n            } else {\n                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.\n                totalFrozen = totalFrozen + amount - memberFrozen[account];\n            }\n            //Record the increased value of this borrower this time\n            memberFrozen[account] = amount;\n        } else {\n            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal\n            if (totalFrozen > memberFrozen[account]) {\n                //Minus the frozen amount added last time\n                totalFrozen -= memberFrozen[account];\n            } else {\n                totalFrozen = 0;\n            }\n            memberFrozen[account] = 0;\n        }\n    }\n\n    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i < borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks >= blocks) {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);\n                } else {\n                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n\n    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {\n        uint256 totalFrozenCoinAge = 0;\n\n        address[] memory borrowerAddresses = getBorrowerAddresses(staker);\n\n        for (uint256 i = 0; i < borrowerAddresses.length; i++) {\n            address borrower = borrowerAddresses[i];\n            uint256 blocks = block.number - uToken.getLastRepay(borrower);\n            if (uToken.checkIsOverdue(borrower)) {\n                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);\n\n                if (pastBlocks >= blocks) {\n                    totalFrozenCoinAge += lockedStake * blocks;\n                } else {\n                    totalFrozenCoinAge += lockedStake * pastBlocks;\n                }\n            }\n        }\n\n        return totalFrozenCoinAge;\n    }\n}\ncontract UToken is Controller, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IUErc20;\n\n    bool public constant IS_UTOKEN = true;\n    uint256 public constant WAD = 1e18;\n    uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.0005e16; //Maximum borrow rate that can ever be applied (.0005% / block)\n    uint256 internal constant RESERVE_FACTORY_MAX_MANTISSA = 1e18; //Maximum fraction of interest that can be set aside for reserves\n\n    address public underlying;\n    IInterestRateModel public interestRateModel;\n    uint256 internal initialExchangeRateMantissa; //Initial exchange rate used when minting the first UTokens (used when totalSupply = 0)\n    uint256 public reserveFactorMantissa; //Fraction of interest currently set aside for reserves\n    uint256 public accrualBlockNumber; //Block number that interest was last accrued at\n    uint256 public borrowIndex; //Accumulator of the total earned interest rate since the opening of the market\n    uint256 public totalBorrows; //Total amount of outstanding borrows of the underlying in this market\n    uint256 public totalReserves; //Total amount of reserves of the underlying held in this marke\n    uint256 public totalRedeemable; //Calculates the exchange rate from the underlying to the uToken\n    uint256 public overdueBlocks; //overdue duration, based on the number of blocks\n    uint256 public originationFee;\n    uint256 public debtCeiling; //The debt limit for the whole system\n    uint256 public maxBorrow;\n    uint256 public minBorrow;\n    address public assetManager;\n    address public userManager;\n    IUErc20 public uErc20;\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interest;\n        uint256 interestIndex;\n        uint256 lastRepay; //Calculate if it is overdue\n    }\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /**\n     *  @dev Change of the interest rate model\n     *  @param oldInterestRateModel Old interest rate model address\n     *  @param newInterestRateModel New interest rate model address\n     */\n    event LogNewMarketInterestRateModel(address oldInterestRateModel, address newInterestRateModel);\n\n    event LogMint(address minter, uint256 underlyingAmount, uint256 uTokenAmount);\n\n    event LogRedeem(address redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn, uint256 redeemAmount);\n\n    event LogReservesAdded(address reserver, uint256 actualAddAmount, uint256 totalReservesNew);\n\n    event LogReservesReduced(address receiver, uint256 reduceAmount, uint256 totalReservesNew);\n\n    /**\n     *  @dev Event borrow\n     *  @param account Member address\n     *  @param amount Borrow amount\n     *  @param fee Origination fee\n     */\n    event LogBorrow(address indexed account, uint256 amount, uint256 fee);\n\n    /**\n     *  @dev Event repay\n     *  @param account Member address\n     *  @param amount Repay amount\n     */\n    event LogRepay(address indexed account, uint256 amount);\n\n    /**\n     *  @dev modifier limit member\n     */\n    modifier onlyMember(address account) {\n        require(IUserManager(userManager).checkIsMember(account), \"UToken: caller is not a member\");\n        _;\n    }\n\n    modifier onlyAssetManager() {\n        require(msg.sender == assetManager, \"UToken: caller is not assetManager\");\n        _;\n    }\n\n    modifier onlyUserManager() {\n        require(msg.sender == userManager, \"UToken: caller is not userManager\");\n        _;\n    }\n\n    function __UToken_init(\n        IUErc20 uErc20_,\n        address underlying_,\n        uint256 initialExchangeRateMantissa_,\n        uint256 reserveFactorMantissa_,\n        uint256 originationFee_,\n        uint256 debtCeiling_,\n        uint256 maxBorrow_,\n        uint256 minBorrow_,\n        uint256 overdueBlocks_,\n        address admin_\n    ) public initializer {\n        require(initialExchangeRateMantissa_ > 0, \"initial exchange rate must be greater than zero.\");\n        require(address(underlying_) != address(0), \"underlying token is zero\");\n        require(\n            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,\n            \"reserveFactorMantissa error\"\n        );\n        uErc20 = uErc20_;\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        underlying = underlying_;\n        originationFee = originationFee_;\n        debtCeiling = debtCeiling_;\n        maxBorrow = maxBorrow_;\n        minBorrow = minBorrow_;\n        overdueBlocks = overdueBlocks_;\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        reserveFactorMantissa = reserveFactorMantissa_;\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = WAD;\n    }\n\n    function setAssetManager(address assetManager_) external onlyAdmin {\n        assetManager = assetManager_;\n    }\n\n    function setUserManager(address userManager_) external onlyAdmin {\n        userManager = userManager_;\n    }\n\n    /**\n     *  @dev Change loan origination fee value\n     *  Accept claims only from the admin\n     *  @param originationFee_ Fees deducted for each loan transaction\n     */\n    function setOriginationFee(uint256 originationFee_) external onlyAdmin {\n        originationFee = originationFee_;\n    }\n\n    /**\n     *  @dev Update the market debt ceiling to a fixed amount, for example, 1 billion DAI etc.\n     *  Accept claims only from the admin\n     *  @param debtCeiling_ The debt limit for the whole system\n     */\n    function setDebtCeiling(uint256 debtCeiling_) external onlyAdmin {\n        debtCeiling = debtCeiling_;\n    }\n\n    /**\n     *  @dev Update the minimum loan size\n     *  Accept claims only from the admin\n     *  @param minBorrow_ Minimum loan amount per user\n     */\n    function setMinBorrow(uint256 minBorrow_) external onlyAdmin {\n        minBorrow = minBorrow_;\n    }\n\n    /**\n     *  @dev Update the max loan size\n     *  Accept claims only from the admin\n     *  @param maxBorrow_ Max loan amount per user\n     */\n    function setMaxBorrow(uint256 maxBorrow_) external onlyAdmin {\n        maxBorrow = maxBorrow_;\n    }\n\n    /**\n     *  @dev Change loan overdue duration, based on the number of blocks\n     *  Accept claims only from the admin\n     *  @param overdueBlocks_ Maximum late repayment block. The number of arrivals is a default\n     */\n    function setOverdueBlocks(uint256 overdueBlocks_) external onlyAdmin {\n        overdueBlocks = overdueBlocks_;\n    }\n\n    /**\n     *  @dev Change to a different interest rate model\n     *  Accept claims only from the admin\n     *  @param newInterestRateModel New interest rate model address\n     */\n    function setInterestRateModel(address newInterestRateModel) external onlyAdmin {\n        _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function setReserveFactor(uint256 reserveFactorMantissa_) external onlyAdmin {\n        require(\n            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,\n            \"reserveFactorMantissa error\"\n        );\n        reserveFactorMantissa = reserveFactorMantissa_;\n    }\n\n    /**\n     *  @dev Returns the remaining amount that can be borrowed from the market.\n     *  @return Remaining total amount\n     */\n    function getRemainingLoanSize() public view returns (uint256) {\n        if (debtCeiling >= totalBorrows) {\n            return debtCeiling - totalBorrows;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev Get the last repay block\n     *  @param account Member address\n     *  @return lastRepay\n     */\n    function getLastRepay(address account) public view returns (uint256 lastRepay) {\n        lastRepay = accountBorrows[account].lastRepay;\n    }\n\n    /**\n     *  @dev Get member interest index\n     *  @param account Member address\n     *  @return interestIndex\n     */\n    function getInterestIndex(address account) public view returns (uint256 interestIndex) {\n        interestIndex = accountBorrows[account].interestIndex;\n    }\n\n    /**\n     *  @dev Check if the member's loan is overdue\n     *  @param account Member address\n     *  @return isOverdue\n     */\n    function checkIsOverdue(address account) public view returns (bool isOverdue) {\n        if (getBorrowed(account) == 0) {\n            isOverdue = false;\n        } else {\n            uint256 lastRepay = getLastRepay(account);\n            uint256 diff = getBlockNumber() - lastRepay;\n            isOverdue = (overdueBlocks < diff);\n        }\n    }\n\n    /**\n     *  @dev Get the origination fee\n     *  @param amount Amount to be calculated\n     *  @return Handling fee\n     */\n    function calculatingFee(uint256 amount) public view returns (uint256) {\n        return (originationFee * amount) / WAD;\n    }\n\n    /**\n     *  @dev Get member loan data\n     *  @param member Member address\n     *  @return principal totalBorrowed asset apr limit isOverdue lastRepay\n     */\n    function getLoan(address member)\n        public\n        view\n        returns (\n            uint256 principal,\n            uint256 totalBorrowed,\n            address asset,\n            uint256 apr,\n            int256 limit,\n            bool isOverdue,\n            uint256 lastRepay\n        )\n    {\n        principal = accountBorrows[msg.sender].principal;\n        totalBorrowed = borrowBalanceStoredInternal(member);\n        asset = underlying;\n        apr = borrowRatePerBlock();\n        lastRepay = getLastRepay(member);\n        limit = _getCreditLimit(member);\n        isOverdue = checkIsOverdue(member);\n    }\n\n    /**\n     *  @dev Get the borrowed principle\n     *  @param account Member address\n     *  @return borrowed\n     */\n    function getBorrowed(address account) public view returns (uint256 borrowed) {\n        borrowed = accountBorrows[account].principal;\n    }\n\n    /**\n     *  @dev Get a member's current owed balance, including the principle and interest but without updating the user's states.\n     *  @param account Member address\n     *  @return Borrowed amount\n     */\n    function borrowBalanceView(address account) public view returns (uint256) {\n        return accountBorrows[account].principal + calculatingInterest(account);\n    }\n\n    /**\n     *  @dev Get a member's total owed, including the principle and the interest calculated based on the interest index.\n     *  @param account Member address\n     *  @return Borrowed amount\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (uint256) {\n        BorrowSnapshot memory loan = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (loan.principal == 0) {\n            return 0;\n        }\n\n        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndex;\n        return principalTimesIndex / loan.interestIndex;\n    }\n\n    /**\n     *  @dev Get the borrowing interest rate per block\n     *  @return Borrow rate\n     */\n    function borrowRatePerBlock() public view returns (uint256) {\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate();\n        require(borrowRateMantissa <= BORROW_RATE_MAX_MANTISSA, \"borrow rate is absurdly high\");\n        return borrowRateMantissa;\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this UToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() public view returns (uint256) {\n        return interestRateModel.getSupplyRate(reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint256) {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the UToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint256) {\n        uint256 totalSupply_ = uErc20.totalSupply();\n        if (totalSupply_ == 0) {\n            return initialExchangeRateMantissa;\n        } else {\n            return (totalRedeemable * WAD) / totalSupply_;\n        }\n    }\n\n    /**\n     *  @dev Calculating member's borrowed interest\n     *  @param account Member address\n     *  @return Interest amount\n     */\n    function calculatingInterest(address account) public view returns (uint256) {\n        BorrowSnapshot memory loan = accountBorrows[account];\n\n        if (loan.principal == 0) {\n            return 0;\n        }\n\n        uint256 borrowRate = borrowRatePerBlock();\n        uint256 currentBlockNumber = getBlockNumber();\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;\n        uint256 simpleInterestFactor = borrowRate * blockDelta;\n        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;\n\n        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndexNew;\n        uint256 balance = principalTimesIndex / loan.interestIndex;\n\n        return balance - accountBorrows[account].principal;\n    }\n\n    /**\n     *  @dev Borrowing from the market\n     *  Accept claims only from the member\n     *  Borrow amount must in the range of creditLimit, minBorrow, maxBorrow, debtCeiling and not overdue\n     *  @param amount Borrow amount\n     */\n    function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        require(amount >= minBorrow, \"UToken: amount less than loan size min\");\n\n        require(amount <= getRemainingLoanSize(), \"UToken: amount more than loan global size max\");\n\n        uint256 fee = calculatingFee(amount);\n        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, \"UToken: amount large than borrow size max\");\n\n        require(!checkIsOverdue(msg.sender), \"UToken: Member has loans overdue\");\n\n        require(amount <= assetManagerContract.getLoanableAmount(underlying), \"UToken: Not enough to lend out\");\n        require(\n            uint256(_getCreditLimit(msg.sender)) >= amount + fee,\n            \"UToken: The loan amount plus fee is greater than credit limit\"\n        );\n\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n\n        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);\n\n        //Set lastRepay init data\n        if (accountBorrows[msg.sender].lastRepay == 0) {\n            accountBorrows[msg.sender].lastRepay = getBlockNumber();\n        }\n\n        uint256 accountBorrowsNew = borrowedAmount + amount + fee;\n        uint256 totalBorrowsNew = totalBorrows + amount + fee;\n        uint256 oldPrincipal = accountBorrows[msg.sender].principal;\n\n        accountBorrows[msg.sender].principal += amount + fee;\n        uint256 newPrincipal = accountBorrows[msg.sender].principal;\n        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);\n        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n        // The origination fees contribute to the reserve\n        totalReserves += fee;\n\n        require(assetManagerContract.withdraw(underlying, msg.sender, amount), \"UToken: Failed to withdraw\");\n\n        emit LogBorrow(msg.sender, amount, fee);\n    }\n\n    function repayBorrow(uint256 repayAmount) external whenNotPaused nonReentrant {\n        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external whenNotPaused nonReentrant {\n        _repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    /**\n     *  @dev Repay the loan\n     *  Accept claims only from the member\n     *  Updated member lastPaymentEpoch only when the repayment amount is greater than interest\n     *  @param payer Payer address\n     *  @param borrower Borrower address\n     *  @param amount Repay amount\n     */\n    function _repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 amount\n    ) private {\n        IUErc20 assetToken = IUErc20(underlying);\n        //In order to prevent the state from being changed, put the value at the top\n        bool isOverdue = checkIsOverdue(borrower);\n        uint256 oldPrincipal = accountBorrows[borrower].principal;\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        require(accrualBlockNumber == getBlockNumber(), \"UToken: market not fresh\");\n\n        uint256 interest = calculatingInterest(borrower);\n        uint256 borrowedAmount = borrowBalanceStoredInternal(borrower);\n\n        uint256 repayAmount;\n        if (amount > borrowedAmount) {\n            repayAmount = borrowedAmount;\n        } else {\n            repayAmount = amount;\n        }\n\n        require(repayAmount > 0, \"UToken: repay amount or owed amount is zero\");\n\n        require(assetToken.allowance(payer, address(this)) >= repayAmount, \"UToken: Not enough allowance to repay\");\n\n        uint256 toReserveAmount;\n        uint256 toRedeemableAmount;\n        if (repayAmount >= interest) {\n            toReserveAmount = (interest * reserveFactorMantissa) / WAD;\n            toRedeemableAmount = interest - toReserveAmount;\n\n            if (isOverdue) {\n                IUserManager(userManager).updateTotalFrozen(borrower, false);\n                IUserManager(userManager).repayLoanOverdue(borrower, underlying, accountBorrows[borrower].lastRepay);\n            }\n            accountBorrows[borrower].principal = borrowedAmount - repayAmount;\n            accountBorrows[borrower].interest = 0;\n\n            if (accountBorrows[borrower].principal == 0) {\n                //LastRepay is cleared when the arrears are paid off, and reinitialized the next time the loan is borrowed\n                accountBorrows[borrower].lastRepay = 0;\n            } else {\n                accountBorrows[borrower].lastRepay = getBlockNumber();\n            }\n        } else {\n            toReserveAmount = (repayAmount * reserveFactorMantissa) / WAD;\n            toRedeemableAmount = repayAmount - toReserveAmount;\n            accountBorrows[borrower].interest = interest - repayAmount;\n        }\n\n        totalReserves += toReserveAmount;\n        totalRedeemable += toRedeemableAmount;\n\n        uint256 newPrincipal = accountBorrows[borrower].principal;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows -= repayAmount;\n\n        IUserManager(userManager).updateLockedData(borrower, oldPrincipal - newPrincipal, false);\n\n        assetToken.safeTransferFrom(payer, address(this), repayAmount);\n\n        assetToken.safeApprove(assetManager, 0);\n        assetToken.safeApprove(assetManager, repayAmount);\n\n        require(IAssetManager(assetManager).deposit(underlying, repayAmount), \"UToken: Deposit failed\");\n\n        emit LogRepay(borrower, repayAmount);\n    }\n\n    function repayBorrowWithPermit(\n        address borrower,\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUErc20 erc20Token = IUErc20(underlying);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        _repayBorrowFresh(msg.sender, borrower, amount);\n    }\n\n    /**\n     *  @dev Accrue interest\n     *  @return Accrue interest finished\n     */\n    function accrueInterest() public returns (bool) {\n        uint256 borrowRate = borrowRatePerBlock();\n        uint256 currentBlockNumber = getBlockNumber();\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;\n\n        uint256 simpleInterestFactor = borrowRate * blockDelta;\n        uint256 interestAccumulated = (simpleInterestFactor * totalBorrows) / WAD;\n        uint256 totalBorrowsNew = interestAccumulated + totalBorrows;\n        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;\n\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n\n        return true;\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256) {\n        return exchangeRateCurrent() * uErc20.balanceOf(owner);\n    }\n\n    function mint(uint256 mintAmount) external whenNotPaused nonReentrant {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        uint256 exchangeRate = exchangeRateStored();\n        IUErc20 assetToken = IUErc20(underlying);\n        uint256 balanceBefore = assetToken.balanceOf(address(this));\n        require(assetToken.allowance(msg.sender, address(this)) >= mintAmount, \"UToken: Not enough allowance\");\n        assetToken.safeTransferFrom(msg.sender, address(this), mintAmount);\n        uint256 balanceAfter = assetToken.balanceOf(address(this));\n        uint256 actualMintAmount = balanceAfter - balanceBefore;\n        totalRedeemable += actualMintAmount;\n        uint256 mintTokens = (actualMintAmount * WAD) / exchangeRate;\n        uErc20.mint(msg.sender, mintTokens);\n\n        assetToken.safeApprove(assetManager, 0);\n        assetToken.safeApprove(assetManager, actualMintAmount);\n\n        require(IAssetManager(assetManager).deposit(underlying, actualMintAmount), \"UToken: Deposit failed\");\n\n        emit LogMint(msg.sender, actualMintAmount, mintTokens);\n    }\n\n    /**\n     * @notice Sender redeems uTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of uTokens to redeem into underlying\n     */\n    function redeem(uint256 redeemTokens) external whenNotPaused nonReentrant {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        _redeemFresh(payable(msg.sender), redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems uTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming uTokens\n     */\n    function redeemUnderlying(uint256 redeemAmount) external whenNotPaused nonReentrant {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        _redeemFresh(payable(msg.sender), 0, redeemAmount);\n    }\n\n    /**\n     * @notice User redeems uTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of uTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming uTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function _redeemFresh(\n        address payable redeemer,\n        uint256 redeemTokensIn,\n        uint256 redeemAmountIn\n    ) internal {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n\n        uint256 exchangeRate = exchangeRateStored();\n\n        uint256 redeemTokens;\n        uint256 redeemAmount;\n\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            redeemTokens = redeemTokensIn;\n            redeemAmount = (redeemTokensIn * exchangeRate) / WAD;\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            redeemTokens = (redeemAmountIn * WAD) / exchangeRate;\n            redeemAmount = redeemAmountIn;\n        }\n\n        require(totalRedeemable >= redeemAmount, \"redeem amount error\");\n        totalRedeemable -= redeemAmount;\n        uErc20.burn(redeemer, redeemTokens);\n\n        require(assetManagerContract.withdraw(underlying, redeemer, redeemAmount), \"UToken: Failed to withdraw\");\n\n        emit LogRedeem(redeemer, redeemTokensIn, redeemAmountIn, redeemAmount);\n    }\n\n    function addReserves(uint256 addAmount) external whenNotPaused nonReentrant {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        IUErc20 assetToken = IUErc20(underlying);\n        uint256 balanceBefore = assetToken.balanceOf(address(this));\n        require(assetToken.allowance(msg.sender, address(this)) >= addAmount, \"UToken: Not enough allowance\");\n        assetToken.safeTransferFrom(msg.sender, address(this), addAmount);\n        uint256 balanceAfter = assetToken.balanceOf(address(this));\n        uint256 actualAddAmount = balanceAfter - balanceBefore;\n\n        uint256 totalReservesNew = totalReserves + actualAddAmount;\n        /* Revert on overflow */\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n        totalReserves = totalReservesNew;\n\n        assetToken.safeApprove(assetManager, 0);\n        assetToken.safeApprove(assetManager, balanceAfter);\n\n        require(IAssetManager(assetManager).deposit(underlying, balanceAfter), \"UToken: Deposit failed\");\n\n        emit LogReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function removeReserves(address receiver, uint256 reduceAmount) external whenNotPaused nonReentrant onlyAdmin {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        require(reduceAmount <= totalReserves, \"amount is large than totalReserves\");\n\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n\n        uint256 totalReservesNew = totalReserves - reduceAmount;\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n        totalReserves = totalReservesNew;\n\n        require(assetManagerContract.withdraw(underlying, receiver, reduceAmount), \"UToken: Failed to withdraw\");\n\n        emit LogReservesReduced(receiver, reduceAmount, totalReservesNew);\n    }\n\n    function debtWriteOff(address borrower, uint256 amount) external whenNotPaused onlyUserManager {\n        uint256 oldPrincipal = accountBorrows[borrower].principal;\n        uint256 repayAmount;\n        if (amount > oldPrincipal) {\n            repayAmount = oldPrincipal;\n        } else {\n            repayAmount = amount;\n        }\n\n        accountBorrows[borrower].principal = oldPrincipal - repayAmount;\n        totalBorrows -= repayAmount;\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    function _setInterestRateModelFresh(address newInterestRateModel_) private {\n        address oldInterestRateModel = address(interestRateModel);\n        address newInterestRateModel = newInterestRateModel_;\n        require(\n            IInterestRateModel(newInterestRateModel).isInterestRateModel(),\n            \"UToken: new model is not a interestRateModel\"\n        );\n        interestRateModel = IInterestRateModel(newInterestRateModel);\n\n        emit LogNewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n    }\n\n    /**\n     *  @dev Update borrower overdue info\n     *  @param account Borrower address\n     */\n    function updateOverdueInfo(address account) external whenNotPaused {\n        if (checkIsOverdue(account)) {\n            IUserManager(userManager).updateTotalFrozen(account, true);\n        }\n    }\n\n    /**\n     *  @dev Batch update borrower overdue info\n     *  @param accounts Borrowers address\n     */\n    function batchUpdateOverdueInfos(address[] calldata accounts) external whenNotPaused {\n        address[] memory overdueAccounts = new address[](accounts.length);\n        bool[] memory isOverdues = new bool[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; i++) {\n            if (checkIsOverdue(accounts[i])) {\n                overdueAccounts[i] = accounts[i];\n                isOverdues[i] = true;\n            }\n        }\n        IUserManager(userManager).batchUpdateTotalFrozen(overdueAccounts, isOverdues);\n    }\n\n    /**\n     *  @dev Get a member's available credit limit\n     *  @param account Member address\n     *  @return Member credit limit\n     */\n    function _getCreditLimit(address account) private view returns (int256) {\n        return IUserManager(userManager).getCreditLimit(account);\n    }\n}\nabstract contract Controller is Initializable, UUPSUpgradeable, AccessControlUpgradeable {\n    bytes32 public constant ROLE_ADMIN = keccak256(\"ROLE_ADMIN\");\n\n    mapping(address => address) private _admins;\n    // slither-disable-next-line uninitialized-state\n    bool private _paused;\n    // slither-disable-next-line uninitialized-state\n    address public pauseGuardian;\n\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Controller: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Controller: not paused\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(hasRole(ROLE_ADMIN, msg.sender), \"Controller: not admin\");\n        _;\n    }\n\n    modifier onlyGuardian() {\n        require(pauseGuardian == msg.sender, \"Controller: caller does not have the guardian role\");\n        _;\n    }\n\n    //When using minimal deploy, do not call initialize directly during deploy, because msg.sender is the proxyFactory address, and you need to call it manually\n    function __Controller_init(address admin_) public initializer {\n        require(admin_ != address(0), \"Controller: address zero\");\n        _paused = false;\n        _admins[admin_] = admin_;\n        __UUPSUpgradeable_init();\n        _setupRole(ROLE_ADMIN, admin_);\n        pauseGuardian = admin_;\n    }\n\n    function _authorizeUpgrade(address) internal view override onlyAdmin {}\n\n    /**\n     * @dev Check if the address provided is the admin\n     * @param account Account address\n     */\n    function isAdmin(address account) public view returns (bool) {\n        return hasRole(ROLE_ADMIN, account);\n    }\n\n    /**\n     * @dev Add a new admin account\n     * @param account Account address\n     */\n    function addAdmin(address account) public onlyAdmin {\n        require(account != address(0), \"Controller: address zero\");\n        require(_admins[account] == address(0), \"Controller: admin already existed\");\n\n        _admins[account] = account;\n        _setupRole(ROLE_ADMIN, account);\n    }\n\n    /**\n     * @dev Set pauseGuardian account\n     * @param account Account address\n     */\n    function setGuardian(address account) public onlyAdmin {\n        pauseGuardian = account;\n    }\n\n    /**\n     * @dev Renouce the admin from the sender's address\n     */\n    function renounceAdmin() public {\n        renounceRole(ROLE_ADMIN, msg.sender);\n        delete _admins[msg.sender];\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyGuardian whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyGuardian whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    uint256[50] private ______gap;\n}\n",
    "bin": []
}