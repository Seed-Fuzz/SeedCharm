{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/58/mellow-vaults",
    "external_functions": [
        [
            "AaveVault",
            "IVaultRegistry",
            "IVaultGovernance",
            "IProtocolGovernance",
            "IERC20",
            "IGatewayVault",
            "ILendingPool",
            "IAaveVaultGovernance"
        ],
        [
            "AaveVaultFactory"
        ],
        [
            "DefaultAccessControl"
        ],
        [
            "GatewayVault",
            "IVaultRegistry",
            "IVaultGovernance",
            "IProtocolGovernance",
            "IERC20",
            "IGatewayVault",
            "IVault",
            "IGatewayVaultGovernance"
        ],
        [
            "GatewayVaultFactory"
        ],
        [
            "GatewayVaultGovernance",
            "IProtocolGovernance",
            "IVault",
            "IVaultRegistry",
            "IVaultFactory",
            "IGatewayVault"
        ],
        [
            "LpIssuer",
            "ERC20",
            "IVaultRegistry",
            "IVaultGovernance",
            "IVault",
            "ILpIssuerGovernance",
            "IERC20",
            "IProtocolGovernance"
        ],
        [
            "LpIssuerFactory"
        ],
        [
            "LpIssuerGovernance",
            "IProtocolGovernance",
            "IVault",
            "IVaultRegistry",
            "IVaultFactory",
            "ILpIssuer"
        ],
        [
            "ProtocolGovernance"
        ],
        [
            "UniV3Vault",
            "IUniswapV3Factory",
            "INonfungiblePositionManager",
            "IVaultRegistry",
            "IVaultGovernance",
            "IProtocolGovernance",
            "IERC20",
            "IGatewayVault",
            "IUniswapV3Pool",
            "IUniV3VaultGovernance"
        ],
        [
            "UniV3VaultFactory"
        ],
        [
            "UniV3VaultGovernance",
            "IProtocolGovernance",
            "IVault",
            "IVaultRegistry",
            "IVaultFactory"
        ],
        [
            "Vault",
            "IVaultRegistry",
            "IVaultGovernance",
            "IProtocolGovernance",
            "IERC20",
            "IGatewayVault"
        ],
        [
            "VaultGovernance",
            "IProtocolGovernance",
            "IVault",
            "IVaultRegistry",
            "IVaultFactory"
        ],
        [
            "YearnVault",
            "IYearnVaultGovernance",
            "IVaultRegistry",
            "IVaultGovernance",
            "IProtocolGovernance",
            "IERC20",
            "IGatewayVault",
            "IYearnVault"
        ],
        [
            "YearnVaultFactory"
        ],
        [
            "YearnVaultGovernance",
            "IProtocolGovernance",
            "IVault",
            "IVaultRegistry",
            "IVaultFactory",
            "IYearnVaultRegistry"
        ]
    ],
    "new_contract": "abstract contract Vault is IVault, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IVaultGovernance internal _vaultGovernance;\n    address[] internal _vaultTokens;\n    mapping(address => bool) internal _vaultTokensIndex;\n    uint256 internal _nft;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance of this Vault\n    /// @param vaultTokens_ ERC20 tokens that will be managed by this Vault\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_) {\n        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);\n        _vaultGovernance = vaultGovernance_;\n        _vaultTokens = vaultTokens_;\n        for (uint256 i = 0; i < vaultTokens_.length; i++) {\n            _vaultTokensIndex[vaultTokens_[i]] = true;\n        }\n    }\n\n    // -------------------  PUBLIC, VIEW  -------------------\n\n    /// @inheritdoc IVault\n    function vaultGovernance() external view returns (IVaultGovernance) {\n        return _vaultGovernance;\n    }\n\n    /// @inheritdoc IVault\n    function vaultTokens() external view returns (address[] memory) {\n        return _vaultTokens;\n    }\n\n    /// @inheritdoc IVault\n    function tvl() public view virtual returns (uint256[] memory tokenAmounts);\n\n    /// @inheritdoc IVault\n    function nft() external view returns (uint256) {\n        return _nft;\n    }\n\n    // -------------------  PUBLIC, MUTATING, VaultGovernance  -------------------\n\n    function initialize(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);\n        _nft = nft_;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        registry.setApprovalForAll(address(registry), true);\n    }\n\n    // -------------------  PUBLIC, MUTATING, NFT OWNER OR APPROVED  -------------------\n\n    /// @inheritdoc IVault\n    function push(\n        address[] memory tokens,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) public nonReentrant returns (uint256[] memory actualTokenAmounts) {\n        uint256 nft_ = _nft;\n        require(nft_ > 0, ExceptionsLibrary.INITIALIZATION);\n        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER); // Also checks that the token exists\n        IVaultRegistry vaultRegistry = _vaultGovernance.internalParams().registry;\n        IVault ownerVault = IVault(vaultRegistry.ownerOf(nft_));\n        uint256 ownerNft = vaultRegistry.nftForVault(address(ownerVault));\n        require(ownerNft > 0, ExceptionsLibrary.OWNER_VAULT_NFT); // require deposits only through Vault\n        uint256[] memory pTokenAmounts = _validateAndProjectTokens(tokens, tokenAmounts);\n        uint256[] memory pActualTokenAmounts = _push(pTokenAmounts, options);\n        actualTokenAmounts = CommonLibrary.projectTokenAmounts(tokens, _vaultTokens, pActualTokenAmounts);\n        emit Push(pActualTokenAmounts);\n    }\n\n    /// @inheritdoc IVault\n    function transferAndPush(\n        address from,\n        address[] memory tokens,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) external returns (uint256[] memory actualTokenAmounts) {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (tokenAmounts[i] > 0) {\n                IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmounts[i]);\n            }\n        }\n        actualTokenAmounts = push(tokens, tokenAmounts, options);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 leftover = actualTokenAmounts[i] < tokenAmounts[i] ? tokenAmounts[i] - actualTokenAmounts[i] : 0;\n            if (leftover > 0) {\n                IERC20(tokens[i]).safeTransfer(from, leftover);\n            }\n        }\n    }\n\n    /// @inheritdoc IVault\n    function pull(\n        address to,\n        address[] memory tokens,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) external nonReentrant returns (uint256[] memory actualTokenAmounts) {\n        require(_isApprovedOrOwner(msg.sender), \"IO\"); // Also checks that the token exists\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        address owner = registry.ownerOf(_nft);\n        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION); // approved can only pull to whitelisted contracts\n        uint256[] memory pTokenAmounts = _validateAndProjectTokens(tokens, tokenAmounts);\n        uint256[] memory pActualTokenAmounts = _pull(to, pTokenAmounts, options);\n        actualTokenAmounts = CommonLibrary.projectTokenAmounts(tokens, _vaultTokens, pActualTokenAmounts);\n        emit Pull(to, actualTokenAmounts);\n    }\n\n    // -------------------  PUBLIC, MUTATING, NFT OWNER OR APPROVED OR PROTOCOL ADMIN -------------------\n    /// @inheritdoc IVault\n    function reclaimTokens(address to, address[] memory tokens) external nonReentrant {\n        require(_nft > 0, ExceptionsLibrary.INITIALIZATION);\n        IProtocolGovernance governance = _vaultGovernance.internalParams().protocolGovernance;\n        bool isProtocolAdmin = governance.isAdmin(msg.sender);\n        require(isProtocolAdmin || _isApprovedOrOwner(msg.sender), ExceptionsLibrary.ADMIN);\n        if (!isProtocolAdmin) {\n            require(_isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);\n        }\n        uint256[] memory tokenAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20 token = IERC20(tokens[i]);\n            tokenAmounts[i] = token.balanceOf(address(this));\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n            token.safeTransfer(to, tokenAmounts[i]);\n        }\n        _postReclaimTokens(to, tokens);\n        emit ReclaimTokens(to, tokens, tokenAmounts);\n    }\n\n    /// @inheritdoc IVault\n    function claimRewards(address from, bytes memory data) external override nonReentrant {\n        require(_nft > 0, ExceptionsLibrary.INITIALIZATION);\n        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);\n        IProtocolGovernance protocolGovernance = _vaultGovernance.internalParams().protocolGovernance;\n        require(protocolGovernance.isAllowedToClaim(from), ExceptionsLibrary.ALLOWED_TO_CLAIM);\n        (bool res, bytes memory returndata) = from.call(data);\n        if (!res) {\n            assembly {\n                let returndata_size := mload(returndata)\n                // Bubble up revert reason\n                revert(add(32, returndata), returndata_size)\n            }\n        }\n    }\n\n    // -------------------  PUBLIC, VIEW   -------------------\\\n\n    function isVaultToken(address token) public view returns (bool) {\n        return _vaultTokensIndex[token];\n    }\n\n    // -------------------  PRIVATE, VIEW  -------------------\n\n    function _validateAndProjectTokens(address[] memory tokens, uint256[] memory tokenAmounts)\n        internal\n        view\n        returns (uint256[] memory pTokenAmounts)\n    {\n        require(CommonLibrary.isSortedAndUnique(tokens), ExceptionsLibrary.SORTED_AND_UNIQUE);\n        require(tokens.length == tokenAmounts.length, ExceptionsLibrary.INCONSISTENT_LENGTH);\n        pTokenAmounts = CommonLibrary.projectTokenAmounts(_vaultTokens, tokens, tokenAmounts);\n    }\n\n    /// The idea is to check that `this` Vault and `to` Vault\n    /// nfts are owned by the same address. Then check that nft for this address\n    /// exists in registry as Vault => it's one of the vaults with trusted interface.\n    /// Then check that both `this` and `to` are registered in the nft owner using hasSubvault function.\n    /// Since only gateway vault has hasSubvault function this will prove correctly that\n    /// the vaults belong to the same vault system.\n    function _isValidPullDestination(address to) internal view returns (bool) {\n        if (!CommonLibrary.isContract(to)) {\n            return false;\n        }\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        // make sure that this vault is a registered vault\n        if (_nft == 0) {\n            return false;\n        }\n        address thisOwner = registry.ownerOf(_nft);\n        // make sure that vault has a registered owner\n        uint256 thisOwnerNft = registry.nftForVault(thisOwner);\n        if (thisOwnerNft == 0) {\n            return false;\n        }\n        IGatewayVault gw = IGatewayVault(thisOwner);\n        if (!gw.hasSubvault(address(this)) || !gw.hasSubvault(to)) {\n            return false;\n        }\n        return true;\n    }\n\n    // -------------------  PRIVATE, VIEW  -------------------\n\n    function _isApprovedOrOwner(address sender) internal view returns (bool) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 nft_ = _nft;\n        if (nft_ == 0) {\n            return false;\n        }\n        return registry.getApproved(nft_) == sender || registry.ownerOf(nft_) == sender;\n    }\n\n    // -------------------  PRIVATE, MUTATING  -------------------\n\n    /// Guaranteed to have exact signature matchinn vault tokens\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        virtual\n        returns (uint256[] memory actualTokenAmounts);\n\n    /// Guaranteed to have exact signature matchinn vault tokens\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal virtual returns (uint256[] memory actualTokenAmounts);\n\n    function _postReclaimTokens(address to, address[] memory tokens) internal virtual {}\n\n    /// @notice Emitted on successful push\n    /// @param tokenAmounts The amounts of tokens to pushed\n    event Push(uint256[] tokenAmounts);\n\n    /// @notice Emitted on successful pull\n    /// @param to The target address for pulled tokens\n    /// @param tokenAmounts The amounts of tokens to pull\n    event Pull(address to, uint256[] tokenAmounts);\n\n    /// @notice Emitted when tokens are reclaimed\n    /// @param to The target address for pulled tokens\n    /// @param tokens ERC20 tokens to be reclaimed\n    /// @param tokenAmounts The amounts of reclaims\n    event ReclaimTokens(address to, address[] tokens, uint256[] tokenAmounts);\n}\ncontract LpIssuerFactory is IVaultFactory {\n    IVaultGovernance public vaultGovernance;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind\n    constructor(IVaultGovernance vaultGovernance_) {\n        vaultGovernance = vaultGovernance_;\n    }\n\n    /// @inheritdoc IVaultFactory\n    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {\n        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        (string memory name, string memory symbol) = abi.decode(options, (string, string));\n        LpIssuer vault = new LpIssuer(vaultGovernance, vaultTokens, name, symbol);\n        return IVault(address(vault));\n    }\n}\ncontract AaveVaultFactory is IVaultFactory {\n    IVaultGovernance public vaultGovernance;\n\n    /// @notice Creates a new contract\n    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind\n    constructor(IVaultGovernance vaultGovernance_) {\n        vaultGovernance = vaultGovernance_;\n    }\n\n    /// @inheritdoc IVaultFactory\n    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {\n        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        AaveVault vault = new AaveVault(vaultGovernance, vaultTokens);\n        return IVault(vault);\n    }\n}\ncontract AaveVault is Vault {\n    address[] internal _aTokens;\n    uint256[] internal _tvls;\n\n    /// @notice Creates a new contract.\n    /// @dev Requires that aToken exists for each vaultToken\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _aTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address aToken = _getAToken(_vaultTokens[i]);\n            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);\n            _aTokens[i] = aToken;\n            _tvls.push(0);\n        }\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        return _tvls;\n    }\n\n    /// @notice Update all tvls to current aToken balances.\n    function updateTvls() public {\n        for (uint256 i = 0; i < _tvls.length; i++) {\n            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        uint256 referralCode = 0;\n        if (options.length > 0) {\n            referralCode = abi.decode(options, (uint256));\n        }\n\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n            address token = tokens[i];\n            _allowTokenIfNecessary(token);\n            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {\n                continue;\n            }\n            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _getAToken(address token) internal view returns (address) {\n        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);\n        return data.aTokenAddress;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {\n            IERC20(token).approve(address(_lendingPool()), type(uint256).max);\n        }\n    }\n\n    function _lendingPool() internal view returns (ILendingPool) {\n        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;\n    }\n}\ncontract YearnVault is Vault {\n    address[] private _yTokens;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _yTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            _yTokens[i] = IYearnVaultGovernance(address(vaultGovernance_)).yTokenForToken(_vaultTokens[i]);\n            require(_yTokens[i] != address(0), \"YV\");\n        }\n    }\n\n    /// @notice Yearn protocol vaults used by this contract\n    function yTokens() external view returns (address[] memory) {\n        return _yTokens;\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        tokenAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            tokenAmounts[i] = (yToken.balanceOf(address(this)) * yToken.pricePerShare()) / (10**yToken.decimals());\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n\n            address token = tokens[i];\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            _allowTokenIfNecessary(token, address(yToken));\n            yToken.deposit(tokenAmounts[i], address(this));\n        }\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        uint256 maxLoss = abi.decode(options, (uint256));\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());\n            uint256 balance = yToken.balanceOf(address(this));\n            if (yTokenAmount > balance) {\n                yTokenAmount = balance;\n            }\n            if (yTokenAmount == 0) {\n                continue;\n            }\n            yToken.withdraw(yTokenAmount, to, maxLoss);\n            (tokenAmounts[i], address(this));\n        }\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _allowTokenIfNecessary(address token, address yToken) internal {\n        if (IERC20(token).allowance(address(this), yToken) < type(uint256).max / 2) {\n            IERC20(token).approve(yToken, type(uint256).max);\n        }\n    }\n}\ncontract YearnVaultFactory is IVaultFactory {\n    IVaultGovernance public vaultGovernance;\n\n    /// @notice Creates a new contract\n    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind\n    constructor(IVaultGovernance vaultGovernance_) {\n        vaultGovernance = vaultGovernance_;\n    }\n\n    /// @inheritdoc IVaultFactory\n    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {\n        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        YearnVault vault = new YearnVault(vaultGovernance, vaultTokens);\n        return IVault(vault);\n    }\n}\ncontract GatewayVaultFactory is IVaultFactory {\n    IVaultGovernance public vaultGovernance;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind\n    constructor(IVaultGovernance vaultGovernance_) {\n        vaultGovernance = vaultGovernance_;\n    }\n\n    /// @inheritdoc IVaultFactory\n    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {\n        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        GatewayVault gatewayVault = new GatewayVault(vaultGovernance, vaultTokens);\n        return IVault(gatewayVault);\n    }\n}\ncontract YearnVaultGovernance is IYearnVaultGovernance, VaultGovernance {\n    mapping(address => address) private _yTokens;\n\n    /// @notice Creates a new contract\n    /// @param internalParams_ Initial Internal Params\n    /// @param delayedProtocolParams_ Initial Protocol Params\n    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)\n        VaultGovernance(internalParams_)\n    {\n        _delayedProtocolParams = abi.encode(delayedProtocolParams_);\n    }\n\n    /// @inheritdoc IYearnVaultGovernance\n    function yTokenForToken(address token) external view returns (address) {\n        address yToken = _yTokens[token];\n        if (yToken != address(0)) {\n            return yToken;\n        }\n        IYearnVaultRegistry yearnRegistry = delayedProtocolParams().yearnVaultRegistry;\n        try yearnRegistry.latestVault(token) returns (address _vault) {\n            return _vault;\n        } catch (bytes memory) {\n            return address(0);\n        }\n    }\n\n    /// @inheritdoc IYearnVaultGovernance\n    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {\n        if (_stagedDelayedProtocolParams.length == 0) {\n            return DelayedProtocolParams({yearnVaultRegistry: IYearnVaultRegistry(address(0))});\n        }\n        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));\n    }\n\n    /// @inheritdoc IYearnVaultGovernance\n    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {\n        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));\n    }\n\n    /// @inheritdoc IYearnVaultGovernance\n    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {\n        _stageDelayedProtocolParams(abi.encode(params));\n        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);\n    }\n\n    /// @inheritdoc IYearnVaultGovernance\n    function commitDelayedProtocolParams() external {\n        _commitDelayedProtocolParams();\n        emit CommitDelayedProtocolParams(\n            tx.origin,\n            msg.sender,\n            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))\n        );\n    }\n\n    /// @inheritdoc IYearnVaultGovernance\n    function setYTokenForToken(address token, address yToken) external {\n        _requireProtocolAdmin();\n        _yTokens[token] = yToken;\n        emit SetYToken(tx.origin, msg.sender, token, yToken);\n    }\n\n    /// @notice Emitted when new yToken is set\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param token ERC-20 token for the yToken\n    /// @param yToken yToken for ERC-20 token\n    event SetYToken(address indexed origin, address indexed sender, address indexed token, address yToken);\n\n    /// @notice Emitted when new DelayedProtocolParams are staged for commit\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param params New params that were staged for commit\n    /// @param when When the params could be committed\n    event StageDelayedProtocolParams(\n        address indexed origin,\n        address indexed sender,\n        DelayedProtocolParams params,\n        uint256 when\n    );\n\n    /// @notice Emitted when new DelayedProtocolParams are committed\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param params New params that are committed\n    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);\n}\ncontract ProtocolGovernance is IProtocolGovernance, DefaultAccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    uint256 public constant MAX_GOVERNANCE_DELAY = 7 days;\n\n    EnumerableSet.AddressSet private _claimAllowlist;\n    address[] private _pendingClaimAllowlistAdd;\n    uint256 public pendingClaimAllowlistAddTimestamp;\n\n    address[] private _tokenWhitelist;\n    address[] private _pendingTokenWhitelistAdd;\n    uint256 private _numberOfValidTokens;\n    mapping(address => bool) _tokensAllowed;\n    mapping(address => bool) _tokenEverAdded;\n    uint256 public pendingTokenWhitelistAddTimestamp;\n\n    EnumerableSet.AddressSet private _vaultGovernances;\n    address[] private _pendingVaultGovernancesAdd;\n    uint256 public pendingVaultGovernancesAddTimestamp;\n\n    IProtocolGovernance.Params public params;\n    Params public pendingParams;\n\n    uint256 public pendingParamsTimestamp;\n\n    /// @notice Creates a new contract.\n    /// @param admin Initial admin of the contract\n    constructor(address admin) DefaultAccessControl(admin) {\n        _tokenWhitelist = new address[](0);\n        _numberOfValidTokens = 0;\n    }\n\n    // -------------------  PUBLIC, VIEW  -------------------\n\n    /// @inheritdoc IProtocolGovernance\n    function claimAllowlist() external view returns (address[] memory) {\n        uint256 l = _claimAllowlist.length();\n        address[] memory res = new address[](l);\n        for (uint256 i = 0; i < l; i++) {\n            res[i] = _claimAllowlist.at(i);\n        }\n        return res;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function tokenWhitelist() external view returns (address[] memory) {\n        uint256 l = _tokenWhitelist.length;\n        address[] memory res = new address[](_numberOfValidTokens);\n        uint256 j = 0;\n        for (uint256 i = 0; i < l; i++) {\n            if (!_tokensAllowed[_tokenWhitelist[i]] && _tokenEverAdded[_tokenWhitelist[i]]) {\n                continue;\n            }\n            res[j] = _tokenWhitelist[i];\n            j += 1;\n        }\n        return res;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function vaultGovernances() external view returns (address[] memory) {\n        uint256 l = _vaultGovernances.length();\n        address[] memory res = new address[](l);\n        for (uint256 i = 0; i < l; i++) {\n            res[i] = _vaultGovernances.at(i);\n        }\n        return res;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function pendingClaimAllowlistAdd() external view returns (address[] memory) {\n        return _pendingClaimAllowlistAdd;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function pendingTokenWhitelistAdd() external view returns (address[] memory) {\n        return _pendingTokenWhitelistAdd;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function pendingVaultGovernancesAdd() external view returns (address[] memory) {\n        return _pendingVaultGovernancesAdd;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function isAllowedToClaim(address addr) external view returns (bool) {\n        return _claimAllowlist.contains(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function isAllowedToken(address addr) external view returns (bool) {\n        return _tokenEverAdded[addr] && _tokensAllowed[addr];\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function isVaultGovernance(address addr) external view returns (bool) {\n        return _vaultGovernances.contains(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function permissionless() external view returns (bool) {\n        return params.permissionless;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function maxTokensPerVault() external view returns (uint256) {\n        return params.maxTokensPerVault;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function governanceDelay() external view returns (uint256) {\n        return params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function protocolTreasury() external view returns (address) {\n        return params.protocolTreasury;\n    }\n\n    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingClaimAllowlistAdd(address[] calldata addresses) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        _pendingClaimAllowlistAdd = addresses;\n        pendingClaimAllowlistAddTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function removeFromClaimAllowlist(address addr) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        if (!_claimAllowlist.contains(addr)) {\n            return;\n        }\n        _claimAllowlist.remove(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingTokenWhitelistAdd(address[] calldata addresses) external {\n        require(isAdmin(msg.sender), \"ADM\");\n        _pendingTokenWhitelistAdd = addresses;\n        pendingTokenWhitelistAddTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function removeFromTokenWhitelist(address addr) external {\n        require(isAdmin(msg.sender), \"ADM\");\n        _tokensAllowed[addr] = false;\n        if (_tokenEverAdded[addr]) {\n            --_numberOfValidTokens;\n        }\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingVaultGovernancesAdd(address[] calldata addresses) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        _pendingVaultGovernancesAdd = addresses;\n        pendingVaultGovernancesAddTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function removeFromVaultGovernances(address addr) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        if (!_vaultGovernances.contains(addr)) {\n            return;\n        }\n        _vaultGovernances.remove(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingParams(IProtocolGovernance.Params memory newParams) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(params.governanceDelay <= MAX_GOVERNANCE_DELAY, ExceptionsLibrary.MAX_GOVERNANCE_DELAY);\n        pendingParams = newParams;\n        pendingParamsTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------\n\n    /// @inheritdoc IProtocolGovernance\n    function commitClaimAllowlistAdd() external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(\n            (block.timestamp >= pendingClaimAllowlistAddTimestamp) && (pendingClaimAllowlistAddTimestamp > 0),\n            ExceptionsLibrary.TIMESTAMP\n        );\n        for (uint256 i = 0; i < _pendingClaimAllowlistAdd.length; i++) {\n            _claimAllowlist.add(_pendingClaimAllowlistAdd[i]);\n        }\n        delete _pendingClaimAllowlistAdd;\n        delete pendingClaimAllowlistAddTimestamp;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function commitTokenWhitelistAdd() external {\n        require(isAdmin(msg.sender), \"ADM\");\n        require(\n            (block.timestamp >= pendingTokenWhitelistAddTimestamp) && (pendingTokenWhitelistAddTimestamp > 0),\n            \"TS\"\n        );\n        for (uint256 i = 0; i < _pendingTokenWhitelistAdd.length; i++) {\n            if (!_tokenEverAdded[_pendingTokenWhitelistAdd[i]]) {\n                _numberOfValidTokens += 1;\n                _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;\n                _tokenWhitelist.push(_pendingTokenWhitelistAdd[i]);\n                _tokenEverAdded[_pendingTokenWhitelistAdd[i]] = true;\n            } else {\n                if (!_tokensAllowed[_pendingTokenWhitelistAdd[i]]) {\n                    _numberOfValidTokens += 1;\n                    _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;\n                }\n            }\n        }\n        delete _pendingTokenWhitelistAdd;\n        delete pendingTokenWhitelistAddTimestamp;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function commitVaultGovernancesAdd() external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(\n            (block.timestamp >= pendingVaultGovernancesAddTimestamp) && (pendingVaultGovernancesAddTimestamp > 0),\n            ExceptionsLibrary.TIMESTAMP\n        );\n        for (uint256 i = 0; i < _pendingVaultGovernancesAdd.length; i++) {\n            _vaultGovernances.add(_pendingVaultGovernancesAdd[i]);\n        }\n        delete _pendingVaultGovernancesAdd;\n        delete pendingVaultGovernancesAddTimestamp;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function commitParams() external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(block.timestamp >= pendingParamsTimestamp, ExceptionsLibrary.TIMESTAMP);\n        require(pendingParams.maxTokensPerVault > 0 || pendingParams.governanceDelay > 0, ExceptionsLibrary.EMPTY_PARAMS); // sanity check for empty params\n        params = pendingParams;\n        delete pendingParams;\n        delete pendingParamsTimestamp;\n    }\n}\ncontract GatewayVaultGovernance is VaultGovernance, IGatewayVaultGovernance {\n    /// @notice Creates a new contract.\n    /// @param internalParams_ Initial Internal Params\n    constructor(InternalParams memory internalParams_) VaultGovernance(internalParams_) {}\n\n    /// @inheritdoc IGatewayVaultGovernance\n    function delayedStrategyParams(uint256 nft) public view returns (DelayedStrategyParams memory) {\n        if (_delayedStrategyParams[nft].length == 0) {\n            return DelayedStrategyParams({redirects: new uint256[](0)});\n        }\n        return abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams));\n    }\n\n    /// @inheritdoc IGatewayVaultGovernance\n    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {\n        if (_stagedDelayedStrategyParams[nft].length == 0) {\n            return DelayedStrategyParams({redirects: new uint256[](0)});\n        }\n        return abi.decode(_stagedDelayedStrategyParams[nft], (DelayedStrategyParams));\n    }\n\n    /// @inheritdoc IGatewayVaultGovernance\n    function strategyParams(uint256 nft) external view returns (StrategyParams memory) {\n        if (_strategyParams[nft].length == 0) {\n            return StrategyParams({limits: new uint256[](0)});\n        }\n        return abi.decode(_strategyParams[nft], (StrategyParams));\n    }\n\n    /// @inheritdoc IGatewayVaultGovernance\n    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external {\n        IGatewayVault vault = IGatewayVault(_internalParams.registry.vaultForNft(nft));\n        require(\n            (params.redirects.length == 0) || (params.redirects.length == vault.subvaultNfts().length),\n            ExceptionsLibrary.REDIRECTS_AND_VAULT_TOKENS_LENGTH\n        );\n        _stageDelayedStrategyParams(nft, abi.encode(params));\n        emit StageDelayedStrategyParams(tx.origin, msg.sender, nft, params, _delayedStrategyParamsTimestamp[nft]);\n    }\n\n    /// @notice Deploy a new vault\n    /// @param vaultTokens ERC20 tokens under vault management\n    /// @param options Abi encoded uint256[] - an array of Nfts of subvaults. It is required that each nft subvault is approved by the caller to this address.\n    /// @param strategy Strategy that will be approved to manage subvaults\n    /// @return vault Address of the new vault\n    /// @return nft Nft of the vault in the vault registry\n    function deployVault(\n        address[] memory vaultTokens,\n        bytes memory options,\n        address strategy\n    ) public override(VaultGovernance, IVaultGovernance) returns (IVault vault, uint256 nft) {\n        for (uint256 i = 0; i < vaultTokens.length; ++i) {\n            require(_internalParams.protocolGovernance.isAllowedToken(vaultTokens[i]), \"TNA\");\n        }\n        (vault, nft) = super.deployVault(vaultTokens, \"\", msg.sender);\n        uint256[] memory subvaultNfts = abi.decode(options, (uint256[]));\n        IVaultRegistry registry = _internalParams.registry;\n        IGatewayVault(address(vault)).addSubvaults(subvaultNfts);\n        for (uint256 i = 0; i < subvaultNfts.length; i++) {\n            registry.safeTransferFrom(msg.sender, address(vault), subvaultNfts[i]);\n        }\n        IGatewayVault gw = IGatewayVault(address(vault));\n        gw.setApprovalsForStrategy(strategy, subvaultNfts);\n    }\n\n    /// @inheritdoc IGatewayVaultGovernance\n    function commitDelayedStrategyParams(uint256 nft) external {\n        _commitDelayedStrategyParams(nft);\n        emit CommitDelayedStrategyParams(\n            tx.origin,\n            msg.sender,\n            nft,\n            abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams))\n        );\n    }\n\n    /// @inheritdoc IGatewayVaultGovernance\n    function setStrategyParams(uint256 nft, StrategyParams calldata params) external {\n        _setStrategyParams(nft, abi.encode(params));\n        emit SetStrategyParams(tx.origin, msg.sender, nft, params);\n    }\n\n    /// @notice Emitted when new DelayedStrategyParams are staged for commit\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param nft VaultRegistry NFT of the vault\n    /// @param params New params that were staged for commit\n    /// @param when When the params could be committed\n    event StageDelayedStrategyParams(\n        address indexed origin,\n        address indexed sender,\n        uint256 indexed nft,\n        DelayedStrategyParams params,\n        uint256 when\n    );\n\n    /// @notice Emitted when new DelayedStrategyParams are committed\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param nft VaultRegistry NFT of the vault\n    /// @param params New params that are committed\n    event CommitDelayedStrategyParams(\n        address indexed origin,\n        address indexed sender,\n        uint256 indexed nft,\n        DelayedStrategyParams params\n    );\n\n    /// @notice Emitted when new StrategyParams are set\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param nft VaultRegistry NFT of the vault\n    /// @param params New params that are set\n    event SetStrategyParams(address indexed origin, address indexed sender, uint256 indexed nft, StrategyParams params);\n}\ncontract GatewayVault is IERC721Receiver, IGatewayVault, Vault {\n    using SafeERC20 for IERC20;\n    uint256[] internal _subvaultNfts;\n    mapping(uint256 => uint256) internal _subvaultNftsIndex;\n\n    /// @notice Creates a new contract.\n    /// @dev All subvault nfts must be owned by this vault before.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {}\n\n    /// @inheritdoc IGatewayVault\n    function subvaultNfts() external view returns (uint256[] memory) {\n        return _subvaultNfts;\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override(IVault, Vault) returns (uint256[] memory tokenAmounts) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        tokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory vTokenAmounts = vault.tvl();\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                tokenAmounts[j] += vTokenAmounts[j];\n            }\n        }\n    }\n\n    /// @inheritdoc IGatewayVault\n    function subvaultTvl(uint256 vaultNum) public view override returns (uint256[] memory) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        IVault vault = IVault(registry.vaultForNft(_subvaultNfts[vaultNum]));\n        return vault.tvl();\n    }\n\n    /// @inheritdoc IGatewayVault\n    function subvaultsTvl() public view override returns (uint256[][] memory tokenAmounts) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 vaultTokensLength = _vaultTokens.length;\n        tokenAmounts = new uint256[][](_subvaultNfts.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory vTokenAmounts = vault.tvl();\n            tokenAmounts[i] = new uint256[](vaultTokensLength);\n            for (uint256 j = 0; j < vaultTokensLength; j++) {\n                tokenAmounts[i][j] = vTokenAmounts[j];\n            }\n        }\n    }\n\n    /// @inheritdoc IGatewayVault\n    function hasSubvault(address vault) external view override returns (bool) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 nft_ = registry.nftForVault(vault);\n        return (_subvaultNftsIndex[nft_] > 0 || _subvaultNfts[0] == nft_);\n    }\n\n    /// @inheritdoc IGatewayVault\n    function addSubvaults(uint256[] memory nfts) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(_subvaultNfts.length == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);\n        require(nfts.length > 0, ExceptionsLibrary.SUB_VAULT_LENGTH);\n        address[] memory selfTokens = _vaultTokens;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        for (uint256 i = 0; i < nfts.length; i++) {\n            uint256 nft_ = nfts[i];\n            require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n            IVault vault = IVault(registry.vaultForNft(nft_));\n            address[] memory vTokens = vault.vaultTokens();\n            require(selfTokens.length == vTokens.length, ExceptionsLibrary.INCONSISTENT_LENGTH);\n            for (uint256 j = 0; j < selfTokens.length; j++) {\n                require(selfTokens[j] == vTokens[j], ExceptionsLibrary.NOT_VAULT_TOKEN);\n            }\n            _subvaultNfts.push(nft_);\n            _subvaultNftsIndex[nft_] = i;\n        }\n    }\n\n    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(strategy != address(0), ExceptionsLibrary.ZERO_STRATEGY_ADDRESS);\n        IVaultRegistry vaultRegistry = IVaultGovernance(_vaultGovernance).internalParams().registry;\n        for (uint i = 0; i < nfts.length; ++i)\n            vaultRegistry.approve(strategy, nfts[i]);\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external nonReentrant returns (bytes4) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        registry.lockNft(tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);\n        bool optimized;\n        bytes[] memory vaultsOptions;\n        (optimized, vaultsOptions) = _parseOptions(options);\n\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256[][] memory tvls = subvaultsTvl();\n        uint256[] memory totalTvl = new uint256[](_vaultTokens.length);\n        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);\n        IGatewayVaultGovernance.DelayedStrategyParams memory strategyParams = IGatewayVaultGovernance(\n            address(_vaultGovernance)\n        ).delayedStrategyParams(_nft);\n        if (optimized && strategyParams.redirects.length > 0) {\n            for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n                if (strategyParams.redirects[i] == 0) {\n                    continue;\n                }\n                for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];\n                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n                    amountsByVault[i][j] = 0;\n                }\n            }\n        }\n        actualTokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            if (optimized && (strategyParams.redirects[i] != 0)) {\n                continue;\n            }\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                if (amountsByVault[i][j] > 0) {\n                    _allowTokenIfNecessary(_vaultTokens[j], address(vault));\n                }\n            }\n            uint256[] memory actualVaultTokenAmounts = vault.transferAndPush(\n                address(this),\n                _vaultTokens,\n                amountsByVault[i],\n                vaultsOptions[i]\n            );\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                actualTokenAmounts[j] += actualVaultTokenAmounts[j];\n                totalTvl[j] += tvls[i][j];\n            }\n        }\n        uint256[] memory _limits = IGatewayVaultGovernance(address(_vaultGovernance)).strategyParams(_nft).limits;\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            require(totalTvl[i] + actualTokenAmounts[i] < _limits[i], ExceptionsLibrary.LIMIT_OVERFLOW);\n        }\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        (bool optimized, bytes[] memory vaultsOptions) = _parseOptions(options);\n\n        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256[][] memory tvls = subvaultsTvl();\n        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);\n        uint256[] memory _redirects = IGatewayVaultGovernance(address(_vaultGovernance))\n            .delayedStrategyParams(_nft)\n            .redirects;\n\n        if (optimized && (_redirects.length > 0)) {\n            for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n                if (_redirects[i] == 0) {\n                    continue;\n                }\n                for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                    uint256 vaultIndex = _subvaultNftsIndex[_redirects[i]];\n                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n                    amountsByVault[i][j] = 0;\n                }\n            }\n        }\n        actualTokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory actualVaultTokenAmounts = vault.pull(\n                to,\n                _vaultTokens,\n                amountsByVault[i],\n                vaultsOptions[i]\n            );\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                actualTokenAmounts[j] += actualVaultTokenAmounts[j];\n            }\n        }\n    }\n\n    function _allowTokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(address(this), address(to)) < type(uint256).max / 2) {\n            IERC20(token).approve(address(to), type(uint256).max);\n        }\n    }\n\n    function _parseOptions(bytes memory options) internal view returns (bool, bytes[] memory) {\n        if (options.length == 0) {\n            return (false, new bytes[](_subvaultNfts.length));\n        }\n        return abi.decode(options, (bool, bytes[]));\n    }\n\n    event CollectProtocolFees(address protocolTreasury, address[] tokens, uint256[] amounts);\n    event CollectStrategyFees(address strategyTreasury, address[] tokens, uint256[] amounts);\n}\ncontract UniV3Vault is IERC721Receiver, Vault {\n    struct Options {\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct Pair {\n        uint256 a0;\n        uint256 a1;\n    }\n\n    IUniswapV3Pool public immutable pool;\n\n    uint256 public uniV3Nft;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param fee Fee of the underlying UniV3 pool\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        uint24 fee\n    ) Vault(vaultGovernance_, vaultTokens_) {\n        require(_vaultTokens.length == 2, ExceptionsLibrary.TOKEN_LENGTH);\n        pool = IUniswapV3Pool(\n            IUniswapV3Factory(_positionManager().factory()).getPool(_vaultTokens[0], _vaultTokens[1], fee)\n        );\n    }\n\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory) external returns (bytes4) {\n        require(msg.sender == address(_positionManager()), \"SNFT\");\n        require(_isStrategy(operator), \"STR\");\n        (\n            , ,\n            address token0,\n            address token1,\n            , , , , , , ,\n        ) = _positionManager().positions(tokenId);\n        // new position should have vault tokens\n        require(\n            token0 == _vaultTokens[0] && token1 == _vaultTokens[1],\n            \"VT\"\n        );\n\n        if (uniV3Nft != 0) {\n            (\n                , , , , , , ,\n                uint128 liquidity,\n                , ,\n                uint128 tokensOwed0,\n                uint128 tokensOwed1\n            ) = _positionManager().positions(uniV3Nft);\n            require(liquidity == 0 && tokensOwed0 == 0 && tokensOwed1 == 0, \"TVL\");\n            // return previous uni v3 position nft\n            _positionManager().transferFrom(address(this), from, uniV3Nft);\n        }\n\n        uniV3Nft = tokenId;\n        return this.onERC721Received.selector;\n    }\n\n    function collectEarnings(address to) external nonReentrant returns (uint256[] memory collectedEarnings) {\n        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        address owner = registry.ownerOf(_nft);\n        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);\n        collectedEarnings = new uint256[](2);\n        (uint256 collectedEarnings0, uint256 collectedEarnings1) = _positionManager().collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: uniV3Nft,\n                recipient: to,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n        collectedEarnings[0] = collectedEarnings0;\n        collectedEarnings[1] = collectedEarnings1;\n        emit CollectedEarnings(tx.origin, to, collectedEarnings0, collectedEarnings1);\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        tokenAmounts = new uint256[](_vaultTokens.length);\n        if (uniV3Nft == 0)\n            return tokenAmounts;\n        (\n            , , , , , \n            int24 tickLower, \n            int24 tickUpper, \n            uint128 liquidity,\n            , , ,\n        ) = _positionManager().positions(uniV3Nft);\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            sqrtPriceAX96,\n            sqrtPriceBX96,\n            liquidity\n        );\n        tokenAmounts[0] = amount0;\n        tokenAmounts[1] = amount1;\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < tokens.length; i++)\n            _allowTokenIfNecessary(tokens[i]);\n\n        actualTokenAmounts = new uint256[](2);\n        if (uniV3Nft == 0)\n            return actualTokenAmounts;\n\n        Options memory opts = _parseOptions(options);\n        Pair memory amounts = Pair({\n            a0: tokenAmounts[0],\n            a1: tokenAmounts[1]\n        });\n        Pair memory minAmounts = Pair({\n            a0: opts.amount0Min,\n            a1: opts.amount1Min\n        });\n        (, uint256 amount0, uint256 amount1) = _positionManager().increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: uniV3Nft,\n                amount0Desired: amounts.a0,\n                amount1Desired: amounts.a1,\n                amount0Min: minAmounts.a0,\n                amount1Min: minAmounts.a1,\n                deadline: opts.deadline\n            })\n        );\n        actualTokenAmounts[0] = amount0;\n        actualTokenAmounts[1] = amount1;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        actualTokenAmounts = new uint256[](2);\n        if (uniV3Nft == 0)\n            return actualTokenAmounts;\n\n        Options memory opts = _parseOptions(options);\n        Pair memory amounts = _pullUniV3Nft(tokenAmounts, to, opts);\n        actualTokenAmounts[0] = amounts.a0;\n        actualTokenAmounts[1] = amounts.a1;\n    }\n\n    function _pullUniV3Nft(\n        uint256[] memory tokenAmounts,\n        address to,\n        Options memory opts\n    ) internal returns (Pair memory) {\n        uint128 liquidityToPull;\n        // scope the code below to avoid stack-too-deep exception\n        {\n            (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = _positionManager().positions(uniV3Nft);\n            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n            uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n            uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n            liquidityToPull = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, tokenAmounts[0], tokenAmounts[1]\n            );\n            liquidityToPull = liquidity < liquidityToPull ? liquidity : liquidityToPull;\n            if (liquidityToPull == 0) {\n                return Pair({a0: 0, a1: 0});\n            }\n        }\n        Pair memory minAmounts = Pair({\n            a0: opts.amount0Min,\n            a1: opts.amount1Min\n        });\n        (uint256 amount0, uint256 amount1) = _positionManager().decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: uniV3Nft,\n                liquidity: liquidityToPull,\n                amount0Min: minAmounts.a0,\n                amount1Min: minAmounts.a1,\n                deadline: opts.deadline\n            })\n        );\n        (uint256 amount0Collected, uint256 amount1Collected) = _positionManager().collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: uniV3Nft,\n                recipient: to,\n                amount0Max: uint128(amount0),\n                amount1Max: uint128(amount1)\n            })\n        );\n        return Pair({a0: amount0Collected, a1: amount1Collected});\n    }\n\n    function _postReclaimTokens(address, address[] memory tokens) internal view override {}\n\n    /// TODO: make a virtual function here? Or other better approach\n    function _positionManager() internal view returns (INonfungiblePositionManager) {\n        return IUniV3VaultGovernance(address(_vaultGovernance)).delayedProtocolParams().positionManager;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(_positionManager()), address(this)) < type(uint256).max / 2)\n            IERC20(token).approve(address(_positionManager()), type(uint256).max);\n    }\n\n    function _parseOptions(bytes memory options) internal view returns (Options memory) {\n        if (options.length == 0)\n            return Options({amount0Min: 0, amount1Min: 0, deadline: block.timestamp + 600});\n\n        require(options.length == 32 * 3, ExceptionsLibrary.IO_LENGTH);\n        return abi.decode(options, (Options));\n    }\n\n    function _isStrategy(address addr) internal view returns (bool) {\n        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;\n    }\n\n    event CollectedEarnings(address indexed origin, address indexed to, uint256 amount0, uint256 amount1);\n}\nabstract contract VaultGovernance is IVaultGovernance {\n    InternalParams internal _internalParams;\n    InternalParams private _stagedInternalParams;\n    uint256 internal _internalParamsTimestamp;\n\n    mapping(uint256 => bytes) internal _delayedStrategyParams;\n    mapping(uint256 => bytes) internal _stagedDelayedStrategyParams;\n    mapping(uint256 => uint256) internal _delayedStrategyParamsTimestamp;\n\n    mapping(uint256 => bytes) internal _delayedProtocolPerVaultParams;\n    mapping(uint256 => bytes) internal _stagedDelayedProtocolPerVaultParams;\n    mapping(uint256 => uint256) internal _delayedProtocolPerVaultParamsTimestamp;\n\n    bytes internal _delayedProtocolParams;\n    bytes internal _stagedDelayedProtocolParams;\n    uint256 internal _delayedProtocolParamsTimestamp;\n\n    mapping(uint256 => bytes) internal _strategyParams;\n    bytes internal _protocolParams;\n\n    IVaultFactory public factory;\n    bool public initialized;\n\n    /// @notice Creates a new contract.\n    /// @param internalParams_ Initial Internal Params\n    constructor(InternalParams memory internalParams_) {\n        _internalParams = internalParams_;\n    }\n\n    // -------------------  PUBLIC, VIEW  -------------------\n\n    /// @inheritdoc IVaultGovernance\n    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256) {\n        return _delayedStrategyParamsTimestamp[nft];\n    }\n\n    /// @inheritdoc IVaultGovernance\n    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256) {\n        return _delayedProtocolPerVaultParamsTimestamp[nft];\n    }\n\n    /// @inheritdoc IVaultGovernance\n    function delayedProtocolParamsTimestamp() external view returns (uint256) {\n        return _delayedProtocolParamsTimestamp;\n    }\n\n    /// @inheritdoc IVaultGovernance\n    function internalParamsTimestamp() external view returns (uint256) {\n        return _internalParamsTimestamp;\n    }\n\n    /// @inheritdoc IVaultGovernance\n    function internalParams() external view returns (InternalParams memory) {\n        return _internalParams;\n    }\n\n    /// @inheritdoc IVaultGovernance\n    function stagedInternalParams() external view returns (InternalParams memory) {\n        return _stagedInternalParams;\n    }\n\n    // -------------------  PUBLIC, MUTATING  -------------------\n\n    /// @inheritdoc IVaultGovernance\n    function initialize(IVaultFactory factory_) external {\n        require(!initialized, ExceptionsLibrary.INITIALIZATION);\n        factory = factory_;\n        initialized = true;\n    }\n\n    /// @inheritdoc IVaultGovernance\n    function deployVault(\n        address[] memory vaultTokens,\n        bytes memory options,\n        address owner\n    ) public virtual returns (IVault vault, uint256 nft) {\n        require(initialized, ExceptionsLibrary.INITIALIZATION);\n        IProtocolGovernance protocolGovernance = IProtocolGovernance(_internalParams.protocolGovernance);\n        require(protocolGovernance.permissionless() || protocolGovernance.isAdmin(msg.sender), ExceptionsLibrary.PERMISSIONLESS_OR_ADMIN);\n        vault = factory.deployVault(vaultTokens, options);\n        address nftOwner = owner;\n        nft = _internalParams.registry.registerVault(address(vault), nftOwner);\n        vault.initialize(nft);\n        emit DeployedVault(tx.origin, msg.sender, vaultTokens, options, nftOwner, address(vault), nft);\n    }\n\n    /// @inheritdoc IVaultGovernance\n    function stageInternalParams(InternalParams memory newParams) external {\n        _requireProtocolAdmin();\n        _stagedInternalParams = newParams;\n        _internalParamsTimestamp = block.timestamp + _internalParams.protocolGovernance.governanceDelay();\n        emit StagedInternalParams(tx.origin, msg.sender, newParams, _internalParamsTimestamp);\n    }\n\n    /// @inheritdoc IVaultGovernance\n    function commitInternalParams() external {\n        _requireProtocolAdmin();\n        require(_internalParamsTimestamp > 0, ExceptionsLibrary.NULL);\n        require(block.timestamp >= _internalParamsTimestamp, ExceptionsLibrary.TIMESTAMP);\n        _internalParams = _stagedInternalParams;\n        delete _internalParamsTimestamp;\n        emit CommitedInternalParams(tx.origin, msg.sender, _internalParams);\n    }\n\n    // -------------------  INTERNAL  -------------------\n\n    /// @notice Set Delayed Strategy Params\n    /// @param nft Nft of the vault\n    /// @param params New params\n    function _stageDelayedStrategyParams(uint256 nft, bytes memory params) internal {\n        _requireAtLeastStrategy(nft);\n        _stagedDelayedStrategyParams[nft] = params;\n        uint256 delayFactor = _delayedStrategyParams[nft].length == 0 ? 0 : 1;\n        _delayedStrategyParamsTimestamp[nft] =\n            block.timestamp +\n            _internalParams.protocolGovernance.governanceDelay() *\n            delayFactor;\n    }\n\n    /// @notice Commit Delayed Strategy Params\n    function _commitDelayedStrategyParams(uint256 nft) internal {\n        _requireAtLeastStrategy(nft);\n        require(_delayedStrategyParamsTimestamp[nft] > 0, ExceptionsLibrary.NULL);\n        require(block.timestamp >= _delayedStrategyParamsTimestamp[nft], ExceptionsLibrary.TIMESTAMP);\n        _delayedStrategyParams[nft] = _stagedDelayedStrategyParams[nft];\n        delete _stagedDelayedStrategyParams[nft];\n        delete _delayedStrategyParamsTimestamp[nft];\n    }\n\n    /// @notice Set Delayed Protocol Per Vault Params\n    /// @param nft Nft of the vault\n    /// @param params New params\n    function _stageDelayedProtocolPerVaultParams(uint256 nft, bytes memory params) internal {\n        _requireProtocolAdmin();\n        _stagedDelayedProtocolPerVaultParams[nft] = params;\n        uint256 delayFactor = _delayedProtocolPerVaultParams[nft].length == 0 ? 0 : 1;\n        _delayedProtocolPerVaultParamsTimestamp[nft] =\n            block.timestamp +\n            _internalParams.protocolGovernance.governanceDelay() *\n            delayFactor;\n    }\n\n    /// @notice Commit Delayed Protocol Per Vault Params\n    function _commitDelayedProtocolPerVaultParams(uint256 nft) internal {\n        _requireProtocolAdmin();\n        require(_delayedProtocolPerVaultParamsTimestamp[nft] > 0, ExceptionsLibrary.NULL);\n        require(block.timestamp >= _delayedProtocolPerVaultParamsTimestamp[nft], ExceptionsLibrary.TIMESTAMP);\n        _delayedProtocolPerVaultParams[nft] = _stagedDelayedProtocolPerVaultParams[nft];\n        delete _stagedDelayedProtocolPerVaultParams[nft];\n        delete _delayedProtocolPerVaultParamsTimestamp[nft];\n    }\n\n    /// @notice Set Delayed Protocol Params\n    /// @param params New params\n    function _stageDelayedProtocolParams(bytes memory params) internal {\n        _requireProtocolAdmin();\n        uint256 delayFactor = _delayedProtocolParams.length == 0 ? 0 : 1;\n        _stagedDelayedProtocolParams = params;\n        _delayedProtocolParamsTimestamp =\n            block.timestamp +\n            _internalParams.protocolGovernance.governanceDelay() *\n            delayFactor;\n    }\n\n    /// @notice Commit Delayed Protocol Params\n    function _commitDelayedProtocolParams() internal {\n        _requireProtocolAdmin();\n        require(_delayedProtocolParamsTimestamp > 0, ExceptionsLibrary.NULL);\n        require(block.timestamp >= _delayedProtocolParamsTimestamp, ExceptionsLibrary.TIMESTAMP);\n        _delayedProtocolParams = _stagedDelayedProtocolParams;\n        delete _stagedDelayedProtocolParams;\n        delete _delayedProtocolParamsTimestamp;\n    }\n\n    /// @notice Set immediate strategy params\n    /// @dev Should require nft > 0\n    /// @param nft Nft of the vault\n    /// @param params New params\n    function _setStrategyParams(uint256 nft, bytes memory params) internal {\n        _requireAtLeastStrategy(nft);\n        _strategyParams[nft] = params;\n    }\n\n    /// @notice Set immediate protocol params\n    /// @param params New params\n    function _setProtocolParams(bytes memory params) internal {\n        _requireProtocolAdmin();\n        _protocolParams = params;\n    }\n\n    function _requireAtLeastStrategy(uint256 nft) internal view {\n        require(\n            (_internalParams.protocolGovernance.isAdmin(msg.sender) ||\n                _internalParams.registry.getApproved(nft) == msg.sender ||\n                (_internalParams.registry.ownerOf(nft) == msg.sender)),\n            ExceptionsLibrary.REQUIRE_AT_LEAST_ADMIN\n        );\n    }\n\n    function _requireProtocolAdmin() internal view {\n        require(_internalParams.protocolGovernance.isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n    }\n\n    /// @notice Emitted when InternalParams are staged for commit\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param params New params that were staged for commit\n    /// @param when When the params could be committed\n    event StagedInternalParams(address indexed origin, address indexed sender, InternalParams params, uint256 when);\n\n    /// @notice Emitted when InternalParams are staged for commit\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param params New params that were staged for commit\n    event CommitedInternalParams(address indexed origin, address indexed sender, InternalParams params);\n\n    /// @notice Emitted when New Vault is deployed\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param vaultTokens Vault tokens for this vault\n    /// @param options Options for deploy. The details of the options structure are specified in subcontracts\n    /// @param owner Owner of the VaultRegistry NFT for this vault\n    /// @param vaultAddress Address of the new Vault\n    /// @param vaultNft VaultRegistry NFT for the new Vault\n    event DeployedVault(\n        address indexed origin,\n        address indexed sender,\n        address[] vaultTokens,\n        bytes options,\n        address owner,\n        address vaultAddress,\n        uint256 vaultNft\n    );\n}\ncontract UniV3VaultFactory is IVaultFactory {\n    IVaultGovernance public vaultGovernance;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind\n    constructor(IVaultGovernance vaultGovernance_) {\n        vaultGovernance = vaultGovernance_;\n    }\n\n    /// @notice Deploy a new vault.\n    /// @param vaultTokens ERC20 tokens under vault management\n    /// @param options Should equal UniV3 pool fee\n    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {\n        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        uint256 fee = abi.decode(options, (uint256));\n        UniV3Vault vault = new UniV3Vault(vaultGovernance, vaultTokens, uint24(fee));\n        return IVault(vault);\n    }\n}\ncontract DefaultAccessControl is IDefaultAccessControl, AccessControlEnumerable {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"admin\");\n    bytes32 public constant ADMIN_DELEGATE_ROLE = keccak256(\"admin_delegate\");\n\n    /// @notice Creates a new contract.\n    /// @param admin Admin of the contract\n    constructor(address admin) {\n        require(admin != address(0), ExceptionsLibrary.ADMIN_ADDRESS_ZERO);\n        _setupRole(ADMIN_ROLE, admin);\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(ADMIN_DELEGATE_ROLE, ADMIN_ROLE);\n    }\n\n    /// @notice Checks if the address is contract admin.\n    /// @param sender Adddress to check\n    /// @return `true` if sender is an admin, `false` otherwise\n    function isAdmin(address sender) public view returns (bool) {\n        return hasRole(ADMIN_ROLE, sender) || hasRole(ADMIN_DELEGATE_ROLE, sender);\n    }\n}\ncontract LpIssuer is IERC721Receiver, ILpIssuer, ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    uint256 private _subvaultNft;\n    IVaultGovernance internal _vaultGovernance;\n    address[] internal _vaultTokens;\n    mapping(address => bool) internal _vaultTokensIndex;\n    uint256 private _nft;\n    uint256[] private _lpPriceHighWaterMarks;\n    uint256[] private _existentials;\n\n    uint256 public lastFeeCharge;\n\n    /// @notice Creates a new contract.\n    /// @dev All subvault nfts must be owned by this vault before.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param name_ Name of the ERC-721 token\n    /// @param symbol_ Symbol of the ERC-721 token\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) {\n        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);\n        _vaultGovernance = vaultGovernance_;\n        _vaultTokens = vaultTokens_;\n        for (uint256 i = 0; i < vaultTokens_.length; i++) {\n            address token = vaultTokens_[i];\n            _vaultTokensIndex[token] = true;\n            _lpPriceHighWaterMarks.push(0);\n            _existentials.push(10**(ERC20(token).decimals() / 2));\n        }\n        lastFeeCharge = block.timestamp;\n    }\n\n    function vaultGovernance() external view returns (IVaultGovernance) {\n        return _vaultGovernance;\n    }\n\n    function vaultTokens() external view returns (address[] memory) {\n        return _vaultTokens;\n    }\n\n    function existentials() external view returns (uint256[] memory) {\n        return _existentials;\n    }\n\n    /// @inheritdoc ILpIssuer\n    function subvaultNft() external view returns (uint256) {\n        return _subvaultNft;\n    }\n\n    function nft() external view returns (uint256) {\n        return _nft;\n    }\n\n    function initialize(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(nft_> 0, ExceptionsLibrary.NFT_ZERO);\n        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);\n        _nft = nft_;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        registry.setApprovalForAll(address(registry), true);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external nonReentrant {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 thisNft = _nft;\n        require(thisNft > 0, ExceptionsLibrary.INITIALIZATION);\n        require(_subvaultNft > 0, ExceptionsLibrary.INITIALIZE_SUB_VAULT);\n        require(registry.ownerOf(thisNft) == address(this), ExceptionsLibrary.INITIALIZE_OWNER);\n        IVault subvault = _subvault();\n        uint256[] memory existentials_ = _existentials;\n        uint256[] memory tvl = subvault.tvl(); //pre-money\n        uint256 supply = totalSupply();\n        uint256 balanceFactor = CommonLibrary.PRICE_DENOMINATOR;\n        if (supply > 0) {\n            // This is lpTokens if total supply == CommonLibrary.PRICE_DENOMINATOR\n            balanceFactor = _getLpAmount(tvl, tokenAmounts, existentials_, CommonLibrary.PRICE_DENOMINATOR);\n        }\n\n        // If with that big supply we don't reveive any lps then it doesn't make sense to continue\n        require(balanceFactor > 0, \"BF\");\n        uint256[] memory balancedAmounts = new uint256[](tokenAmounts.length);\n\n        // Making sure the proportion between tokenAmounts and tvl are the same\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            balancedAmounts[i] = _getBalancedAmount(tvl[i], tokenAmounts[i], existentials_[i], balanceFactor, supply);\n            _allowTokenIfNecessary(_vaultTokens[i], address(subvault));\n            IERC20(_vaultTokens[i]).safeTransferFrom(msg.sender, address(this), balancedAmounts[i]);\n        }\n\n        uint256[] memory actualTokenAmounts = subvault.transferAndPush(\n            address(this),\n            _vaultTokens,\n            balancedAmounts,\n            options\n        );\n        uint256 amountToMint = _getLpAmount(tvl, actualTokenAmounts, existentials_, supply);\n\n        require(amountToMint > 0, \"ZLP\");\n\n        require(\n            amountToMint + balanceOf(msg.sender) <=\n                ILpIssuerGovernance(address(_vaultGovernance)).strategyParams(thisNft).tokenLimitPerAddress,\n            ExceptionsLibrary.LIMIT_PER_ADDRESS\n        );\n\n        _chargeFees(thisNft, tvl, supply, actualTokenAmounts, amountToMint, false);\n        _mint(msg.sender, amountToMint);\n\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (balancedAmounts[i] > actualTokenAmounts[i]) {\n                IERC20(_vaultTokens[i]).safeTransfer(msg.sender, balancedAmounts[i] - actualTokenAmounts[i]);\n            }\n        }\n\n        emit Deposit(msg.sender, _vaultTokens, actualTokenAmounts, amountToMint);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function withdraw(\n        address to,\n        uint256 lpTokenAmount,\n        bytes memory options\n    ) external nonReentrant {\n        uint256 supply = totalSupply();\n        require(supply > 0, ExceptionsLibrary.TOTAL_SUPPLY_IS_ZERO);\n        uint256[] memory tokenAmounts = new uint256[](_vaultTokens.length);\n        uint256[] memory tvl = _subvault().tvl();\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            tokenAmounts[i] = (lpTokenAmount * tvl[i]) / supply;\n        }\n        uint256[] memory actualTokenAmounts = _subvault().pull(address(this), _vaultTokens, tokenAmounts, options);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (actualTokenAmounts[i] == 0) {\n                continue;\n            }\n            IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);\n        }\n        _chargeFees(_nft, tvl, supply, actualTokenAmounts, lpTokenAmount, true);\n        _burn(msg.sender, lpTokenAmount);\n        emit Withdraw(msg.sender, _vaultTokens, actualTokenAmounts, lpTokenAmount);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function addSubvault(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(_subvaultNft == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);\n        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n        _subvaultNft = nft_;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external nonReentrant returns (bytes4) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        registry.lockNft(tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    function _allowTokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(address(to), address(this)) < type(uint256).max / 2) {\n            IERC20(token).approve(address(to), type(uint256).max);\n        }\n    }\n\n    function _subvault() internal view returns (IVault) {\n        return IVault(_vaultGovernance.internalParams().registry.vaultForNft(_subvaultNft));\n    }\n\n    /// @dev We don't charge on any deposit / withdraw to save gas.\n    /// While this introduce some error, the charge always goes for lower lp token supply (pre-deposit / post-withdraw)\n    /// So the error results in slightly lower management fees than in exact case\n    function _chargeFees(\n        uint256 thisNft,\n        uint256[] memory tvls,\n        uint256 supply,\n        uint256[] memory deltaTvls,\n        uint256 deltaSupply,\n        bool isWithdraw\n    ) internal {\n        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));\n        uint256 elapsed = block.timestamp - lastFeeCharge;\n        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n            return;\n        }\n        lastFeeCharge = block.timestamp;\n        uint256 baseSupply = supply;\n        if (isWithdraw) {\n            baseSupply = 0;\n            if (supply > deltaSupply) {\n                baseSupply = supply - deltaSupply;\n            }\n        }\n\n        if (baseSupply == 0) {\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;\n            }\n            return;\n        }\n\n        uint256[] memory baseTvls = new uint256[](tvls.length);\n        for (uint256 i = 0; i < baseTvls.length; i++) {\n            if (isWithdraw) {\n                baseTvls[i] = tvls[i] - deltaTvls[i];\n            } else {\n                baseTvls[i] = tvls[i];\n            }\n        }\n\n        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);\n        if (strategyParams.managementFee > 0) {\n            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /\n                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(strategyParams.strategyTreasury, toMint);\n            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);\n        }\n        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;\n        if (protocolFee > 0) {\n            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();\n            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(treasury, toMint);\n            emit ProtocolFeesCharged(treasury, protocolFee, toMint);\n        }\n        uint256 performanceFee = strategyParams.performanceFee;\n        uint256[] memory hwms = _lpPriceHighWaterMarks;\n        if (performanceFee > 0) {\n            uint256 minLpPriceFactor = type(uint256).max;\n            for (uint256 i = 0; i < baseTvls.length; i++) {\n                uint256 hwm = hwms[i];\n                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;\n                if (lpPrice > hwm) {\n                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;\n                    if (delta < minLpPriceFactor) {\n                        minLpPriceFactor = delta;\n                    }\n                } else {\n                    // not eligible for performance fees\n                    return;\n                }\n            }\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            }\n            address treasury = strategyParams.strategyPerformanceTreasury;\n            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            _mint(treasury, toMint);\n            emit PerformanceFeesCharged(treasury, performanceFee, toMint);\n        }\n    }\n\n    function _getLpAmount(\n        uint256[] memory tvl,\n        uint256[] memory amounts,\n        uint256[] memory existentials_,\n        uint256 supply\n    ) internal pure returns (uint256 lpAmount) {\n        lpAmount = 0;\n        if (supply == 0) {\n            // On init lpToken = max(tokenAmounts)\n            for (uint256 i = 0; i < tvl.length; i++) {\n                if (amounts[i] > lpAmount) {\n                    lpAmount = amounts[i];\n                }\n            }\n            return lpAmount;\n        }\n        for (uint256 i = 0; i < tvl.length; i++) {\n            if (amounts[i] <= existentials_[i]) {\n                // skip existential deposits for lp share calculation\n                continue;\n            }\n            uint256 tokenLpAmount = (amounts[i] * supply) / tvl[i];\n            // take min of meaningful tokenLp amounts\n            if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {\n                lpAmount = tokenLpAmount;\n            }\n        }\n    }\n\n    function _getBalancedAmount(\n        uint256 tvl,\n        uint256 amount,\n        uint256 existential,\n        uint256 balanceFactor,\n        uint256 supply\n    ) internal pure returns (uint256) {\n        if (supply == 0) {\n            // skip normalization on init\n            return amount;\n        }\n        if (amount < existential) {\n            // avoid putting small amounts as it can introduce unnecessary harsh errors\n            // one should provide amount > existential deposit each time tvl is not 0\n            require(tvl == 0, \"PN\");\n            return 0;\n        }\n        // normalize amount\n        uint256 res = (tvl * balanceFactor) / CommonLibrary.PRICE_DENOMINATOR;\n        if (res > amount) {\n            res = amount;\n        }\n        return res;\n    }\n\n    /// @notice Emitted when management fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ManagementFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when protocol fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ProtocolFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when performance fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event PerformanceFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when liquidity is deposited\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens deposited\n    /// @param actualTokenAmounts Token amounts deposited\n    /// @param lpTokenMinted LP tokens received by the liquidity provider\n    event Deposit(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenMinted);\n\n    /// @notice Emitted when liquidity is withdrawn\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens withdrawn\n    /// @param actualTokenAmounts Token amounts withdrawn\n    /// @param lpTokenBurned LP tokens burned from the liquidity provider\n    event Withdraw(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenBurned);\n}\ncontract UniV3VaultGovernance is IUniV3VaultGovernance, VaultGovernance {\n    /// @notice Creates a new contract.\n    /// @param internalParams_ Initial Internal Params\n    /// @param delayedProtocolParams_ Initial Protocol Params\n    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)\n        VaultGovernance(internalParams_)\n    {\n        _delayedProtocolParams = abi.encode(delayedProtocolParams_);\n    }\n\n    /// @inheritdoc IUniV3VaultGovernance\n    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {\n        if (_delayedProtocolParams.length == 0) {\n            return DelayedProtocolParams({positionManager: INonfungiblePositionManager(address(0))});\n        }\n        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));\n    }\n\n    /// @inheritdoc IUniV3VaultGovernance\n    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {\n        if (_stagedDelayedProtocolParams.length == 0) {\n            return DelayedProtocolParams({positionManager: INonfungiblePositionManager(address(0))});\n        }\n        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));\n    }\n\n    /// @inheritdoc IUniV3VaultGovernance\n    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {\n        _stageDelayedProtocolParams(abi.encode(params));\n        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);\n    }\n\n    /// @inheritdoc IUniV3VaultGovernance\n    function commitDelayedProtocolParams() external {\n        _commitDelayedProtocolParams();\n        emit CommitDelayedProtocolParams(\n            tx.origin,\n            msg.sender,\n            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))\n        );\n    }\n\n    /// @notice Emitted when new DelayedProtocolParams are staged for commit\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param params New params that were staged for commit\n    /// @param when When the params could be committed\n    event StageDelayedProtocolParams(\n        address indexed origin,\n        address indexed sender,\n        DelayedProtocolParams params,\n        uint256 when\n    );\n    /// @notice Emitted when new DelayedProtocolParams are committed\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param params New params that are committed\n    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);\n}\ncontract LpIssuerGovernance is IERC721Receiver, ILpIssuerGovernance, VaultGovernance {\n    uint256 public immutable MAX_PROTOCOL_FEE;\n    uint256 public immutable MAX_MANAGEMENT_FEE;\n    uint256 public immutable MAX_PERFORMANCE_FEE;\n\n    /// @notice Creates a new contract.\n    /// @param internalParams_ Initial Internal Params\n    /// @param delayedProtocolParams_ Initial Protocol Params\n    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)\n        VaultGovernance(internalParams_)\n    {\n        _delayedProtocolParams = abi.encode(delayedProtocolParams_);\n        MAX_PROTOCOL_FEE = 5 * CommonLibrary.DENOMINATOR;\n        MAX_MANAGEMENT_FEE = 10 * CommonLibrary.DENOMINATOR;\n        MAX_PERFORMANCE_FEE = 50 * CommonLibrary.DENOMINATOR;\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {\n        if (_delayedProtocolParams.length == 0) {\n            return DelayedProtocolParams({managementFeeChargeDelay: 0});\n        }\n        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {\n        if (_stagedDelayedProtocolParams.length == 0) {\n            return DelayedProtocolParams({managementFeeChargeDelay: 0});\n        }\n        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory) {\n        if (_delayedProtocolPerVaultParams[nft].length == 0) {\n            return DelayedProtocolPerVaultParams({protocolFee: 0});\n        }\n        return abi.decode(_delayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams));\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function stagedDelayedProtocolPerVaultParams(uint256 nft)\n        external\n        view\n        returns (DelayedProtocolPerVaultParams memory)\n    {\n        if (_stagedDelayedProtocolPerVaultParams[nft].length == 0) {\n            return DelayedProtocolPerVaultParams({protocolFee: 0});\n        }\n        return abi.decode(_stagedDelayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams));\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {\n        if (_stagedDelayedStrategyParams[nft].length == 0) {\n            return\n                DelayedStrategyParams({\n                    strategyTreasury: address(0),\n                    strategyPerformanceTreasury: address(0),\n                    managementFee: 0,\n                    performanceFee: 0\n                });\n        }\n        return abi.decode(_stagedDelayedStrategyParams[nft], (DelayedStrategyParams));\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {\n        if (_delayedStrategyParams[nft].length == 0) {\n            return\n                DelayedStrategyParams({\n                    strategyTreasury: address(0),\n                    strategyPerformanceTreasury: address(0),\n                    managementFee: 0,\n                    performanceFee: 0\n                });\n        }\n        return abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams));\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function strategyParams(uint256 nft) external view returns (StrategyParams memory) {\n        if (_strategyParams[nft].length == 0) {\n            return StrategyParams({tokenLimitPerAddress: 0});\n        }\n        return abi.decode(_strategyParams[nft], (StrategyParams));\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external {\n        require(params.managementFee <= MAX_MANAGEMENT_FEE, ExceptionsLibrary.MAX_MANAGEMENT_FEE);\n        require(params.performanceFee <= MAX_PERFORMANCE_FEE, ExceptionsLibrary.MAX_PERFORMANCE_FEE);\n        _stageDelayedStrategyParams(nft, abi.encode(params));\n        emit StageDelayedStrategyParams(tx.origin, msg.sender, nft, params, _delayedStrategyParamsTimestamp[nft]);\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function commitDelayedStrategyParams(uint256 nft) external {\n        _commitDelayedStrategyParams(nft);\n        emit CommitDelayedStrategyParams(\n            tx.origin,\n            msg.sender,\n            nft,\n            abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams))\n        );\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external {\n        require(params.protocolFee <= MAX_PROTOCOL_FEE, ExceptionsLibrary.MAX_PROTOCOL_FEE);\n        _stageDelayedProtocolPerVaultParams(nft, abi.encode(params));\n        emit StageDelayedProtocolPerVaultParams(\n            tx.origin,\n            msg.sender,\n            nft,\n            params,\n            _delayedStrategyParamsTimestamp[nft]\n        );\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function commitDelayedProtocolPerVaultParams(uint256 nft) external {\n        _commitDelayedProtocolPerVaultParams(nft);\n        emit CommitDelayedProtocolPerVaultParams(\n            tx.origin,\n            msg.sender,\n            nft,\n            abi.decode(_delayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams))\n        );\n    }\n\n    function setStrategyParams(uint256 nft, StrategyParams calldata params) external {\n        _setStrategyParams(nft, abi.encode(params));\n        emit SetStrategyParams(tx.origin, msg.sender, nft, params);\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {\n        _stageDelayedProtocolParams(abi.encode(params));\n        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);\n    }\n\n    /// @inheritdoc ILpIssuerGovernance\n    function commitDelayedProtocolParams() external {\n        _commitDelayedProtocolParams();\n        emit CommitDelayedProtocolParams(\n            tx.origin,\n            msg.sender,\n            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))\n        );\n    }\n\n    /// @notice Required for intermediate vault token transfer in deploy\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external view returns (bytes4) {\n        IVaultRegistry registry = _internalParams.registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        return this.onERC721Received.selector;\n    }\n\n    /// @notice Deploy a new vault.\n    /// @param vaultTokens ERC20 tokens under vault management\n    /// @param options Abi encoded uint256 - an nfts of the gateway subvault. It is required that nft subvault is approved by the caller to this address and that it is a gateway vault\n    /// @return vault Address of the new vault\n    /// @return nft Nft of the vault in the vault registry\n    function deployVault(\n        address[] memory vaultTokens,\n        bytes memory options,\n        address\n    ) public override(VaultGovernance, IVaultGovernance) returns (IVault vault, uint256 nft) {\n        (uint256 subvaultNft, string memory name, string memory symbol) = abi.decode(\n            options,\n            (uint256, string, string)\n        );\n        (vault, nft) = super.deployVault(vaultTokens, abi.encode(name, symbol), msg.sender);\n        IVaultRegistry registry = _internalParams.registry;\n        ILpIssuer(address(vault)).addSubvault(subvaultNft);\n        registry.safeTransferFrom(msg.sender, address(vault), subvaultNft);\n    }\n\n    /// @notice Emitted when new DelayedProtocolPerVaultParams are staged for commit\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param nft VaultRegistry NFT of the vault\n    /// @param params New params that were staged for commit\n    /// @param when When the params could be committed\n    event StageDelayedProtocolPerVaultParams(\n        address indexed origin,\n        address indexed sender,\n        uint256 indexed nft,\n        DelayedProtocolPerVaultParams params,\n        uint256 when\n    );\n\n    /// @notice Emitted when new DelayedProtocolPerVaultParams are committed\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param nft VaultRegistry NFT of the vault\n    /// @param params New params that are committed\n    event CommitDelayedProtocolPerVaultParams(\n        address indexed origin,\n        address indexed sender,\n        uint256 indexed nft,\n        DelayedProtocolPerVaultParams params\n    );\n\n    /// @notice Emitted when new DelayedStrategyParams are staged for commit\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param nft VaultRegistry NFT of the vault\n    /// @param params New params that were staged for commit\n    /// @param when When the params could be committed\n    event StageDelayedStrategyParams(\n        address indexed origin,\n        address indexed sender,\n        uint256 indexed nft,\n        DelayedStrategyParams params,\n        uint256 when\n    );\n\n    /// @notice Emitted when new DelayedStrategyParams are committed\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param nft VaultRegistry NFT of the vault\n    /// @param params New params that are committed\n    event CommitDelayedStrategyParams(\n        address indexed origin,\n        address indexed sender,\n        uint256 indexed nft,\n        DelayedStrategyParams params\n    );\n\n    /// @notice Emitted when new StrategyParams are set.\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param nft VaultRegistry NFT of the vault\n    /// @param params New params that are set\n    event SetStrategyParams(address indexed origin, address indexed sender, uint256 indexed nft, StrategyParams params);\n\n    /// @notice Emitted when new DelayedProtocolParams are staged for commit\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param params New params that were staged for commit\n    /// @param when When the params could be committed\n    event StageDelayedProtocolParams(\n        address indexed origin,\n        address indexed sender,\n        DelayedProtocolParams params,\n        uint256 when\n    );\n\n    /// @notice Emitted when new DelayedProtocolParams are committed\n    /// @param origin Origin of the transaction\n    /// @param sender Sender of the transaction\n    /// @param params New params that are committed\n    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);\n}\n",
    "bin": []
}