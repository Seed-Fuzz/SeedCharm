{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/60/protocol",
    "external_functions": [
        [
            "Collateral",
            "IProduct",
            "IFactory"
        ],
        [],
        [
            "Factory",
            "IProduct"
        ],
        [
            "UFactoryProvider"
        ],
        [
            "Incentivizer",
            "IFactory",
            "IProductProvider",
            "IProduct"
        ],
        [],
        [],
        [
            "ChainlinkOracle",
            "IChainlinkFeed"
        ],
        [
            "Product",
            "IFactory",
            "IProductProvider",
            "ICollateral",
            "IIncentivizer"
        ],
        [
            "ProductProviderBase",
            "IOracle"
        ],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [
            "UOwnable"
        ],
        [
            "UReentrancyGuard"
        ]
    ],
    "new_contract": "contract ChainlinkOracle is IOracle, UOwnable {\n\n    event MinDelayUpdated(uint256 newMinDelay);\n\n    /// @dev Chainlink price feed to read from\n    IChainlinkFeed public feed;\n\n    /// @dev Mapping of historical price at each oracle version\n    Fixed18[] public priceAtVersion;\n\n    /// @dev Mapping of historical timestamp at each oracle version\n    uint256[] public timestampAtVersion;\n\n    /// @dev Decimal offset used to normalize chainlink price to 18 decimals\n    uint256 private _decimalOffset;\n\n    /// @dev Minimum timestamp delay before committed a new version\n    uint256 public minDelay;\n\n    /**\n     * @notice Initializes the contract state\n     * @param feed_ Chainlink price feed\n     */\n    constructor(IChainlinkFeed feed_) {\n        feed = feed_;\n        _decimalOffset = 10 ** feed_.decimals();\n        minDelay = 30 minutes;\n\n        sync();\n        UOwnable__initialize();\n    }\n\n    /**\n     * @notice Checks for a new price and updates the oracle version if one is found\n     */\n    function sync() public {\n        (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();\n        Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));\n\n        if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {\n            priceAtVersion.push(price);\n            timestampAtVersion.push(timestamp);\n\n            emit Version(currentVersion(), timestamp, price);\n        }\n    }\n\n    /**\n     * @notice Returns the current oracle version\n     * @return Current oracle version\n     */\n    function currentVersion() public view returns (uint256) {\n        return priceAtVersion.length - 1;\n    }\n\n    /**\n     * @notice Updates the minimum delay before a new version can be committed\n     * @param newMinDelay New minimum delay\n     */\n    function updateMinDelay(uint256 newMinDelay) onlyOwner external {\n        minDelay = newMinDelay;\n        emit MinDelayUpdated(newMinDelay);\n    }\n}\nabstract contract UReentrancyGuard {\n    error UReentrancyGuardReentrantCallError();\n\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    /**\n     * @dev unstructured storage slot for the reentrancy status\n     */\n    bytes32 private constant STATUS_SLOT = keccak256(\"equilibria.utils.UReentrancyGuard.status\");\n\n    /**\n     * @dev Initializes the contract setting the status to _NOT_ENTERED.\n     */\n    function UReentrancyGuard__initialize() internal {\n        _setStatus(_NOT_ENTERED);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function _status() private view returns (uint256 result) {\n        bytes32 slot = STATUS_SLOT;\n        assembly {\n            result := sload(slot)\n        }\n    }\n\n    function _setStatus(uint256 newStatus) private {\n        bytes32 slot = STATUS_SLOT;\n        assembly {\n            sstore(slot, newStatus)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        if (_status() == _ENTERED) revert UReentrancyGuardReentrantCallError();\n\n        // Any calls to nonReentrant after this point will fail\n        _setStatus(_ENTERED);\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _setStatus(_NOT_ENTERED);\n    }\n}\nabstract contract UFactoryProvider {\n    error AlreadyInitializedError();\n    error NotOwnerError(address sender);\n    error NotProductError(address sender);\n    error NotCollateralError(address sender);\n    error NotControllerOwnerError(address sender, uint256 controllerId);\n    error NotProductOwnerError(address sender, IProduct product);\n    error PausedError();\n\n    /// @dev unstructured storage slot for the factory address\n    bytes32 private constant FACTORY_SLOT = keccak256(\"equilibria.perennial.UFactoryProvider.factory\");\n\n    /**\n     * @notice Initializes the contract state\n     * @param factory_ Protocol Factory contract address\n     */\n    function UFactoryProvider__initialize(IFactory factory_) internal {\n        if (address(factory()) != address(0)) revert AlreadyInitializedError();\n\n        _setFactory(factory_);\n    }\n\n    /**\n     * @notice Reads the protocol Factory contract address from unstructured state\n     * @return result Protocol Factory contract address\n     */\n    function factory() public view virtual returns (IFactory result) {\n        bytes32 slot = FACTORY_SLOT;\n        assembly {\n            result := sload(slot)\n        }\n    }\n\n    /**\n     * @notice Sets the protocol Factory contract address in unstructured state\n     * @dev Internal helper\n     */\n    function _setFactory(IFactory newFactory) private {\n        bytes32 slot = FACTORY_SLOT;\n        assembly {\n            sstore(slot, newFactory)\n        }\n    }\n\n    /// @dev Only allow a valid product contract to call\n    modifier onlyProduct {\n        if (!factory().isProduct(IProduct(msg.sender))) revert NotProductError(msg.sender);\n\n        _;\n    }\n\n    /// @dev Verify that `product` is a valid product contract\n    modifier isProduct(IProduct product) {\n        if (!factory().isProduct(product)) revert NotProductError(address(product));\n\n        _;\n    }\n\n    /// @dev Only allow the Collateral contract to call\n    modifier onlyCollateral {\n        if (msg.sender != address(factory().collateral())) revert NotCollateralError(msg.sender);\n\n        _;\n    }\n\n    /// @dev Only allow the protocol owner contract to call\n    modifier onlyOwner() {\n        if (msg.sender != factory().owner()) revert NotOwnerError(msg.sender);\n\n        _;\n    }\n\n    /// @dev Only allow if the the protocol is currently unpaused\n    modifier notPaused() {\n        if (factory().isPaused()) revert PausedError();\n\n        _;\n    }\n}\ncontract Factory is IFactory {\n\n    /// @dev Whether the factory has been initialized\n    bool public initialized;\n\n    /// @dev Secondary pauser address (not owner, but has permission to update isPaused)\n    address public pauser;\n\n    /// @dev Whether the protocol is currently paused\n    bool public isPaused;\n\n    /// @dev Collateral contract address for the protocol\n    ICollateral public collateral;\n\n    /// @dev Incentivizer contract address for the protocol\n    IIncentivizer public incentivizer;\n\n    /// @dev Base Product implementation contract address for the protocol\n    IProduct public productBase;\n\n    /// @dev List of product controllers\n    Controller[] private _controllers;\n\n    /// @dev Mapping of the controller for each  product\n    mapping(IProduct => uint256) public controllerFor;\n\n    /// @dev Whether a specific controller is allowed to create a new product\n    mapping(uint256 => bool) public allowed;\n\n    /// @dev Percent of the fee that goes to the protocol treasury vs the product treasury\n    UFixed18 public fee;\n\n    /// @dev Minimum allowable funding fee for a product\n    UFixed18 public minFundingFee;\n\n    /// @dev Minimum allowable collateral amount per user account\n    UFixed18 public minCollateral;\n\n    /**\n     * @notice Initializes the contract state\n     * @param collateral_ Collateral contract address\n     * @param incentivizer_ Incentivizer contract address\n     * @param productBase_ Base Product implementation contract address\n     * @param treasury_ Protocol treasury address\n     */\n    function initialize(\n        ICollateral collateral_,\n        IIncentivizer incentivizer_,\n        IProduct productBase_,\n        address treasury_\n    ) external {\n        if (initialized) revert FactoryAlreadyInitializedError();\n\n        createController(treasury_);\n\n        updatePauser(msg.sender);\n        updateCollateral(collateral_);\n        updateIncentivizer(incentivizer_);\n        updateProductBase(productBase_);\n        updateFee(UFixed18Lib.ratio(50, 100));\n        updateMinFundingFee(UFixed18Lib.ratio(10, 100));\n\n        initialized = true;\n    }\n\n    /**\n     * @notice Creates a new controller with `msg.sender` as the owner\n     * @param controllerTreasury Treasury address for the controller\n     * @return New controller ID\n     */\n    function createController(address controllerTreasury) public returns (uint256) {\n        uint256 controllerId = _controllers.length;\n\n        _controllers.push(Controller({\n            owner: msg.sender,\n            treasury: controllerTreasury\n        }));\n\n        emit ControllerCreated(controllerId, msg.sender, controllerTreasury);\n\n        return controllerId;\n    }\n\n    /**\n     * @notice Updates the owner and treasury of an existing controller\n     * @dev Must be called by the controller's current owner\n     * @param controllerId Controller to update\n     * @param newController New controller owner and treasury\n     */\n    function updateController(uint256 controllerId, Controller memory newController) onlyOwner(controllerId) external {\n        _controllers[controllerId] = newController;\n        emit ControllerUpdated(controllerId, newController.owner, newController.treasury);\n    }\n\n    /**\n     * @notice Creates a new product market with `provider`\n     * @dev Controller caller must be allowed\n     * @param controllerId Controller that will own the product\n     * @param provider Provider that will service the market\n     * @return New product contract address\n     */\n    function createProduct(uint256 controllerId, IProductProvider provider) onlyOwner(controllerId) external returns (IProduct) {\n        if (controllerId == 0) revert FactoryNoZeroControllerError();\n        if (!allowed[0] && !allowed[controllerId]) revert FactoryNotAllowedError();\n\n        IProduct newProduct = IProduct(Clones.clone(address(productBase)));\n        newProduct.initialize(provider);\n        controllerFor[newProduct] = controllerId;\n        emit ProductCreated(newProduct, provider);\n\n        return newProduct;\n    }\n\n    /**\n     * @notice Updates the Collateral contract address\n     * @param newCollateral New Collateral contract address\n     */\n    function updateCollateral(ICollateral newCollateral) onlyOwner(0) public {\n        collateral = newCollateral;\n        emit CollateralUpdated(newCollateral);\n    }\n\n    /**\n     * @notice Updates the Incentivizer contract address\n     * @param newIncentivizer New Incentivizer contract address\n     */\n    function updateIncentivizer(IIncentivizer newIncentivizer) onlyOwner(0) public {\n        incentivizer = newIncentivizer;\n        emit IncentivizerUpdated(newIncentivizer);\n    }\n\n    /**\n     * @notice Updates the base Product contract address\n     * @param newProductBase New base Product contract address\n     */\n    function updateProductBase(IProduct newProductBase) onlyOwner(0) public {\n        productBase = newProductBase;\n        emit ProductBaseUpdated(newProductBase);\n    }\n\n    /**\n     * @notice Updates the protocol-product fee split\n     * @param newFee New protocol-product fee split\n     */\n    function updateFee(UFixed18 newFee) onlyOwner(0) public {\n        fee = newFee;\n        emit FeeUpdated(newFee);\n    }\n\n    /**\n     * @notice Updates the minimum allowed funding fee\n     * @param newMinFundingFee New minimum allowed funding fee\n     */\n    function updateMinFundingFee(UFixed18 newMinFundingFee) onlyOwner(0) public {\n        minFundingFee = newMinFundingFee;\n        emit MinFundingFeeUpdated(newMinFundingFee);\n    }\n\n    /**\n     * @notice Updates the minimum allowed collateral amount per user account\n     * @param newMinCollateral New minimum allowed collateral amount\n     */\n    function updateMinCollateral(UFixed18 newMinCollateral) onlyOwner(0) public {\n        minCollateral = newMinCollateral;\n        emit MinCollateralUpdated(newMinCollateral);\n    }\n\n    /**\n     * @notice Updates the secondary pauser address\n     * @param newPauser New secondary pauser address\n     */\n    function updatePauser(address newPauser) onlyOwner(0) public {\n        pauser = newPauser;\n        emit PauserUpdated(newPauser);\n    }\n\n    /**\n     * @notice Updates the protocol pause status\n     * @param newIsPaused New protocol pause status\n     */\n    function updateIsPaused(bool newIsPaused) public {\n        if (msg.sender != owner() && msg.sender != pauser) revert FactoryNotPauserError(msg.sender);\n\n        isPaused = newIsPaused;\n        emit IsPausedUpdated(newIsPaused);\n    }\n\n    /**\n     * @notice Updates whether `controllerId` is allowed to create new products\n     * @param controllerId Controller to update\n     * @param newAllowed New allowed status for `controllerId`\n     */\n    function updateAllowed(uint256 controllerId, bool newAllowed) onlyOwner(0) external {\n        allowed[controllerId] = newAllowed;\n        emit AllowedUpdated(controllerId, newAllowed);\n    }\n\n    /**\n     * @notice Returns whether a contract is a product\n     * @param product Contract address to check\n     * @return Whether a contract is a product\n     */\n    function isProduct(IProduct product) public view returns (bool) {\n        return controllerFor[product] != 0;\n    }\n\n    /**\n     * @notice Returns controller state for controller `controllerId`\n     * @param controllerId Controller to return for\n     * @return Controller state\n     */\n    function controllers(uint256 controllerId) external view returns (Controller memory) {\n        return _controllers[controllerId];\n    }\n\n    /**\n     * @notice Returns the owner of the protocol\n     * @return Owner of the protocol\n     */\n    function owner() public view returns (address) {\n        return owner(0);\n    }\n\n    /**\n     * @notice Returns the owner of the controller `controllerId`\n     * @param controllerId Controller to return for\n     * @return Owner of the controller\n     */\n    function owner(uint256 controllerId) public view returns (address) {\n        return _controllers[controllerId].owner;\n    }\n\n    /**\n     * @notice Returns the owner of the product `product`\n     * @param product Product to return for\n     * @return Owner of the product\n     */\n    function owner(IProduct product) public view returns (address) {\n        return owner(controllerFor[product]);\n    }\n\n    /**\n     * @notice Returns the treasury of the protocol\n     * @return Treasury of the protocol\n     */\n    function treasury() public view returns (address) {\n        return treasury(0);\n    }\n\n    /**\n     * @notice Returns the treasury of the controller `controllerId`\n     * @param controllerId Controller to return for\n     * @return Treasury of the controller\n     */\n    function treasury(uint256 controllerId) public view returns (address) {\n        return _controllers[controllerId].treasury;\n    }\n\n    /**\n     * @notice Returns the treasury of the product `product`\n     * @param product Product to return for\n     * @return Treasury of the product\n     */\n    function treasury(IProduct product) public view returns (address) {\n        return treasury(controllerFor[product]);\n    }\n\n    // @dev Only allow owner of `controllerId` to call\n    modifier onlyOwner(uint256 controllerId) {\n        if (msg.sender != owner(controllerId)) revert FactoryNotOwnerError(controllerId);\n\n        _;\n    }\n}\nabstract contract ProductProviderBase is IProductProvider {\n    IOracle public oracle;\n\n    /**\n     * @notice Initializes the contract state\n     * @param oracle_ Oracle price provider contract address\n     */\n    constructor(IOracle oracle_) {\n        oracle = oracle_;\n    }\n\n    /**\n     * @notice Returns the payoff function given a raw oracle price\n     * @param price Raw oracle price\n     * @return Payoff value\n     */\n    function payoff(Fixed18 price) public view virtual override returns (Fixed18);\n\n    /**\n     * @notice Pass-through hook to call sync() on the oracle provider\n     */\n    function sync() external override {\n        return oracle.sync();\n    }\n\n    /**\n     * @notice Returns the payoff value at oracle version `version`\n     * @param version Oracle version to return for\n     * @return Payoff value at oracle version\n     */\n    function priceAtVersion(uint256 version) external override view returns (Fixed18) {\n        return payoff(oracle.priceAtVersion(version));\n    }\n\n    /**\n     * @notice Returns the timestamp at oracle version `version`\n     * @param version Oracle version to return for\n     * @return Timestamp at oracle version\n     */\n    function timestampAtVersion(uint256 version) external override view returns (uint256) {\n        return oracle.timestampAtVersion(version);\n    }\n\n    /**\n     * @notice Returns the current oracle version\n     * @return Current oracle version\n     */\n    function currentVersion() external override view returns (uint256) {\n        return oracle.currentVersion();\n    }\n}\nabstract contract UOwnable {\n    /**\n     * @dev unstructured storage slot for the owner address\n     */\n    bytes32 private constant OWNER_SLOT = keccak256(\"equilibria.utils.UOwnable.owner\");\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    error UOwnableNotOwnerError(address sender);\n    error UOwnableZeroAddressError();\n\n    /**\n     * @dev Initializes the contract setting the caller as the initial owner.\n     */\n    function UOwnable__initialize() internal {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address result) {\n        bytes32 slot = OWNER_SLOT;\n        assembly {\n            result := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        if (owner() != msg.sender) revert UOwnableNotOwnerError(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) revert UOwnableZeroAddressError();\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner;\n        bytes32 slot = OWNER_SLOT;\n        assembly {\n            oldOwner := sload(slot)\n            sstore(slot, newOwner)\n        }\n\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\ncontract Incentivizer is IIncentivizer, UFactoryProvider, UReentrancyGuard {\n    using UFixed18Lib for UFixed18;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using Token18Lib for Token18;\n    using PositionLib for Position;\n    using AccumulatorLib for Accumulator;\n    using ProgramInfoLib for ProgramInfo;\n    using ProgramLib for Program;\n\n    /// @dev Maximum programs per product allowed\n    uint256 public programsPerProduct;\n\n    /// @dev Fee taken from total program amount\n    UFixed18 public fee;\n\n    /// @dev Static program state\n    ProgramInfo[] private _programInfos;\n\n    /// @dev Dynamic program state\n    mapping(uint256 => Program) private _programs;\n\n    /// @dev Mapping of all programs for each product\n    mapping(IProduct => EnumerableSet.UintSet) private _registry;\n\n    /// @dev Fees that have been collected, but remain unclaimed\n    mapping(Token18 => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the contract state\n     * @param factory_ Factory contract address\n     */\n    function initialize(IFactory factory_) external {\n        UFactoryProvider__initialize(factory_);\n        UReentrancyGuard__initialize();\n\n        programsPerProduct = 2;\n        fee = UFixed18Lib.ZERO;\n    }\n\n    /**\n     * @notice Creates a new incentive program\n     * @dev Must be called as the product or protocol owner\n     * @param info Parameters for the new program\n     * @return new program's ID\n     */\n    function create(ProgramInfo calldata info)\n    nonReentrant\n    isProduct(info.product)\n    notPaused\n    external returns (uint256) {\n        bool protocolOwned = msg.sender == factory().owner();\n\n        if (_registry[info.product].length() >= programsPerProduct) revert IncentivizerTooManyProgramsError();\n        if (!protocolOwned && msg.sender != factory().owner(info.product))\n            revert NotProductOwnerError(msg.sender, info.product);\n\n        uint256 programId = _programInfos.length;\n        (ProgramInfo memory programInfo, UFixed18 programFee) = ProgramInfoLib.create(fee, info);\n\n        _programInfos.push(programInfo);\n        _programs[programId].initialize(programInfo, protocolOwned);\n        _registry[info.product].add(programId);\n        fees[info.token] = fees[info.token].add(programFee);\n\n        info.token.pull(msg.sender, info.amount.sum());\n\n        emit ProgramCreated(\n            programId,\n            programInfo.product,\n            programInfo.token,\n            programInfo.amount.maker,\n            programInfo.amount.taker,\n            programInfo.start,\n            programInfo.duration,\n            programInfo.grace,\n            programFee\n        );\n\n        return programId;\n    }\n\n    /**\n     * @notice Completes an in-progress program early\n     * @dev Must be called as the program owner\n     * @param programId Program to end\n     */\n    function end(uint256 programId)\n    notPaused\n    validProgram(programId)\n    onlyProgramOwner(programId)\n    external {\n        completeInternal(programId);\n    }\n\n    /**\n     * @notice Closes a program, returning all unclaimed rewards\n     * @param programId Program to end\n     */\n    function close(uint256 programId)\n    notPaused\n    validProgram(programId)\n    external {\n        Program storage program = _programs[programId];\n        ProgramInfo storage programInfo = _programInfos[programId];\n\n        if (!program.canClose(programInfo, block.timestamp)) revert IncentivizerProgramNotClosableError();\n\n        // complete if not yet completed\n        if (program.versionComplete == 0) {\n            completeInternal(programId);\n        }\n\n        // close\n        UFixed18 amountToReturn = _programs[programId].close();\n        programInfo.token.push(treasury(programId), amountToReturn);\n        _registry[programInfo.product].remove(programId);\n\n        emit ProgramClosed(programId, amountToReturn);\n    }\n\n    /**\n     * @notice Completes any in-progress programs that newly completable\n     * @dev Called every settle() from each product\n     */\n    function sync() onlyProduct external {\n        IProduct product = IProduct(msg.sender);\n        IProductProvider provider = product.provider();\n\n        uint256 currentTimestamp = provider.timestampAtVersion(provider.currentVersion());\n\n        for (uint256 i; i < _registry[product].length(); i++) {\n            uint256 programId = _registry[product].at(i);\n\n            if (_programs[programId].versionComplete != 0) continue;\n            if (!_programInfos[programId].isComplete(currentTimestamp)) continue;\n\n            completeInternal(programId);\n        }\n    }\n\n    /**\n     * @notice Completes a program\n     * @dev Internal helper\n     * @param programId Program to complete\n     */\n    function completeInternal(uint256 programId) private {\n        uint256 version = _programInfos[programId].product.latestVersion();\n        _programs[programId].complete(version);\n\n        emit ProgramCompleted(programId, version);\n    }\n\n    /**\n     * @notice Settles unsettled balance for `account`\n     * @dev Called immediately proceeding a position update in the corresponding product\n     * @param account Account to sync\n     */\n    function syncAccount(address account) onlyProduct external {\n        IProduct product = IProduct(msg.sender);\n\n        for (uint256 i; i < _registry[product].length(); i++) {\n            uint256 programId = _registry[product].at(i);\n            _programs[programId].settle(_programInfos[programId], account);\n        }\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s rewards for `product` programs\n     * @param product Product to claim rewards for\n     */\n    function claim(IProduct product) notPaused nonReentrant isProduct(product) public {\n        // settle product markets\n        product.settle();\n        product.settleAccount(msg.sender);\n\n        // claim\n        for (uint256 i; i < _registry[product].length(); i++) {\n            claimInternal(msg.sender, _registry[product].at(i));\n        }\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s rewards for a specific program\n     * @param programId Program to claim rewards for\n     */\n    function claim(uint256 programId) notPaused nonReentrant validProgram(programId) public {\n        IProduct product = _programInfos[programId].product;\n\n        // settle product markets\n        product.settle();\n        product.settleAccount(msg.sender);\n\n        // claim\n        claimInternal(msg.sender, programId);\n    }\n\n    /**\n     * @notice Claims all of `account`'s rewards for a specific program\n     * @dev Internal helper, assumes account has already been product-settled prior to calling\n     * @param account Account to claim rewards for\n     * @param programId Program to claim rewards for\n     */\n    function claimInternal(address account, uint256 programId) private {\n        Program storage program = _programs[programId];\n        ProgramInfo memory programInfo = _programInfos[programId];\n\n        program.settle(programInfo, account);\n        UFixed18 claimedAmount = program.claim(account);\n\n        programInfo.token.push(account, claimedAmount);\n\n        emit Claim(account, programId, claimedAmount);\n    }\n\n    /**\n     * @notice Claims all `tokens` fees to the protocol treasury\n     * @param tokens Tokens to claim fees for\n     */\n    function claimFee(Token18[] calldata tokens) notPaused external {\n        for(uint256 i; i < tokens.length; i++) {\n            Token18 token = tokens[i];\n            UFixed18 amount = fees[token];\n\n            fees[token] = UFixed18Lib.ZERO;\n            tokens[i].push(factory().treasury(), amount);\n\n            emit FeeClaim(token, amount);\n        }\n    }\n\n    /**\n     * @notice Returns program info for program `programId`\n     * @param programId Program to return for\n     * @return Program info\n     */\n    function programInfos(uint256 programId) external view returns (ProgramInfo memory) {\n        return _programInfos[programId];\n    }\n\n    /**\n     * @notice Returns `account`'s total unclaimed rewards for a specific program\n     * @param account Account to return for\n     * @param programId Program to return for\n     * @return `account`'s total unclaimed rewards for `programId`\n     */\n    function unclaimed(address account, uint256 programId) external view returns (UFixed18) {\n        if (programId >= _programInfos.length) return (UFixed18Lib.ZERO);\n\n        ProgramInfo memory programInfo = _programInfos[programId];\n        return _programs[programId].unclaimed(programInfo, account);\n    }\n\n    /**\n     * @notice Returns `account`'s latest synced version for a specific program\n     * @param account Account to return for\n     * @param programId Program to return for\n     * @return `account`'s latest synced version for `programId`\n     */\n    function latestVersion(address account, uint256 programId) external view returns (uint256) {\n        return _programs[programId].latestVersion[account];\n    }\n\n    /**\n     * @notice Returns `account`'s settled rewards for a specific program\n     * @param account Account to return for\n     * @param programId Program to return for\n     * @return `account`'s settled rewards for `programId`\n     */\n    function settled(address account, uint256 programId) external view returns (UFixed18) {\n        return _programs[programId].settled[account];\n    }\n\n    /**\n     * @notice Returns available rewards for a specific program\n     * @param programId Program to return for\n     * @return Available rewards for `programId`\n     */\n    function available(uint256 programId) external view returns (UFixed18) {\n        return _programs[programId].available;\n    }\n\n    /**\n     * @notice Returns the version completed for a specific program\n     * @param programId Program to return for\n     * @return The version completed for `programId`\n     */\n    function versionComplete(uint256 programId) external view returns (uint256) {\n        return _programs[programId].versionComplete;\n    }\n\n    /**\n     * @notice Returns whether closed for a specific program\n     * @param programId Program to return for\n     * @return whether closed for `programId`\n     */\n    function closed(uint256 programId) external view returns (bool) {\n        return _programs[programId].closed;\n    }\n\n    /**\n     * @notice Returns quantity of programs for a specific product\n     * @param product Product to return for\n     * @return Quantity of programs for `product`\n     */\n    function programsForLength(IProduct product) external view returns (uint256) {\n        return _registry[product].length();\n    }\n\n    /**\n     * @notice Returns the program at index `index` for a specific product\n     * @param product Product to return for\n     * @param index Index to return for\n     * @return The program at index `index` for `product`\n     */\n    function programsForAt(IProduct product, uint256 index) external view returns (uint256) {\n        return _registry[product].at(index);\n    }\n\n    /**\n     * @notice Returns the owner of a specific program\n     * @param programId Program to return for\n     * @return The owner of `programId`\n     */\n    function owner(uint256 programId) public view returns (address) {\n        Program storage program = _programs[programId];\n        ProgramInfo storage programInfo = _programInfos[programId];\n        return program.protocolOwned ? factory().owner() : factory().owner(programInfo.product);\n    }\n\n    /**\n     * @notice Returns the treasury of a specific program\n     * @param programId Program to return for\n     * @return The treasury of `programId`\n     */\n    function treasury(uint256 programId) public view returns (address) {\n        Program storage program = _programs[programId];\n        ProgramInfo storage programInfo = _programInfos[programId];\n        return program.protocolOwned ? factory().treasury() : factory().treasury(programInfo.product);\n    }\n\n    /**\n     * @notice Updates the maximum programs per product\n     * @param newProgramsPerProduct New maximum programs per product value\n     */\n    function updateProgramsPerProduct(uint256 newProgramsPerProduct) onlyOwner external {\n        programsPerProduct = newProgramsPerProduct;\n\n        emit ProgramsPerProductUpdated(newProgramsPerProduct);\n    }\n\n    /**\n     * @notice Updates the fee\n     * @param newFee New fee value\n     */\n    function updateFee(UFixed18 newFee) onlyOwner external {\n        fee = newFee;\n\n        emit FeeUpdated(newFee);\n    }\n\n    /// @dev Only allow the owner of `programId` to call\n    modifier onlyProgramOwner(uint256 programId) {\n        if (msg.sender != owner(programId)) revert IncentivizerNotProgramOwnerError(msg.sender, programId);\n\n        _;\n    }\n\n    /// @dev Only allow a valid `programId`\n    modifier validProgram(uint256 programId) {\n        if (programId >= _programInfos.length) revert IncentivizerInvalidProgramError(programId);\n\n        _;\n    }\n}\ncontract Product is IProduct, UFactoryProvider, UReentrancyGuard {\n    using UFixed18Lib for UFixed18;\n    using Fixed18Lib for Fixed18;\n    using AccumulatorLib for Accumulator;\n    using PositionLib for Position;\n    using PrePositionLib for PrePosition;\n    using AccountAccumulatorLib for AccountAccumulator;\n    using VersionedAccumulatorLib for VersionedAccumulator;\n    using AccountPositionLib for AccountPosition;\n    using VersionedPositionLib for VersionedPosition;\n\n    /// @dev The parameter provider of the product market\n    IProductProvider public provider;\n\n    /// @dev The individual position state for each account\n    mapping(address => AccountPosition) private _positions;\n\n    /// @dev The global position state for the product\n    VersionedPosition private _position;\n\n    /// @dev The individual accumulator state for each account\n    mapping(address => AccountAccumulator) private _accumulators;\n\n    /// @dev The global accumulator state for the product\n    VersionedAccumulator private _accumulator;\n\n    /**\n     * @notice Initializes the contract state\n     * @param provider_ Product provider contract address\n     */\n    function initialize(IProductProvider provider_) external {\n        UFactoryProvider__initialize(IFactory(msg.sender));\n        UReentrancyGuard__initialize();\n\n        provider = provider_;\n    }\n\n    /**\n     * @notice Surfaces global settlement externally\n     */\n    function settle() nonReentrant notPaused external {\n        settleInternal();\n    }\n\n    /**\n     * @notice Core global settlement flywheel\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function settleInternal() internal {\n        provider.sync();\n        factory().incentivizer().sync();\n\n        uint256 oracleVersionPreSettle = _position.pre.oracleVersionToSettle(provider);\n        uint256 oracleVersionCurrent = provider.currentVersion();\n        UFixed18 accumulatedFee;\n\n        // value a->b\n        accumulatedFee = accumulatedFee.add(_accumulator.accumulate(_position, factory(), provider, oracleVersionPreSettle));\n\n        // position a->b\n        accumulatedFee = accumulatedFee.add(_position.settle(provider, oracleVersionPreSettle));\n\n        // short-circuit if a->c\n        if (oracleVersionPreSettle != oracleVersionCurrent) {\n\n            // value b->c\n            accumulatedFee = accumulatedFee.add(_accumulator.accumulate(_position, factory(), provider, oracleVersionCurrent));\n\n            // position b->c (stamp c, does not settle pre position)\n            _position.settle(provider, oracleVersionCurrent);\n        }\n\n        // settle collateral\n        factory().collateral().settleProduct(accumulatedFee);\n\n        emit Settle(oracleVersionPreSettle, oracleVersionCurrent);\n    }\n\n    /**\n     * @notice Surfaces account settlement externally\n     * @param account Account to settle\n     */\n    function settleAccount(address account) notPaused nonReentrant external {\n        settleAccountInternal(account);\n    }\n\n    /**\n     * @notice Core account settlement flywheel\n     * @param account Account to settle\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function settleAccountInternal(address account) internal {\n        (IIncentivizer incentivizer, ICollateral collateral) = (factory().incentivizer(), factory().collateral());\n        uint256 oracleVersionPreSettle = _positions[account].pre.oracleVersionToSettle(provider);\n        uint256 oracleVersionCurrent = provider.currentVersion();\n        Fixed18 accumulated;\n\n        // value a->b\n        accumulated = accumulated.add(_accumulators[account].syncTo(_accumulator, _positions[account], oracleVersionPreSettle).sum());\n\n        // sync incentivizer before position update\n        incentivizer.syncAccount(account);\n\n        // position a->b\n        accumulated = accumulated.sub(Fixed18Lib.from(_positions[account].settle(provider, oracleVersionPreSettle)));\n\n        // short-circuit if a->c\n        if (oracleVersionPreSettle != oracleVersionCurrent) {\n\n            // value b->c\n            accumulated = accumulated.add(_accumulators[account].syncTo(_accumulator, _positions[account], oracleVersionCurrent).sum());\n\n            // position b->c (stamp c, does not settle pre position)\n            _positions[account].settle(provider, oracleVersionCurrent);\n        }\n\n        // settle collateral\n        collateral.settleAccount(account, accumulated);\n\n        emit AccountSettle(account, oracleVersionPreSettle, oracleVersionCurrent);\n    }\n\n    /**\n     * @notice Opens a taker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openTake(UFixed18 amount)\n    notPaused\n    nonReentrant\n    settleForAccount(msg.sender)\n    takerInvariant\n    positionInvariant\n    liquidationInvariant\n    maintenanceInvariant\n    external {\n        _positions[msg.sender].pre.openTake(provider, amount);\n        _position.pre.openTake(provider, amount);\n\n        emit TakeOpened(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeTake(UFixed18 amount)\n    notPaused\n    nonReentrant\n    settleForAccount(msg.sender)\n    closeInvariant\n    liquidationInvariant\n    external {\n        closeTakeInternal(msg.sender, amount);\n    }\n\n    function closeTakeInternal(address account, UFixed18 amount) internal {\n        _positions[account].pre.closeTake(provider, amount);\n        _position.pre.closeTake(provider, amount);\n\n        emit TakeClosed(account, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openMake(UFixed18 amount)\n    notPaused\n    nonReentrant\n    settleForAccount(msg.sender)\n    makerInvariant\n    positionInvariant\n    liquidationInvariant\n    maintenanceInvariant\n    external {\n        _positions[msg.sender].pre.openMake(provider, amount);\n        _position.pre.openMake(provider, amount);\n\n        emit MakeOpened(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeMake(UFixed18 amount)\n    notPaused\n    nonReentrant\n    settleForAccount(msg.sender)\n    takerInvariant\n    closeInvariant\n    liquidationInvariant\n    external {\n        closeMakeInternal(msg.sender, amount);\n    }\n\n    function closeMakeInternal(address account, UFixed18 amount) internal {\n        _positions[account].pre.closeMake(provider, amount);\n        _position.pre.closeMake(provider, amount);\n\n        emit MakeClosed(account, amount);\n    }\n\n    /**\n     * @notice Closes all open and pending positions, locking for liquidation\n     * @dev Only callable by the Collateral contract as part of the liquidation flow\n     * @param account Account to close out\n     */\n    function closeAll(address account) onlyCollateral settleForAccount(account) external {\n        Position memory p = _positions[account].position.next(_positions[account].pre);\n\n        // Close all positions\n        closeMakeInternal(account, p.maker);\n        closeTakeInternal(account, p.taker);\n\n        // Mark liquidation to lock position\n        _positions[account].liquidation = true;\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account`\n     * @param account Account to return for\n     * @return The current maintenance requirement\n     */\n    function maintenance(address account) public view returns (UFixed18) {\n        return _positions[account].maintenance(provider);\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account` after next settlement\n     * @dev Assumes no price change and no funding, used to protect user from over-opening\n     * @param account Account to return for\n     * @return The next maintenance requirement\n     */\n    function maintenanceNext(address account) public view returns (UFixed18) {\n        return _positions[account].maintenanceNext(provider);\n    }\n\n    /**\n     * @notice Returns whether `account` has a completely zero'd position\n     * @param account Account to return for\n     * @return The the account is closed\n     */\n    function isClosed(address account) external view returns (bool) {\n        return _positions[account].isClosed();\n    }\n\n    /**\n     * @notice Returns whether `account` is currently locked for an in-progress liquidation\n     * @param account Account to return for\n     * @return Whether the account is in liquidation\n     */\n    function isLiquidating(address account) external view returns (bool) {\n        return _positions[account].liquidation;\n    }\n\n    /**\n     * @notice Returns `account`'s current position\n     * @param account Account to return for\n     * @return Current position of the account\n     */\n    function position(address account) external view returns (Position memory) {\n        return _positions[account].position;\n    }\n\n    /**\n     * @notice Returns `account`'s current pending-settlement position\n     * @param account Account to return for\n     * @return Current pre-position of the account\n     */\n    function pre(address account) external view returns (PrePosition memory) {\n        return _positions[account].pre;\n    }\n\n    /**\n     * @notice Returns the global latest settled oracle version\n     * @return Latest settled oracle version of the product\n     */\n    function latestVersion() external view returns (uint256) {\n        return _position.latestVersion;\n    }\n\n    /**\n     * @notice Returns the global position at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global position at oracle version\n     */\n    function positionAtVersion(uint256 oracleVersion) external view returns (Position memory) {\n        return _position.positionAtVersion[oracleVersion];\n    }\n\n    /**\n     * @notice Returns the current global pending-settlement position\n     * @return Global pending-settlement position\n     */\n    function pre() external view returns (PrePosition memory) {\n        return _position.pre;\n    }\n\n    /**\n     * @notice Returns the global accumulator value at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator value at oracle version\n     */\n    function valueAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.valueAtVersion[oracleVersion];\n    }\n\n    /**\n     * @notice Returns the global accumulator share at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator share at oracle version\n     */\n    function shareAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.shareAtVersion[oracleVersion];\n    }\n\n    /**\n     * @notice Returns `account`'s latest settled oracle version\n     * @param account Account to return for\n     * @return Latest settled oracle version of the account\n     */\n    function latestVersion(address account) external view returns (uint256) {\n        return _accumulators[account].latestVersion;\n    }\n\n    /// @dev Limit total maker for guarded rollouts\n    modifier makerInvariant {\n        _;\n\n        Position memory next = _position.position().next(_position.pre);\n\n        if (next.maker.gt(provider.makerLimit())) revert ProductMakerOverLimitError();\n    }\n\n    /// @dev Limit maker short exposure to the range 0.0-1.0x of their position\n    modifier takerInvariant {\n        _;\n\n        Position memory next = _position.position().next(_position.pre);\n        UFixed18 socializationFactor = next.socializationFactor();\n\n        if (socializationFactor.lt(UFixed18Lib.ONE)) revert ProductInsufficientLiquidityError(socializationFactor);\n    }\n\n    /// @dev Ensure that the user has only taken a maker or taker position, but not both\n    modifier positionInvariant {\n        _;\n\n        if (_positions[msg.sender].isDoubleSided()) revert ProductDoubleSidedError();\n    }\n\n    /// @dev Ensure that the user hasn't closed more than is open\n    modifier closeInvariant {\n        _;\n\n        if (_positions[msg.sender].isOverClosed()) revert ProductOverClosedError();\n    }\n\n    /// @dev Ensure that the user will have sufficient margin for maintenance after next settlement\n    modifier maintenanceInvariant {\n        _;\n\n        if (factory().collateral().liquidatableNext(msg.sender, IProduct(this)))\n            revert ProductInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the user is not currently being liquidated\n    modifier liquidationInvariant {\n        if (_positions[msg.sender].liquidation) revert ProductInLiquidationError();\n\n        _;\n    }\n\n    /// @dev Helper to fully settle an account's state\n    modifier settleForAccount(address account) {\n        settleInternal();\n        settleAccountInternal(account);\n\n        _;\n    }\n}\ncontract Collateral is ICollateral, UFactoryProvider, UReentrancyGuard {\n    using UFixed18Lib for UFixed18;\n    using Token18Lib for Token18;\n    using OptimisticLedgerLib for OptimisticLedger;\n\n    /// @dev ERC20 stablecoin for collateral\n    Token18 public token;\n\n    /// @dev Fee on maintenance for liquidation\n    UFixed18 public liquidationFee;\n\n    /// @dev Per product collateral state\n    mapping(IProduct => OptimisticLedger) private _products;\n\n    /// @dev Protocol and product fees collected, but not yet claimed\n    mapping(address => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the contract state\n     * @param factory_ Factory contract address\n     * @param token_ Collateral ERC20 stablecoin address\n     */\n    function initialize(IFactory factory_, Token18 token_) external {\n        UFactoryProvider__initialize(factory_);\n        UReentrancyGuard__initialize();\n\n        token = token_;\n        liquidationFee = UFixed18Lib.ratio(50, 100);\n    }\n\n    /**\n     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`\n     *         account\n     * @param account Account to deposit the collateral for\n     * @param product Product to credit the collateral to\n     * @param amount Amount of collateral to deposit\n     */\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    notPaused\n    collateralInvariant(account, product)\n    external {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account\n     *         and sends it to `account`\n     * @param account Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawTo(address account, IProduct product, UFixed18 amount)\n    notPaused\n    collateralInvariant(msg.sender, product)\n    maintenanceInvariant(msg.sender, product)\n    external {\n        _products[product].debitAccount(msg.sender, amount);\n        token.push(account, amount);\n\n        emit Withdrawal(msg.sender, product, amount);\n    }\n\n    /**\n     * @notice Liquidates `account`'s `product` collateral account\n     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`\n     * @param account Account to liquidate\n     * @param product Product to liquidate for\n     */\n    function liquidate(address account, IProduct product) notPaused nonReentrant external {\n        // settle\n        product.settle();\n        product.settleAccount(account);\n\n        // liquidate\n        UFixed18 totalMaintenance = product.maintenance(account);\n        UFixed18 totalCollateral = collateral(account, product);\n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 fee = UFixed18Lib.min(totalCollateral, totalMaintenance.mul(liquidationFee));\n\n        _products[product].debitAccount(account, fee);\n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n\n    /**\n     * @notice Credits `amount` to `account`'s collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel.\n     *      Moves collateral within a product, any collateral leaving the product due to\n     *      fees has already been accounted for in the settleProduct flywheel.\n     *      Debits in excess of the account balance get recorded as shortfall, and can be\n     *      resolved by the product owner as needed.\n     * @param account Account to credit\n     * @param amount Amount to credit the account (can be negative)\n     */\n    function settleAccount(address account, Fixed18 amount) onlyProduct external {\n        IProduct product = IProduct(msg.sender);\n\n        UFixed18 newShortfall = _products[product].settleAccount(account, amount);\n\n        emit AccountSettle(product, account, amount, newShortfall);\n    }\n\n    /**\n     * @notice Debits `amount` from product's total collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel\n     *      Removes collateral from the product as fees.\n     * @param amount Amount to debit from the account\n     */\n    function settleProduct(UFixed18 amount) onlyProduct external {\n        IProduct product = IProduct(msg.sender);\n\n        address protocolTreasury = factory().treasury();\n        address productTreasury = factory().treasury(product);\n\n        UFixed18 protocolFee = amount.mul(factory().fee());\n        UFixed18 productFee = amount.sub(protocolFee);\n\n        _products[product].debit(amount);\n        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);\n        fees[productTreasury] = fees[productTreasury].add(productFee);\n\n        emit ProductSettle(product, protocolFee, productFee);\n    }\n\n    /**\n     * @notice Returns the balance of `account`'s `product` collateral account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return The balance of the collateral account\n     */\n    function collateral(address account, IProduct product) public view returns (UFixed18) {\n        return _products[product].balances[account];\n    }\n\n    /**\n     * @notice Returns the total balance of `product`'s collateral\n     * @param product Product to return for\n     * @return The total balance of collateral in the product\n     */\n    function collateral(IProduct product) public view returns (UFixed18) {\n        return _products[product].total;\n    }\n\n    /**\n     * @notice Returns the current shortfall of `product`'s collateral\n     * @param product Product to return for\n     * @return The current shortfall of the product\n     */\n    function shortfall(IProduct product) public view returns (UFixed18) {\n        return _products[product].shortfall;\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatable(address account, IProduct product) external view returns (bool) {\n        return product.maintenance(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     *         after the next oracle version settlement\n     * @dev Takes into account the current pre-position on the account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatableNext(address account, IProduct product) external view returns (bool) {\n        return product.maintenanceNext(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Injects additional collateral into a product to resolve shortfall\n     * @dev Shortfall is a measure of settled insolvency in the market\n     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market\n     * @param product Product to resolve shortfall for\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolveShortfall(IProduct product, UFixed18 amount) notPaused external {\n        _products[product].resolve(amount);\n        token.pull(msg.sender, amount);\n\n        emit ShortfallResolution(product, amount);\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s fees\n     */\n    function claimFee() notPaused external {\n        UFixed18 amount = fees[msg.sender];\n\n        fees[msg.sender] = UFixed18Lib.ZERO;\n        token.push(msg.sender, amount);\n\n        emit FeeClaim(msg.sender, amount);\n    }\n\n    /**\n     * @notice Updates the liquidation fee\n     * @param newLiquidationFee New liquidation fee\n     */\n    function updateLiquidationFee(UFixed18 newLiquidationFee) onlyOwner external {\n        liquidationFee = newLiquidationFee;\n        emit LiquidationFeeUpdated(newLiquidationFee);\n    }\n\n    /// @dev Ensure that the user has sufficient margin for both current and next maintenance\n    modifier maintenanceInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 maintenance = product.maintenance(account);\n        UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n            revert CollateralInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the account is either empty or above the collateral minimum\n    modifier collateralInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 accountCollateral = collateral(account, product);\n        if (!accountCollateral.isZero() && accountCollateral.lt(factory().minCollateral()))\n            revert CollateralUnderLimitError();\n    }\n}\n",
    "bin": []
}