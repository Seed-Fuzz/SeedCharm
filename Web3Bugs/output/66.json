{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/66/packages/contracts",
    "external_functions": [
        [
            "IMasterChefJoeV2"
        ],
        [
            "IRewarder"
        ],
        [
            "WJLP",
            "IMasterChefJoeV2",
            "IERC20"
        ],
        [
            "IYETIToken"
        ],
        [
            "sYETIToken",
            "IYETIToken",
            "IERC20",
            "IsYETIRouter"
        ]
    ],
    "new_contract": "contract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() public {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}contract WJLP is ERC20_8, IWAsset {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable JLP;\n    IERC20 public immutable JOE;\n\n    IMasterChefJoeV2 public immutable _MasterChefJoe;\n    uint public _poolPid;\n\n    address internal activePool;\n    address internal TML;\n    address internal TMR;\n    address internal defaultPool;\n    address internal stabilityPool;\n    address internal YetiFinanceTreasury;\n    address internal borrowerOperations;\n    address internal collSurplusPool;\n\n    bool addressesSet;\n\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        uint256 unclaimedJOEReward;\n        uint256 amountInYeti;\n        //\n        // This explanation is from the Master Chef V2 contracts, which we use here to essentially \n        // keep track of rewards which are owned by this contract but actually belong to users \n        // which have wrapped LP tokens. \n        // We do some fancy math here. Basically, any point in time, the amount of JOEs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accJoePerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accJoePerShare` (and `lastRewardTimestamp`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n\n    // Info of each user that stakes LP tokens.\n    mapping(address => UserInfo) userInfo;\n\n    /* ========== INITIALIZER ========== */\n\n    constructor(string memory ERC20_symbol,\n        string memory ERC20_name,\n        uint8 ERC20_decimals,\n        IERC20 _JLP,\n        IERC20 _JOE,\n        IMasterChefJoeV2 MasterChefJoe,\n        uint256 poolPid) {\n\n        checkContract(address(_JLP));\n        checkContract(address(_JOE));\n        checkContract(address(MasterChefJoe));\n\n        _symbol = ERC20_symbol;\n        _name = ERC20_name;\n        _decimals = ERC20_decimals;\n\n        JLP = _JLP;\n        JOE = _JOE;\n\n        _MasterChefJoe = MasterChefJoe;\n        _poolPid = poolPid;\n    }\n\n    function setAddresses(\n        address _activePool,\n        address _TML,\n        address _TMR,\n        address _defaultPool,\n        address _stabilityPool,\n        address _YetiFinanceTreasury, \n        address _borrowerOperations, \n        address _collSurplusPool) external {\n        require(!addressesSet, \"setAddresses: Addresses already set\");\n        checkContract(_activePool);\n        checkContract(_TML);\n        checkContract(_TMR);\n        checkContract(_defaultPool);\n        checkContract(_stabilityPool);\n        checkContract(_YetiFinanceTreasury);\n        checkContract(_borrowerOperations);\n        checkContract(_collSurplusPool);\n        activePool = _activePool;\n        TML = _TML;\n        TMR = _TMR;\n        defaultPool = _defaultPool;\n        stabilityPool = _stabilityPool;\n        YetiFinanceTreasury = _YetiFinanceTreasury;\n        borrowerOperations = _borrowerOperations;\n        collSurplusPool = _collSurplusPool;\n        addressesSet = true;\n    }\n\n    /* ========== New Functions =============== */\n\n    // Can be called by anyone.\n    // This function pulls in _amount of base JLP tokens from _from, and stakes \n    // them in the reward contract, while updating the reward balance for that user. \n    // Sends reward balance to _rewardRecipient, and the ability to withdraw from the \n    // contract and get your JLP back is tracked by wJLP balance, and given to _to. \n    // If the caller is not borrower operations, then _from and msg.sender must be \n    // the same to make it so you must be the one wrapping your tokens. \n    // Intended for use by Yeti Finance so that users can collateralize their LP tokens \n    // while gaining yield. So the protocol owns wJLP while the user owns the reward balance \n    // and can claim their JOE rewards any time. \n    function wrap(uint _amount, address _from, address _to, address _rewardRecipient) external override {\n        if (msg.sender != borrowerOperations) {\n            // Unless the caller is borrower operations, msg.sender and _from cannot \n            // be different. \n            require(msg.sender == _from, \"WJLP: msg.sender and _from must be the same\");\n        }\n\n        JLP.transferFrom(_from, address(this), _amount);\n\n        JLP.safeApprove(address(_MasterChefJoe), 0);\n        JLP.safeIncreaseAllowance(address(_MasterChefJoe), _amount);\n\n        // stake LP tokens in Trader Joe's.\n        // In process of depositing, all this contract's\n        // accumulated JOE rewards are sent into this contract\n        _MasterChefJoe.deposit(_poolPid, _amount);\n\n        // update user reward tracking\n        _userUpdate(_rewardRecipient, _amount, true);\n        _mint(_to, _amount);\n        if (_to == activePool) {\n            userInfo[_rewardRecipient].amountInYeti += _amount;\n        }\n    }\n\n    // External function intended for users to unwrap manually their LP tokens. \n    function unwrap(uint _amount) external override {\n        // Claim pending reward for unwrapper\n        _sendJoeReward(msg.sender, msg.sender);\n\n        // Decrease rewards by the same amount user is unwrapping. Ensures they have enough reward balance. \n        _userUpdate(msg.sender, _amount, false);\n\n        // Withdraw LP tokens from Master chef contract\n        _MasterChefJoe.withdraw(_poolPid, _amount);\n        \n        // Rid of WJLP tokens from wallet \n        _burn(msg.sender, _amount);\n\n        // Transfer withdrawn JLP tokens to withdrawer. \n        JLP.safeTransfer(msg.sender, _amount);\n    }\n\n    // Override function which allows us to check the amount of LP tokens a user actually has rewards for, and update \n    // that amount so that a user can't keep depositing into the protocol using the same reward amount\n    function transferFrom(address _from, address _to, uint _amount) public override returns (bool success) {\n        if (msg.sender == borrowerOperations || msg.sender == activePool || msg.sender == defaultPool) {\n            UserInfo memory user = userInfo[_from];\n            require(user.amount - user.amountInYeti >= _amount, \"Reward balance not sufficient to transfer into Yeti Finance\");\n            user.amountInYeti += _amount;\n        }\n        return super.transferFrom(_from, _to, _amount);\n    }\n\n    // Override function which allows us to check the amount of LP tokens a user actually has rewards for, and update \n    // that amount so that a user can't keep depositing into the protocol using the same reward amount\n    function transfer(address _to, uint _amount) public override returns (bool success) {\n        if (msg.sender == borrowerOperations || msg.sender == activePool || msg.sender == defaultPool) {\n            if (_to != stabilityPool && _to != defaultPool && _to != collSurplusPool){\n                UserInfo memory user = userInfo[msg.sender];\n                require(user.amount - user.amountInYeti >= _amount, \"Reward balance not sufficient to transfer into Yeti Finance\");\n                user.amountInYeti += _amount;\n            }\n        }\n        return super.transfer(_to, _amount);\n    }\n\n    // Only callable by ActivePool or StabilityPool\n    // Used to unwrap assets during:\n    // 1. Sending 0.5% liquidation reward to liquidators\n    // 2. Sending back redeemed assets\n    // In both cases, the wrapped asset is first sent to the liquidator or redeemer respectively,\n    // then this function is called with _for equal to the the liquidator or redeemer address\n    // Prior to this being called, the user whose assets we are burning should have their rewards updated\n    // This function also claims rewards when unwrapping so they are automatically sent to the original owner,\n    // and also reduces the reward balance before unwrapping is complete. \n    // _from has the current rewards. \n    function unwrapFor(address _from, address _to, uint _amount) external override {\n        _requireCallerIsPool();\n\n        // Claim pending reward for original owner\n        _sendJoeReward(_from, _from);\n\n        // Decrease rewards by the same amount user is unwrapping. Ensures they have enough reward balance. \n        _userUpdate(_from, _amount, false);\n        userInfo[_from].amountInYeti -= _amount;\n\n        // Withdraw LP tokens from Master chef contract\n        _MasterChefJoe.withdraw(_poolPid, _amount);\n\n        // msg.sender is either Active Pool or Stability Pool\n        // each one has the ability to unwrap and burn WAssets they own and\n        // send them to someone else\n        _burn(msg.sender, _amount);\n\n        // Transfer withdrawn JLP tokens to new owner. \n        JLP.safeTransfer(_to, _amount);\n    }\n\n    // When funds are transferred into the stabilityPool on liquidation,\n    // the rewards these funds are earning are allocated Yeti Finance Treasury.\n    // But when an stabilityPool depositor wants to withdraw their collateral,\n    // the wAsset is unwrapped and the rewards are no longer accruing to the Yeti Finance Treasury\n    function endTreasuryReward(address _to, uint _amount) external override {\n        _requireCallerIsSPorDP();\n\n        // Then update new owner of rewards.\n        _updateReward(YetiFinanceTreasury, _to, _amount);\n    }\n\n    // Decreases _from's amount of LP tokens earning yield by _amount\n    // And increases _to's amount of LP tokens earning yield by _amount\n    // If _to is address(0), then doesn't increase anyone's amount\n    function updateReward(address _from, address _to, uint _amount) external override {\n        _requireCallerIsLRDorBO();\n        _updateReward(_from, _to, _amount);\n    }\n\n    function _updateReward(address _from, address _to, uint _amount) internal {\n        // Claim any outstanding reward first \n        _sendJoeReward(_from, _from);\n        _userUpdate(_from, _amount, false);\n        userInfo[_from].amountInYeti -= _amount;\n        _userUpdate(_to, _amount, true);\n        userInfo[_to].amountInYeti += _amount;\n    }\n\n    // checks total pending JOE rewards for _for\n    function getPendingRewards(address _for) external view override returns\n        (address[] memory, uint[] memory)  {\n        // latest accumulated Joe Per Share:\n        uint256 accJoePerShare = _MasterChefJoe.poolInfo(_poolPid).accJoePerShare;\n        UserInfo storage user = userInfo[_for];\n\n        uint unclaimed = user.unclaimedJOEReward;\n        uint pending = (user.amount * accJoePerShare / 1e12) - user.rewardDebt;\n\n        address[] memory tokens = new address[](1);\n        uint[] memory amounts = new uint[](1);\n        tokens[0] = address(JLP);\n        amounts[0] = unclaimed + pending;\n\n        return (tokens, amounts);\n    }\n\n    // checks total pending JOE rewards for _for\n    function getUserInfo(address _user) external view override returns (uint, uint, uint)  {\n        UserInfo memory user = userInfo[_user];\n        return (user.amount, user.rewardDebt, user.unclaimedJOEReward);\n    }\n\n\n    // Claims msg.sender's pending rewards and sends to _to address\n    function claimReward(address _to) external override {\n        _sendJoeReward(msg.sender, _to);\n    }\n\n\n    function _sendJoeReward(address _rewardOwner, address _to) internal {\n        // harvests all JOE that the WJLP contract is owed\n        _MasterChefJoe.withdraw(_poolPid, 0);\n\n        // updates user.unclaimedJOEReward with latest data from TJ\n        _userUpdate(_rewardOwner, 0, true);\n\n        uint joeToSend = userInfo[_rewardOwner].unclaimedJOEReward;\n        userInfo[_rewardOwner].unclaimedJOEReward = 0;\n        _safeJoeTransfer(_to, joeToSend);\n    }\n\n    /*\n     * Updates _user's reward tracking to give them unclaimedJOEReward.\n     * They have the right to less or more future rewards depending\n     * on whether it is or isn't a deposit\n    */\n    function _userUpdate(address _user, uint256 _amount, bool _isDeposit) private {\n        // latest accumulated Joe Per Share:\n        uint256 accJoePerShare = _MasterChefJoe.poolInfo(_poolPid).accJoePerShare;\n        UserInfo storage user = userInfo[_user];\n        uint256 cachedUserAmount = user.amount;\n\n        if (cachedUserAmount != 0) {\n            user.unclaimedJOEReward = (cachedUserAmount * accJoePerShare / 1e12) - user.rewardDebt;\n        }\n\n        if (_isDeposit) {\n            user.amount = cachedUserAmount + _amount;\n        } else {\n            user.amount = cachedUserAmount - _amount;\n        }\n\n        // update for JOE rewards that are already accounted for in user.unclaimedJOEReward\n        user.rewardDebt = user.amount * accJoePerShare / 1e12;\n    }\n\n    /*\n    * Safe joe transfer function, just in case if rounding error causes pool to not have enough JOEs.\n    */\n    function _safeJoeTransfer(address _to, uint256 _amount) internal {\n        IERC20 cachedJOE = JOE;\n        uint256 joeBal = cachedJOE.balanceOf(address(this));\n        if (_amount > joeBal) {\n            cachedJOE.safeTransfer(_to, joeBal);\n        } else {\n            cachedJOE.safeTransfer(_to, _amount);\n        }\n    }\n\n    // ===== Check Caller Require View Functions =====\n\n    function _requireCallerIsPool() internal view {\n        require((msg.sender == activePool || msg.sender == stabilityPool || msg.sender == collSurplusPool),\n            \"Caller is not active pool or stability pool\"\n        );\n    }\n\n    function _requireCallerIsSPorDP() internal view {\n        require((msg.sender == stabilityPool || msg.sender == defaultPool),\n            \"Caller is not stability pool or default pool\"\n        );\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        require(msg.sender == activePool,\n            \"Caller is not active pool\"\n        );\n    }\n\n    // liquidation redemption default pool\n    function _requireCallerIsLRDorBO() internal view {\n        require(\n            (msg.sender == TML ||\n             msg.sender == TMR ||\n             msg.sender == defaultPool || \n             msg.sender == borrowerOperations),\n            \"Caller is not LRD\"\n        );\n    }\n\n    function _requireCallerIsSP() internal view {\n        require(msg.sender == stabilityPool, \"Caller is not stability pool\");\n    }\n\n    function checkContract(address _account) internal view {\n        require(_account != address(0), \"Account cannot be zero address\");\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(_account) }\n        require(size != 0, \"Account code size cannot be zero\");\n    }\n\n}contract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\ncontract Domain {\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\n\n    // solhint-disable var-name-mixedcase\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\n\n    /// @dev Calculate the DOMAIN_SEPARATOR\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_SEPARATOR_SIGNATURE_HASH,\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    constructor() public {\n        uint256 chainId; assembly {chainId := chainid()}\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\n    // solhint-disable-next-line func-name-mixedcase\n    function _domainSeparator() internal view returns (bytes32) {\n        uint256 chainId; assembly {chainId := chainid()}\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n        digest =\n        keccak256(\n            abi.encodePacked(\n                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                _domainSeparator(),\n                dataHash\n            )\n        );\n    }\n}contract ERC20_8 is IERC20 {\n\n    string public _symbol;\n    string public _name;\n    uint8 public _decimals;\n    uint public _totalSupply;\n\n    // For each person map between their address and the number of tokens they have\n    mapping(address => uint) balances;\n    // To transfer erc20 token, give contract permission to transfer. Maps from your address to address of transfer target and amount to transfer.\n    mapping(address => mapping(address => uint)) allowed;\n\n    /* ========== View Functions ========== */\n\n    //Returns decimals that this token uses.\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n\n    //Returns the token name\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n\n    //Returns the symbol\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n\n    // Return total supply\n    function totalSupply() public override view returns (uint) {\n        return _totalSupply;\n    }\n\n\n    // Return the token balance for account tokenOwner\n    function balanceOf(address _token_owner) public override view returns (uint balance) {\n        return balances[_token_owner];\n    }\n\n    // ------------------------------------------------------------------------\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender's account\n    // ------------------------------------------------------------------------\n    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n\n    /* ========== External Functions ========== */\n\n\n    // ------------------------------------------------------------------------\n    // Transfer the balance from token owner's account to to account\n    // - Owner's account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transfer(address _to, uint _num_tokens) public virtual override returns (bool success) {\n        require(_num_tokens <= balances[msg.sender], \"You are trying to transfer more tokens than you have\");\n\n        unchecked { balances[msg.sender] = balances[msg.sender] - _num_tokens; } // pre checked that you have enough tokens\n        balances[_to] = balances[_to] + _num_tokens;\n        emit Transfer(msg.sender, _to, _num_tokens);\n        return true;\n    }\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for spender to transferFrom(...) tokens\n    // from the token owner's account\n    //\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n    // recommends that there are no checks for the approval double-spend attack\n    // as this should be implemented in user interfaces\n    // ------------------------------------------------------------------------\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\n        _approve(msg.sender, spender, allowed[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        _approve(msg.sender, spender, allowed[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        allowed[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer tokens from the from account to the to account\n    //\n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the from account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transferFrom(address _from, address _to, uint _amount) public virtual override returns (bool success) {\n        return _transferFrom(_from, _to, _amount);\n    }\n\n\n    function _transferFrom(address _from, address _to, uint _amount) internal returns (bool) {\n        balances[_from] = balances[_from] - _amount;\n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _amount;\n        balances[_to] = balances[_to] + _amount;\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Mint new tokens to a given _to address\n    // ------------------------------------------------------------------------\n    function _mint(address _to, uint _num_tokens) internal returns (bool success) {\n        balances[_to] = balances[_to] + _num_tokens;\n        _totalSupply= _totalSupply+_num_tokens;\n        emit Transfer(address(0), _to, _num_tokens);\n        return true;\n    }\n\n    // ------------------------------------------------------------------------\n    // Burn tokens owned by _holder\n    // ------------------------------------------------------------------------\n    function _burn(address _holder, uint _num_tokens) internal returns (bool success) {\n        balances[_holder] = balances[_holder] - _num_tokens;\n        _totalSupply= _totalSupply- _num_tokens;\n        emit Transfer(_holder, address(0), _num_tokens);\n        return true;\n    }\n}\ncontract sYETIToken is IERC20, Domain, BoringOwnable {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringERC20 for IERC20;\n\n    string public constant symbol = \"sYETI\";\n    string public constant name = \"Staked YETI Tokens\";\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 private constant LOCK_TIME = 69 hours;\n    uint256 public effectiveYetiTokenBalance;\n    uint256 public lastBuybackTime;\n    uint256 public lastBuybackPrice;\n    uint256 public lastRebaseTime;\n    uint256 public transferRatio; // 100% = 1e18. Amount to transfer over each rebase. \n    IYETIToken public yetiToken;\n    IERC20 public yusdToken;\n    bool private addressesSet;\n\n\n    // Internal mapping to keep track of valid routers. Find the one with least slippage off chain\n    // and do that one. \n    mapping(address => bool) public validRouters;\n\n    struct User {\n        uint128 balance;\n        uint128 lockedUntil;\n    }\n\n    /// @notice owner > balance mapping.\n    mapping(address => User) public users;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);\n    event Rebase(uint additionalYetiTokenBalance);\n\n    function balanceOf(address user) public view override returns (uint256) {\n        return users[user].balance;\n    }\n\n    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {\n        require(!addressesSet, \"addresses already set\");\n        yetiToken = _yeti;\n        yusdToken = _yusd;\n        addressesSet = true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        User memory fromUser = users[from];\n        require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\n        if (shares != 0) {\n            require(fromUser.balance >= shares, \"Low balance\");\n            if (from != to) {\n                require(to != address(0), \"Zero address\"); // Moved down so other failed calls safe some gas\n                User memory toUser = users[to];\n                uint128 shares128 = shares.to128();\n                users[from].balance = fromUser.balance - shares128; // Underflow is checked\n                users[to].balance = toUser.balance + shares128; // Can't overflow because totalSupply would be greater than 2^128-1;\n            }\n        }\n        emit Transfer(from, to, shares);\n    }\n\n    function _useAllowance(address from, uint256 shares) internal {\n        if (msg.sender == from) {\n            return;\n        }\n        uint256 spenderAllowance = allowance[from][msg.sender];\n        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n        if (spenderAllowance != type(uint256).max) {\n            require(spenderAllowance >= shares, \"Low allowance\");\n            uint256 newAllowance = spenderAllowance - shares;\n            allowance[from][msg.sender] = newAllowance; // Underflow is checked\n            emit Approval(from, msg.sender, newAllowance);\n        }\n    }\n\n    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param shares of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 shares) public returns (bool) {\n        _transfer(msg.sender, to, shares);\n        return true;\n    }\n\n    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param shares The token shares to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _transfer(from, to, shares);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] += amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    \n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"Zero owner\");\n        require(block.timestamp < deadline, \"Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n            owner_,\n            \"Invalid Sig\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n\n    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18\n    /// theoretically you can grow the amount/share ratio, but it's not practical and useless\n    function mint(uint256 amount) public returns (bool) {\n        User memory user = users[msg.sender];\n\n        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;\n        user.balance += shares.to128();\n        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();\n        users[msg.sender] = user;\n        totalSupply += shares;\n\n        yetiToken.sendToSYETI(msg.sender, amount);\n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);\n\n        emit Transfer(address(0), msg.sender, shares);\n        return true;\n    }\n\n    function _burn(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        require(to != address(0), \"Zero address\");\n        User memory user = users[from];\n        require(block.timestamp >= user.lockedUntil, \"Locked\");\n        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;\n        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\n        totalSupply -= shares;\n\n        yetiToken.transfer(to, amount);\n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);\n\n        emit Transfer(from, address(0), shares);\n    }\n\n    function burn(address to, uint256 shares) public returns (bool) {\n        _burn(msg.sender, to, shares);\n        return true;\n    }\n\n    function burnFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _burn(from, to, shares);\n        return true;\n    }\n\n    /** \n     * Buyback function called by owner of function. Keeps track of the \n     */\n    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {\n        require(_YUSDToSell != 0, \"Zero amount\");\n        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, \"Not enough YUSD in contract\");\n        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);\n    }\n\n    /** \n     * Public function for doing buybacks, eligible every 169 hours. This is so that there are some guaranteed rewards to be distributed if the team multisig is lost.\n     * Has a max amount of YUSD to sell at 5% of the YUSD in the contract, which should be enough to cover the amount. Uses the default router which has a time lock \n     * in order to activate. \n     * No YUSDToSell param since this just does 5% of the YUSD in the contract.\n     */\n    function publicBuyBack(address _routerAddress) external {\n        uint256 YUSDBalance = yusdToken.balanceOf(address(this));\n        require(YUSDBalance != 0, \"No YUSD in contract\");\n        require(lastBuybackTime + 169 hours < block.timestamp, \"Can only publicly buy back every 169 hours\");\n        // Get 5% of the YUSD in the contract\n        // Always enough YUSD in the contract to cover the 5% of the YUSD in the contract\n        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);\n        _buyBack(_routerAddress, YUSDToSell, 0);\n    }\n\n    // Internal function calls the router function for buyback and emits event with amount of YETI bought and YUSD spent. \n    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {\n        // Checks internal mapping to see if router is valid\n        require(validRouters[_routerAddress] == true, \"Invalid router passed in\");\n        require(yusdToken.approve(_routerAddress, 0));\n        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));\n        lastBuybackTime = block.timestamp;\n        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));\n        // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]\n        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);\n        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);\n    }\n\n    // Rebase function for adding new value to the sYETI - YETI ratio. \n    function rebase() external {\n        require(block.timestamp >= lastRebaseTime + 8 hours, \"Can only rebase every 8 hours\");\n        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns \n        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance\n\n        // raw balance of the contract\n        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  \n        // amount of YETI free / available to give out\n        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); \n        // in YETI, amount that should be eligible to give out.\n        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); \n        // in YETI, amount to rebase\n        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); \n        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. \n        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase\n        if (amountYetiToRebase > adjustedYetiTokenBalance) {\n            amountYetiToRebase = adjustedYetiTokenBalance;\n        }\n        // rebase amount joins the effective supply. \n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);\n        // update rebase time\n        lastRebaseTime = block.timestamp;\n        emit Rebase(amountYetiToRebase);\n    }\n\n    // Sums YUSD balance + old price. \n    // Should take add the YUSD balance / last buyback price to get value of the YUSD in YETI \n    // added to the YETI balance of the contract. Essentially the amount it is eligible to give out.\n    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {\n        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));\n        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);\n    }\n\n    // Sets new transfer ratio for rebasing\n    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {\n        require(newTransferRatio != 0, \"Zero transfer ratio\");\n        require(newTransferRatio <= 1e18, \"Transfer ratio too high\");\n        transferRatio = newTransferRatio;\n    }\n    \n    // TODO - add time delay for setting new valid router. \n    function addValidRouter(address _routerAddress) external onlyOwner {\n        require(_routerAddress != address(0), \"Invalid router address\");\n        validRouters[_routerAddress] = true;\n    }\n\n    // TODO - add time delay for invalidating router. \n    function removeValidRouter(address _routerAddress) external onlyOwner {\n        validRouters[_routerAddress] = false;\n    }\n\n    // Safe divide\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b != 0, \"BoringMath: Div By 0\");\n        return a / b;\n    }\n}\n",
    "bin": []
}