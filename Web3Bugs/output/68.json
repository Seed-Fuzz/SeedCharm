{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/68/contracts/basket",
    "external_functions": [
        [
            "RebalanceManager",
            "IERC20",
            "IExperiPie"
        ],
        [
            "RebalanceManagerV2",
            "IERC20",
            "IExperiPie"
        ],
        [
            "RebalanceManagerV3",
            "IERC20",
            "IExperiPie"
        ],
        [
            "BasketFacet",
            "IERC20"
        ],
        [
            "CallFacet"
        ],
        [
            "ERC20Facet"
        ],
        [
            "PieFactoryContract",
            "IExperiPie",
            "PProxy",
            "Diamond"
        ],
        [
            "EthSingleTokenJoin",
            "IERC20",
            "IPangolinRouter",
            "IBasketFacet",
            "IWrappedNativeToken"
        ],
        [
            "EthSingleTokenJoinV2",
            "IERC20",
            "IPangolinRouter",
            "IBasketFacet",
            "IWrappedNativeToken"
        ],
        [
            "SingleNativeTokenExit",
            "IERC20",
            "IPangolinRouter",
            "IBasketFacet",
            "IWrappedNativeToken"
        ],
        [
            "SingleNativeTokenExitV2",
            "IERC20",
            "IBasketFacet",
            "IPangolinRouter",
            "IWrappedNativeToken"
        ],
        [
            "SingleTokenJoin",
            "IERC20",
            "IPangolinRouter",
            "IBasketFacet"
        ],
        [
            "SingleTokenJoinV2",
            "IERC20",
            "IPangolinRouter",
            "IBasketFacet"
        ]
    ],
    "new_contract": "contract ReentryProtection {\n    modifier noReentry {\n        // Use counter to only write to storage once\n        LibReentryProtectionStorage.RPStorage storage s =\n            LibReentryProtectionStorage.rpStorage();\n        s.lockCounter++;\n        uint256 lockValue = s.lockCounter;\n        _;\n        require(\n            lockValue == s.lockCounter,\n            \"ReentryProtectionFacet.noReentry: reentry detected\"\n        );\n    }\n}\ncontract CallFacet is ReentryProtection, ICallFacet {\n    uint256 public constant MAX_CALLERS = 50;\n\n    // uses modified call protection modifier to also allow whitelisted addresses to call\n    modifier protectedCall() {\n        require(\n            msg.sender == LibDiamond.diamondStorage().contractOwner ||\n                LibCallStorage.callStorage().canCall[msg.sender] ||\n                msg.sender == address(this),\n            \"NOT_ALLOWED\"\n        );\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == LibDiamond.diamondStorage().contractOwner,\n            \"NOT_ALLOWED\"\n        );\n        _;\n    }\n\n    function addCaller(address _caller) external override onlyOwner {\n        LibCallStorage.CallStorage storage callStorage =\n            LibCallStorage.callStorage();\n\n        require(callStorage.callers.length < MAX_CALLERS, \"TOO_MANY_CALLERS\");\n        require(!callStorage.canCall[_caller], \"IS_ALREADY_CALLER\");\n        require(_caller != address(0), \"INVALID_CALLER\");\n\n        callStorage.callers.push(_caller);\n        callStorage.canCall[_caller] = true;\n\n        emit CallerAdded(_caller);\n    }\n\n    function removeCaller(address _caller) external override onlyOwner {\n        LibCallStorage.CallStorage storage callStorage =\n            LibCallStorage.callStorage();\n\n        require(callStorage.canCall[_caller], \"IS_NOT_CALLER\");\n\n        callStorage.canCall[_caller] = false;\n\n        for (uint256 i = 0; i < callStorage.callers.length; i++) {\n            address currentCaller = callStorage.callers[i];\n\n            // if found remove it\n            if (currentCaller == _caller) {\n                callStorage.callers[i] = callStorage.callers[\n                    callStorage.callers.length - 1\n                ];\n                callStorage.callers.pop();\n                break;\n            }\n        }\n\n        emit CallerRemoved(_caller);\n    }\n\n    function call(\n        address[] memory _targets,\n        bytes[] memory _calldata,\n        uint256[] memory _values\n    ) public override noReentry protectedCall {\n        require(\n            _targets.length == _calldata.length &&\n                _values.length == _calldata.length,\n            \"ARRAY_LENGTH_MISMATCH\"\n        );\n\n        for (uint256 i = 0; i < _targets.length; i++) {\n            _call(_targets[i], _calldata[i], _values[i]);\n        }\n    }\n\n    function callNoValue(address[] memory _targets, bytes[] memory _calldata)\n        public\n        override\n        noReentry\n        protectedCall\n    {\n        require(_targets.length == _calldata.length, \"ARRAY_LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < _targets.length; i++) {\n            _call(_targets[i], _calldata[i], 0);\n        }\n    }\n\n    function singleCall(\n        address _target,\n        bytes calldata _calldata,\n        uint256 _value\n    ) external override noReentry protectedCall {\n        _call(_target, _calldata, _value);\n    }\n\n    function _call(\n        address _target,\n        bytes memory _calldata,\n        uint256 _value\n    ) internal {\n        require(address(this).balance >= _value, \"ETH_BALANCE_TOO_LOW\");\n        (bool success, ) = _target.call{value: _value}(_calldata);\n        require(success, \"CALL_FAILED\");\n        emit Call(msg.sender, _target, _calldata, _value);\n    }\n\n    function canCall(address _caller) external view override returns (bool) {\n        return LibCallStorage.callStorage().canCall[_caller];\n    }\n\n    function getCallers() external view override returns (address[] memory) {\n        return LibCallStorage.callStorage().callers;\n    }\n}\ncontract ERC20Facet is IERC20, IERC20Facet, CallProtection {\n    using SafeMath for uint256;\n\n    function initialize(\n        uint256 _initialSupply,\n        string memory _name,\n        string memory _symbol\n    ) external override {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        LibERC20Storage.ERC20Storage storage es =\n            LibERC20Storage.erc20Storage();\n\n        require(\n            bytes(es.name).length == 0 && bytes(es.symbol).length == 0,\n            \"ALREADY_INITIALIZED\"\n        );\n\n        require(\n            bytes(_name).length != 0 && bytes(_symbol).length != 0,\n            \"INVALID_PARAMS\"\n        );\n\n        require(msg.sender == ds.contractOwner, \"Must own the contract.\");\n\n        LibERC20.mint(msg.sender, _initialSupply);\n\n        es.name = _name;\n        es.symbol = _symbol;\n    }\n\n    function name() external view override returns (string memory) {\n        return LibERC20Storage.erc20Storage().name;\n    }\n\n    function setName(string calldata _name) external override protectedCall {\n        LibERC20Storage.erc20Storage().name = _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return LibERC20Storage.erc20Storage().symbol;\n    }\n\n    function setSymbol(string calldata _symbol)\n        external\n        override\n        protectedCall\n    {\n        LibERC20Storage.erc20Storage().symbol = _symbol;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n\n    function mint(address _receiver, uint256 _amount)\n        external\n        override\n        protectedCall\n    {\n        LibERC20.mint(_receiver, _amount);\n    }\n\n    function burn(address _from, uint256 _amount)\n        external\n        override\n        protectedCall\n    {\n        LibERC20.burn(_from, _amount);\n    }\n\n    function approve(address _spender, uint256 _amount)\n        external\n        override\n        returns (bool)\n    {\n        require(_spender != address(0), \"SPENDER_INVALID\");\n        LibERC20Storage.erc20Storage().allowances[msg.sender][\n            _spender\n        ] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function increaseApproval(address _spender, uint256 _amount)\n        external\n        override\n        returns (bool)\n    {\n        require(_spender != address(0), \"SPENDER_INVALID\");\n        LibERC20Storage.ERC20Storage storage es =\n            LibERC20Storage.erc20Storage();\n        es.allowances[msg.sender][_spender] = es.allowances[msg.sender][\n            _spender\n        ]\n            .add(_amount);\n        emit Approval(\n            msg.sender,\n            _spender,\n            es.allowances[msg.sender][_spender]\n        );\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint256 _amount)\n        external\n        override\n        returns (bool)\n    {\n        require(_spender != address(0), \"SPENDER_INVALID\");\n        LibERC20Storage.ERC20Storage storage es =\n            LibERC20Storage.erc20Storage();\n        uint256 oldValue = es.allowances[msg.sender][_spender];\n        if (_amount > oldValue) {\n            es.allowances[msg.sender][_spender] = 0;\n        } else {\n            es.allowances[msg.sender][_spender] = oldValue.sub(_amount);\n        }\n        emit Approval(\n            msg.sender,\n            _spender,\n            es.allowances[msg.sender][_spender]\n        );\n        return true;\n    }\n\n    function transfer(address _to, uint256 _amount)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override returns (bool) {\n        LibERC20Storage.ERC20Storage storage es =\n            LibERC20Storage.erc20Storage();\n        require(_from != address(0), \"FROM_INVALID\");\n\n        // Update approval if not set to max uint256\n        if (es.allowances[_from][msg.sender] != uint256(-1)) {\n            uint256 newApproval = es.allowances[_from][msg.sender].sub(_amount);\n            es.allowances[_from][msg.sender] = newApproval;\n            emit Approval(_from, msg.sender, newApproval);\n        }\n\n        _transfer(_from, _to, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return LibERC20Storage.erc20Storage().allowances[_owner][_spender];\n    }\n\n    function balanceOf(address _of) external view override returns (uint256) {\n        return LibERC20Storage.erc20Storage().balances[_of];\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return LibERC20Storage.erc20Storage().totalSupply;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        LibERC20Storage.ERC20Storage storage es =\n            LibERC20Storage.erc20Storage();\n\n        es.balances[_from] = es.balances[_from].sub(_amount);\n        es.balances[_to] = es.balances[_to].add(_amount);\n\n        emit Transfer(_from, _to, _amount);\n    }\n}\ncontract BasketFacet is ReentryProtection, CallProtection, IBasketFacet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MIN_AMOUNT = 10**6;\n    uint256 public constant MAX_ENTRY_FEE = 10**17; // 10%\n    uint256 public constant MAX_EXIT_FEE = 10**17; // 10%\n    uint256 public constant MAX_ANNUAL_FEE = 10**17; // 10%\n    uint256 public constant HUNDRED_PERCENT = 10**18;\n\n    // Assuming a block gas limit of 12M this allows for a gas consumption per token of roughly 333k allowing 2M of overhead for addtional operations\n    uint256 public constant MAX_TOKENS = 30;\n\n    function addToken(address _token) external override protectedCall {\n        LibBasketStorage.BasketStorage storage bs =\n            LibBasketStorage.basketStorage();\n        require(!bs.inPool[_token], \"TOKEN_ALREADY_IN_POOL\");\n        require(bs.tokens.length < MAX_TOKENS, \"TOKEN_LIMIT_REACHED\");\n        // Enforce minimum to avoid rounding errors; (Minimum value is the same as in Balancer)\n        require(balance(_token) >= MIN_AMOUNT, \"BALANCE_TOO_SMALL\");\n\n        bs.inPool[_token] = true;\n        bs.tokens.push(IERC20(_token));\n\n        emit TokenAdded(_token);\n    }\n\n    function removeToken(address _token) external override protectedCall {\n        LibBasketStorage.BasketStorage storage bs =\n            LibBasketStorage.basketStorage();\n\n        require(bs.inPool[_token], \"TOKEN_NOT_IN_POOL\");\n\n        bs.inPool[_token] = false;\n\n        // remove token from array\n        for (uint256 i; i < bs.tokens.length; i++) {\n            if (address(bs.tokens[i]) == _token) {\n                bs.tokens[i] = bs.tokens[bs.tokens.length - 1];\n                bs.tokens.pop();\n                emit TokenRemoved(_token);\n                break;\n            }\n        }\n    }\n\n    function setEntryFee(uint256 _fee) external override protectedCall {\n        require(_fee <= MAX_ENTRY_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().entryFee = _fee;\n        emit EntryFeeSet(_fee);\n    }\n\n    function getEntryFee() external view override returns (uint256) {\n        return LibBasketStorage.basketStorage().entryFee;\n    }\n\n    function setExitFee(uint256 _fee) external override protectedCall {\n        require(_fee <= MAX_EXIT_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().exitFee = _fee;\n        emit ExitFeeSet(_fee);\n    }\n\n    function getExitFee() external view override returns (uint256) {\n        return LibBasketStorage.basketStorage().exitFee;\n    }\n\n    function setAnnualizedFee(uint256 _fee) external override protectedCall {\n        chargeOutstandingAnnualizedFee();\n        require(_fee <= MAX_ANNUAL_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().annualizedFee = _fee;\n        emit AnnualizedFeeSet(_fee);\n    }\n\n    function getAnnualizedFee() external view override returns (uint256) {\n        return LibBasketStorage.basketStorage().annualizedFee;\n    }\n\n    function setFeeBeneficiary(address _beneficiary)\n        external\n        override\n        protectedCall\n    {\n        chargeOutstandingAnnualizedFee();\n        LibBasketStorage.basketStorage().feeBeneficiary = _beneficiary;\n        emit FeeBeneficiarySet(_beneficiary);\n    }\n\n    function getFeeBeneficiary() external view override returns (address) {\n        return LibBasketStorage.basketStorage().feeBeneficiary;\n    }\n\n    function setEntryFeeBeneficiaryShare(uint256 _share)\n        external\n        override\n        protectedCall\n    {\n        require(_share <= HUNDRED_PERCENT, \"FEE_SHARE_TOO_BIG\");\n        LibBasketStorage.basketStorage().entryFeeBeneficiaryShare = _share;\n        emit EntryFeeBeneficiaryShareSet(_share);\n    }\n\n    function getEntryFeeBeneficiaryShare()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return LibBasketStorage.basketStorage().entryFeeBeneficiaryShare;\n    }\n\n    function setExitFeeBeneficiaryShare(uint256 _share)\n        external\n        override\n        protectedCall\n    {\n        require(_share <= HUNDRED_PERCENT, \"FEE_SHARE_TOO_BIG\");\n        LibBasketStorage.basketStorage().exitFeeBeneficiaryShare = _share;\n        emit ExitFeeBeneficiaryShareSet(_share);\n    }\n\n    function getExitFeeBeneficiaryShare()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return LibBasketStorage.basketStorage().exitFeeBeneficiaryShare;\n    }\n\n    function joinPool(uint256 _amount, uint16 _referral)\n        external\n        override\n        noReentry\n    {\n        require(!this.getLock(), \"POOL_LOCKED\");\n        chargeOutstandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs =\n            LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n        require(\n            totalSupply.add(_amount) <= this.getCap(),\n            \"MAX_POOL_CAP_REACHED\"\n        );\n\n        uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);\n\n        for (uint256 i; i < bs.tokens.length; i++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenAmount =\n                balance(address(token)).mul(_amount.add(feeAmount)).div(\n                    totalSupply\n                );\n            require(tokenAmount != 0, \"AMOUNT_TOO_SMALL\");\n            token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n        }\n\n        // If there is any fee that should go to the beneficiary mint it\n        if (\n            feeAmount != 0 &&\n            bs.entryFeeBeneficiaryShare != 0 &&\n            bs.feeBeneficiary != address(0)\n        ) {\n            uint256 feeBeneficiaryShare =\n                feeAmount.mul(bs.entryFeeBeneficiaryShare).div(10**18);\n            if (feeBeneficiaryShare != 0) {\n                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);\n            }\n        }\n\n        LibERC20.mint(msg.sender, _amount);\n        emit PoolJoined(msg.sender, _amount, _referral);\n    }\n\n    // Must be overwritten to withdraw from strategies\n    function exitPool(uint256 _amount, uint16 _referral)\n        external\n        virtual\n        override\n        noReentry\n    {\n        require(!this.getLock(), \"POOL_LOCKED\");\n        chargeOutstandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs =\n            LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n\n        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);\n\n        for (uint256 i; i < bs.tokens.length; i++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            // redeem less tokens if there is an exit fee\n            uint256 tokenAmount =\n                tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);\n            require(\n                tokenBalance.sub(tokenAmount) >= MIN_AMOUNT,\n                \"TOKEN_BALANCE_TOO_LOW\"\n            );\n            token.safeTransfer(msg.sender, tokenAmount);\n        }\n\n        // If there is any fee that should go to the beneficiary mint it\n        if (\n            feeAmount != 0 &&\n            bs.exitFeeBeneficiaryShare != 0 &&\n            bs.feeBeneficiary != address(0)\n        ) {\n            uint256 feeBeneficiaryShare =\n                feeAmount.mul(bs.exitFeeBeneficiaryShare).div(10**18);\n            if (feeBeneficiaryShare != 0) {\n                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);\n            }\n        }\n\n        require(\n            totalSupply.sub(_amount) >= MIN_AMOUNT,\n            \"POOL_TOKEN_BALANCE_TOO_LOW\"\n        );\n        LibERC20.burn(msg.sender, _amount);\n        emit PoolExited(msg.sender, _amount, _referral);\n    }\n\n    function calcOutStandingAnnualizedFee()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        LibBasketStorage.BasketStorage storage bs =\n            LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n\n        uint256 lastFeeClaimed = bs.lastAnnualizedFeeClaimed;\n        uint256 annualizedFee = bs.annualizedFee;\n\n        if (\n            annualizedFee == 0 ||\n            bs.feeBeneficiary == address(0) ||\n            lastFeeClaimed == 0\n        ) {\n            return 0;\n        }\n\n        uint256 timePassed = block.timestamp.sub(lastFeeClaimed);\n\n        return\n            totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(\n                365 days\n            );\n    }\n\n    function chargeOutstandingAnnualizedFee() public override {\n        uint256 outStandingFee = calcOutStandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs =\n            LibBasketStorage.basketStorage();\n\n        bs.lastAnnualizedFeeClaimed = block.timestamp;\n\n        // if there is any fee to mint and the beneficiary is set\n        // note: feeBeneficiary is already checked in calc function\n        if (outStandingFee != 0) {\n            LibERC20.mint(bs.feeBeneficiary, outStandingFee);\n        }\n\n        emit FeeCharged(outStandingFee);\n    }\n\n    // returns true when locked\n    function getLock() external view override returns (bool) {\n        LibBasketStorage.BasketStorage storage bs =\n            LibBasketStorage.basketStorage();\n        return bs.lockBlock == 0 || bs.lockBlock >= block.number;\n    }\n\n    function getTokenInPool(address _token)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return LibBasketStorage.basketStorage().inPool[_token];\n    }\n\n    function getLockBlock() external view override returns (uint256) {\n        return LibBasketStorage.basketStorage().lockBlock;\n    }\n\n    // lock up to and including _lock blocknumber\n    function setLock(uint256 _lock) external override protectedCall {\n        LibBasketStorage.basketStorage().lockBlock = _lock;\n        emit LockSet(_lock);\n    }\n\n    function setCap(uint256 _maxCap) external override protectedCall {\n        LibBasketStorage.basketStorage().maxCap = _maxCap;\n        emit CapSet(_maxCap);\n    }\n\n    // Seperated balance function to allow yearn like strategies to be hooked up by inheriting from this contract and overriding\n    function balance(address _token) public view override returns (uint256) {\n        return IERC20(_token).balanceOf(address(this));\n    }\n\n    function getTokens() external view override returns (address[] memory) {\n        IERC20[] memory tokens = LibBasketStorage.basketStorage().tokens;\n        address[] memory result = new address[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            result[i] = address(tokens[i]);\n        }\n\n        return (result);\n    }\n\n    function getCap() external view override returns (uint256) {\n        return LibBasketStorage.basketStorage().maxCap;\n    }\n\n    function calcTokensForAmount(uint256 _amount)\n        external\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory amounts)\n    {\n        LibBasketStorage.BasketStorage storage bs =\n            LibBasketStorage.basketStorage();\n        uint256 totalSupply =\n            LibERC20Storage.erc20Storage().totalSupply.add(\n                calcOutStandingAnnualizedFee()\n            );\n\n        tokens = new address[](bs.tokens.length);\n        amounts = new uint256[](bs.tokens.length);\n\n        for (uint256 i; i < bs.tokens.length; i++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            uint256 tokenAmount = tokenBalance.mul(_amount).div(totalSupply);\n            // Add entry fee\n            tokenAmount = tokenAmount.add(\n                tokenAmount.mul(bs.entryFee).div(10**18)\n            );\n\n            tokens[i] = address(token);\n            amounts[i] = tokenAmount;\n        }\n\n        return (tokens, amounts);\n    }\n\n    function calcTokensForAmountExit(uint256 _amount)\n        external\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory amounts)\n    {\n        LibBasketStorage.BasketStorage storage bs =\n            LibBasketStorage.basketStorage();\n        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);\n        uint256 totalSupply =\n            LibERC20Storage.erc20Storage().totalSupply.add(\n                calcOutStandingAnnualizedFee()\n            );\n\n        tokens = new address[](bs.tokens.length);\n        amounts = new uint256[](bs.tokens.length);\n\n        for (uint256 i; i < bs.tokens.length; i++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            uint256 tokenAmount =\n                tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);\n\n            tokens[i] = address(token);\n            amounts[i] = tokenAmount;\n        }\n\n        return (tokens, amounts);\n    }\n}\ncontract SingleTokenJoinV2 {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Can be any IPangolinRouter or IUniRouter ...\n    IPangolinRouter public immutable uniSwapLikeRouter;\n    // WETH or WAVAX ...\n    IERC20 public immutable INTERMEDIATE_TOKEN;\n\n    struct UnderlyingTrade {\n        UniswapV2SwapStruct[] swaps;\n        uint256 quantity; //Quantity to buy\n    }\n\n    struct UniswapV2SwapStruct {\n        address exchange;\n        address[] path;\n    }\n    struct JoinTokenStructV2 {\n        address inputToken;\n        address outputBasket;\n        uint256 inputAmount;\n        uint256 outputAmount;\n        UnderlyingTrade[] trades;\n        uint256 deadline;\n        uint16 referral;\n    }\n\n    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter) {\n        require(_INTERMEDIATE_TOKEN != address(0), \"INTERMEDIATE_ZERO\");\n        require(_uniSwapLikeRouter != address(0), \"UNI_ROUTER_ZERO\");\n\n        INTERMEDIATE_TOKEN = IERC20(_INTERMEDIATE_TOKEN);\n        uniSwapLikeRouter = IPangolinRouter(_uniSwapLikeRouter);\n    }\n\n    function _maxApprove(IERC20 token, address spender) internal {\n        if (\n            token.allowance(address(this), spender) <\n            token.balanceOf(address(this))\n        ) {\n            token.approve(spender, uint256(-1));\n        }\n    }\n\n    function joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)\n        external\n    {\n        // ######## INIT TOKEN #########\n        IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);\n\n        inputToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _joinTokenStruct.inputAmount\n        );\n\n        _joinTokenSingle(_joinTokenStruct);\n\n        // ######## SEND TOKEN #########\n        uint256 remainingIntermediateBalance = inputToken.balanceOf(\n            address(this)\n        );\n        if (remainingIntermediateBalance > 0) {\n            inputToken.safeTransfer(msg.sender, remainingIntermediateBalance);\n        }\n    }\n\n    function _joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)\n        internal\n    {\n        // ######## INIT TOKEN #########\n        IERC20 outputToken = IERC20(_joinTokenStruct.outputBasket);\n\n        for (uint256 i; i < _joinTokenStruct.trades.length; i++) {\n            UnderlyingTrade calldata trade = _joinTokenStruct.trades[i];\n            uint256[] memory inputs = new uint256[](trade.swaps.length + 1);\n            inputs[0] = trade.quantity;\n            //Get inputs to\n            for (uint256 j; j < trade.swaps.length; j++) {\n                UniswapV2SwapStruct calldata swap = trade.swaps[\n                    trade.swaps.length - j - 1\n                ];\n                uint256[] memory amounts = IPangolinRouter(swap.exchange)\n                    .getAmountsIn(inputs[j], swap.path);\n                inputs[j + 1] = amounts[0];\n            }\n\n            for (uint256 j; j < trade.swaps.length; j++) {\n                UniswapV2SwapStruct calldata swap = trade.swaps[j];\n                uint256 amountIn = inputs[trade.swaps.length - j];\n                _maxApprove(IERC20(swap.path[0]), address(swap.exchange));\n                IPangolinRouter(swap.exchange).swapExactTokensForTokens(\n                    amountIn,\n                    0,\n                    swap.path,\n                    address(this),\n                    block.timestamp\n                );\n            }\n        }\n\n        address[] memory tokens = IBasketFacet(_joinTokenStruct.outputBasket)\n            .getTokens();\n\n        for (uint256 i; i < tokens.length; i++) {\n            _maxApprove(IERC20(tokens[i]), _joinTokenStruct.outputBasket);\n        }\n\n        IBasketFacet(_joinTokenStruct.outputBasket).joinPool(\n            _joinTokenStruct.outputAmount,\n            _joinTokenStruct.referral\n        );\n\n        // ######## SEND TOKEN #########\n\n        uint256 outputAmount = outputToken.balanceOf(address(this));\n        require(\n            outputAmount == _joinTokenStruct.outputAmount,\n            \"FAILED_OUTPUT_AMOUNT\"\n        );\n        outputToken.safeTransfer(msg.sender, outputAmount);\n    }\n}\ncontract SingleNativeTokenExit {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Can be any IPangolinRouter or IUniRouter ...\n    IPangolinRouter public immutable uniSwapLikeRouter;\n    // WETH or WAVAX ...\n    IERC20 public immutable INTERMEDIATE_TOKEN;\n    struct ExitTokenStruct {\n        address inputBasket;\n        uint256 inputAmount;\n        uint256 minAmount;\n        uint256 deadline;\n        uint16 referral;\n    }\n\n    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter) {\n        require(_INTERMEDIATE_TOKEN != address(0), \"INTERMEDIATE_ZERO\");\n        require(_uniSwapLikeRouter != address(0), \"UNI_ROUTER_ZERO\");\n\n        INTERMEDIATE_TOKEN = IERC20(_INTERMEDIATE_TOKEN);\n        uniSwapLikeRouter = IPangolinRouter(_uniSwapLikeRouter);\n    }\n\n    receive() external payable {}\n\n    function _maxApprove(IERC20 token, address spender) internal {\n        if (\n            token.allowance(address(this), spender) <\n            token.balanceOf(address(this))\n        ) {\n            token.approve(spender, uint256(-1));\n        }\n    }\n\n    function exitEth(ExitTokenStruct calldata _exitTokenStruct) external {\n        // ######## INIT TOKEN #########\n        IERC20 inputBasket = IERC20(_exitTokenStruct.inputBasket);\n\n        inputBasket.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _exitTokenStruct.inputAmount\n        );\n\n        IBasketFacet(address(inputBasket)).exitPool(\n            _exitTokenStruct.inputAmount,\n            _exitTokenStruct.referral\n        );\n\n        address[] memory tokens = IBasketFacet(address(inputBasket))\n            .getTokens();\n\n        address[] memory path = new address[](2);\n        path[1] = address(INTERMEDIATE_TOKEN);\n\n        for (uint256 i; i < tokens.length; i++) {\n            path[0] = tokens[i];\n\n            _maxApprove(IERC20(tokens[i]), address(uniSwapLikeRouter));\n            uniSwapLikeRouter.swapExactTokensForTokens(\n                IERC20(tokens[i]).balanceOf(address(this)),\n                0,\n                path,\n                address(this),\n                _exitTokenStruct.deadline\n            );\n        }\n\n        uint256 intermediateTokenBalance = INTERMEDIATE_TOKEN.balanceOf(\n            address(this)\n        );\n        require(\n            intermediateTokenBalance >= _exitTokenStruct.minAmount,\n            \"Insufficient output\"\n        );\n\n        IWrappedNativeToken(address(INTERMEDIATE_TOKEN)).withdraw(\n            intermediateTokenBalance\n        );\n        msg.sender.transfer(intermediateTokenBalance);\n    }\n}\ncontract RebalanceManagerV2 is IRebalanceManagerV2 {\n    IExperiPie public immutable basket;\n\n    mapping(address => bool) public exchanges;\n\n    address public rebalanceManager;\n\n    event Rebalanced(address indexed basket);\n    event Swaped(\n        address indexed basket,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 quantity,\n        uint256 returnedQuantity\n    );\n    event RebalanceManagerSet(address indexed rebalanceManager);\n\n    constructor(address _basket, address _uniswapV2Like) {\n        require(_basket != address(0), \"INVALID_BASKET\");\n        require(_uniswapV2Like != address(0), \"INVALID_UNISWAP_V2\");\n\n        basket = IExperiPie(_basket);\n        rebalanceManager = msg.sender;\n        exchanges[_uniswapV2Like] = true;\n    }\n\n    modifier onlyRebalanceManager() {\n        require(msg.sender == rebalanceManager, \"NOT_REBALANCE_MANAGER\");\n        _;\n    }\n\n    function setRebalanceManager(address _rebalanceManager)\n        external\n        onlyRebalanceManager\n    {\n        rebalanceManager = _rebalanceManager;\n        emit RebalanceManagerSet(_rebalanceManager);\n    }\n\n    function setExchange(address _exchange, bool _activated)\n        external\n        onlyRebalanceManager\n    {\n        exchanges[_exchange] = _activated;\n    }\n\n    function _swapUniswapV2(\n        UniswapV2SwapStruct calldata swap,\n        address recipient,\n        uint256 deadline\n    ) internal {\n        if (\n            IERC20(swap.path[0]).allowance(address(basket), swap.exchange) <\n            swap.quantity\n        ) {\n            basket.singleCall(\n                swap.path[0],\n                abi.encodeWithSelector(\n                    IERC20(swap.path[0]).approve.selector,\n                    address(swap.exchange),\n                    uint256(-1)\n                ),\n                0\n            );\n        }\n        // Swap on exchange\n        // exchange.swapExactTokensForTokens(amount, minReturnAmount, path, recipient, deadline);\n        basket.singleCall(\n            swap.exchange,\n            abi.encodeWithSelector(\n                IUniswapV2Router02(swap.exchange)\n                    .swapExactTokensForTokens\n                    .selector,\n                swap.quantity,\n                swap.minReturn,\n                swap.path,\n                recipient,\n                deadline\n            ),\n            0\n        );\n\n        emit Swaped(\n            address(basket),\n            swap.path[0],\n            swap.path[swap.path.length - 1],\n            swap.quantity,\n            swap.minReturn\n        );\n    }\n\n    function removeToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        //if there is a token balance of the token is not in the pool, skip\n        if (balance != 0 || !inPool) {\n            return;\n        }\n\n        // remove token\n        basket.singleCall(\n            address(basket),\n            abi.encodeWithSelector(basket.removeToken.selector, _token),\n            0\n        );\n    }\n\n    function addToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        // If token has no balance or is already in the pool, skip\n        if (balance == 0 || inPool) {\n            return;\n        }\n\n        // add token\n        basket.singleCall(\n            address(basket),\n            abi.encodeWithSelector(basket.addToken.selector, _token),\n            0\n        );\n    }\n\n    function lockBasketData(uint256 _block) internal {\n        basket.singleCall(\n            address(basket),\n            abi.encodeWithSelector(basket.setLock.selector, _block),\n            0\n        );\n    }\n\n    /**\n        @notice Rebalance underling token\n        @param _swapsV2 Swaps to perform\n        @param _deadline Unix timestamp after which the transaction will revert.\n    */\n    function rebalance(\n        UniswapV2SwapStruct[] calldata _swapsV2,\n        uint256 _deadline\n    ) external override onlyRebalanceManager {\n        lockBasketData(block.number + 30);\n\n        // remove token from array\n        for (uint256 i; i < _swapsV2.length; i++) {\n            require(exchanges[_swapsV2[i].exchange], \"NOT_UNISWAP_V2\");\n\n            //swap token\n            _swapUniswapV2(_swapsV2[i], address(basket), _deadline);\n\n            //add to token if missing\n            addToken(_swapsV2[i].path[_swapsV2[i].path.length - 1]);\n\n            //remove from token if resulting quantity is 0\n            removeToken(_swapsV2[i].path[0]);\n        }\n\n        emit Rebalanced(address(basket));\n    }\n}\ncontract RebalanceManagerV3 is IRebalanceManagerV3 {\n    IExperiPie public immutable basket;\n    uint256 public immutable lockTime;\n    mapping(address => bool) public exchanges;\n\n    address public rebalanceManager;\n\n    event Rebalanced(address indexed basket);\n    event Swaped(\n        address indexed basket,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 quantity,\n        uint256 returnedQuantity\n    );\n    event RebalanceManagerSet(address indexed rebalanceManager);\n\n    constructor(\n        address _basket,\n        address _uniswapV2Like,\n        uint256 _lockTime\n    ) {\n        require(_basket != address(0), \"INVALID_BASKET\");\n        require(_uniswapV2Like != address(0), \"INVALID_UNISWAP_V2\");\n\n        basket = IExperiPie(_basket);\n        rebalanceManager = msg.sender;\n        exchanges[_uniswapV2Like] = true;\n        lockTime = _lockTime;\n    }\n\n    modifier onlyRebalanceManager() {\n        require(msg.sender == rebalanceManager, \"NOT_REBALANCE_MANAGER\");\n        _;\n    }\n\n    function setRebalanceManager(address _rebalanceManager)\n        external\n        onlyRebalanceManager\n    {\n        rebalanceManager = _rebalanceManager;\n        emit RebalanceManagerSet(_rebalanceManager);\n    }\n\n    function setExchange(address _exchange, bool _activated)\n        external\n        onlyRebalanceManager\n    {\n        exchanges[_exchange] = _activated;\n    }\n\n    function _swapUniswapV2(\n        address exchange,\n        uint256 quantity,\n        uint256 minReturn,\n        address[] calldata path,\n        address recipient,\n        uint256 deadline\n    ) internal {\n        if (IERC20(path[0]).allowance(address(basket), exchange) < quantity) {\n            basket.singleCall(\n                path[0],\n                abi.encodeWithSelector(\n                    IERC20(path[0]).approve.selector,\n                    address(exchange),\n                    uint256(-1)\n                ),\n                0\n            );\n        }\n\n        // Swap on exchange\n        basket.singleCall(\n            exchange,\n            abi.encodeWithSelector(\n                IUniswapV2Router02(exchange).swapExactTokensForTokens.selector,\n                quantity,\n                minReturn,\n                path,\n                recipient,\n                deadline\n            ),\n            0\n        );\n\n        emit Swaped(\n            address(basket),\n            path[0],\n            path[path.length - 1],\n            quantity,\n            minReturn\n        );\n    }\n\n    function removeToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        //if there is a token balance of the token is not in the pool, skip\n        if (balance != 0 || !inPool) {\n            return;\n        }\n\n        // remove token\n        basket.singleCall(\n            address(basket),\n            abi.encodeWithSelector(basket.removeToken.selector, _token),\n            0\n        );\n    }\n\n    function addToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        // If token has no balance or is already in the pool, skip\n        if (balance == 0 || inPool) {\n            return;\n        }\n\n        // add token\n        basket.singleCall(\n            address(basket),\n            abi.encodeWithSelector(basket.addToken.selector, _token),\n            0\n        );\n    }\n\n    function lockBasketData(uint256 _block) internal {\n        basket.singleCall(\n            address(basket),\n            abi.encodeWithSelector(basket.setLock.selector, _block),\n            0\n        );\n    }\n\n    /**\n        @notice Lock before Rebalance\n    */\n    function lock() external onlyRebalanceManager {\n        lockBasketData(block.number + lockTime);\n    }\n\n    /**\n        @notice Rebalance underling token\n        @param _swapsV2 Swaps to perform\n        @param _deadline Unix timestamp after which the transaction will revert.\n    */\n    function rebalance(UnderlyingTrade[] calldata _swapsV2, uint256 _deadline)\n        external\n        override\n        onlyRebalanceManager\n    {\n        require(basket.getLock(), \"REQUIRE_LOCK\");\n        lockBasketData(block.number + 30);\n\n        for (uint256 i; i < _swapsV2.length; i++) {\n            UnderlyingTrade calldata trade = _swapsV2[i];\n            uint256 input = trade.quantity;\n            address targetToken = trade.swaps[0].path[0];\n            //internal trades\n            for (uint256 j; j < trade.swaps.length; j++) {\n                UniswapV2SwapStruct calldata swap = trade.swaps[j];\n                require(exchanges[swap.exchange], \"INVALID_EXCHANGE\");\n                require(targetToken == swap.path[0], \"INVALID_INPUT_TOKEN\");\n                targetToken = swap.path[swap.path.length - 1];\n\n                uint256 oldBalance = IERC20(targetToken).balanceOf(\n                    address(basket)\n                );\n                //swap token\n                _swapUniswapV2(\n                    swap.exchange,\n                    input,\n                    0,\n                    swap.path,\n                    address(basket),\n                    _deadline\n                );\n                //The output of this trade is the input for the next trade\n                input =\n                    IERC20(targetToken).balanceOf(address(basket)) -\n                    oldBalance;\n            }\n            require(trade.minimumReturn <= input, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n            //add to token if missing\n            UniswapV2SwapStruct calldata toAdd = trade.swaps[\n                trade.swaps.length - 1\n            ];\n            addToken(toAdd.path[toAdd.path.length - 1]);\n\n            //remove from token if resulting quantity is 0\n            removeToken(trade.swaps[0].path[0]);\n        }\n\n        emit Rebalanced(address(basket));\n    }\n}\ncontract EthSingleTokenJoin is SingleTokenJoin {\n    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter)\n        SingleTokenJoin(_INTERMEDIATE_TOKEN, _uniSwapLikeRouter)\n    {}\n\n    receive() external payable {}\n\n    function joinTokenEth(JoinTokenStruct calldata _joinTokenStruct)\n        external\n        payable\n    {\n        require(\n            _joinTokenStruct.inputToken == address(INTERMEDIATE_TOKEN),\n            \"Wrong input token\"\n        );\n        require(msg.value > 0, \"No native token passed\");\n\n        // ######## Wrap TOKEN #########\n        address(INTERMEDIATE_TOKEN).call{value: msg.value}(\"\");\n\n        _joinTokenSingle(_joinTokenStruct);\n\n        uint256 remainingIntermediateBalance = INTERMEDIATE_TOKEN.balanceOf(\n            address(this)\n        );\n        if (remainingIntermediateBalance > 0) {\n            IWrappedNativeToken(address(INTERMEDIATE_TOKEN)).withdraw(\n                remainingIntermediateBalance\n            );\n            msg.sender.transfer(remainingIntermediateBalance);\n        }\n    }\n}\ncontract RebalanceManager is IRebalanceManager {\n    IExperiPie public immutable basket;\n\n    enum ExchangeType {\n        NoExchange,\n        UniswapV2,\n        UniswapV3\n    }\n    mapping(address => ExchangeType) public exchanges;\n\n    address public rebalanceManager;\n\n    event Rebalanced(address indexed basket);\n    event Swaped(\n        address indexed basket,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 quantity,\n        uint256 returnedQuantity\n    );\n    event RebalanceManagerSet(address indexed rebalanceManager);\n\n    constructor(\n        address _basket,\n        address _uniswapV2Like,\n        address _uniswapV3\n    ) {\n        require(_basket != address(0), \"INVALID_BASKET\");\n        require(_uniswapV2Like != address(0), \"INVALID_UNISWAP_V2\");\n        require(_uniswapV3 != address(0), \"INVALID_UNISWAP_V3\");\n\n        basket = IExperiPie(_basket);\n        rebalanceManager = msg.sender;\n        exchanges[_uniswapV2Like] = ExchangeType.UniswapV2;\n        exchanges[_uniswapV3] = ExchangeType.UniswapV3;\n    }\n\n    modifier onlyRebalanceManager() {\n        require(msg.sender == rebalanceManager, \"NOT_REBALANCE_MANAGER\");\n        _;\n    }\n\n    function setRebalanceManager(address _rebalanceManager)\n        external\n        onlyRebalanceManager\n    {\n        rebalanceManager = _rebalanceManager;\n        emit RebalanceManagerSet(_rebalanceManager);\n    }\n\n    function setExchange(address _exchange, ExchangeType exchangeType)\n        external\n        onlyRebalanceManager\n    {\n        exchanges[_exchange] = exchangeType;\n    }\n\n    function _swapUniswapV3(\n        UniswapV3SwapStruct calldata swap,\n        address recipient,\n        uint256 deadline\n    ) internal {\n        if (\n            IERC20(swap.tokenIn).allowance(address(basket), swap.exchange) <\n            swap.quantity\n        ) {\n            basket.singleCall(\n                swap.tokenIn,\n                abi.encodeWithSelector(\n                    IERC20(swap.tokenIn).approve.selector,\n                    address(swap.exchange),\n                    uint256(-1)\n                ),\n                0\n            );\n        }\n        ISwapRouter.ExactInputParams memory params = ISwapRouter\n            .ExactInputParams(\n                swap.path,\n                recipient,\n                deadline,\n                swap.quantity,\n                swap.minReturn\n            );\n\n        // Swap on uniswapV3\n        // uniswapV3.exactInputSingle(params);\n        basket.singleCall(\n            address(swap.exchange),\n            abi.encodeWithSelector(\n                ISwapRouter(swap.exchange).exactInput.selector,\n                params\n            ),\n            0\n        );\n        emit Swaped(\n            address(basket),\n            swap.tokenIn,\n            swap.tokenOut,\n            swap.quantity,\n            swap.minReturn\n        );\n    }\n\n    function _swapUniswapV2(\n        UniswapV2SwapStruct calldata swap,\n        address recipient,\n        uint256 deadline\n    ) internal {\n        if (\n            IERC20(swap.path[0]).allowance(address(basket), swap.exchange) <\n            swap.quantity\n        ) {\n            basket.singleCall(\n                swap.path[0],\n                abi.encodeWithSelector(\n                    IERC20(swap.path[0]).approve.selector,\n                    address(swap.exchange),\n                    uint256(-1)\n                ),\n                0\n            );\n        }\n        // Swap on exchange\n        // exchange.swapExactTokensForTokens(amount, minReturnAmount, path, recipient, deadline);\n        basket.singleCall(\n            swap.exchange,\n            abi.encodeWithSelector(\n                IUniswapV2Router02(swap.exchange)\n                    .swapExactTokensForTokens\n                    .selector,\n                swap.quantity,\n                swap.minReturn,\n                swap.path,\n                recipient,\n                deadline\n            ),\n            0\n        );\n\n        emit Swaped(\n            address(basket),\n            swap.path[0],\n            swap.path[swap.path.length - 1],\n            swap.quantity,\n            swap.minReturn\n        );\n    }\n\n    function removeToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        //if there is a token balance of the token is not in the pool, skip\n        if (balance != 0 || !inPool) {\n            return;\n        }\n\n        // remove token\n        basket.singleCall(\n            address(basket),\n            abi.encodeWithSelector(basket.removeToken.selector, _token),\n            0\n        );\n    }\n\n    function addToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        // If token has no balance or is already in the pool, skip\n        if (balance == 0 || inPool) {\n            return;\n        }\n\n        // add token\n        basket.singleCall(\n            address(basket),\n            abi.encodeWithSelector(basket.addToken.selector, _token),\n            0\n        );\n    }\n\n    function lockBasketData(uint256 _block) internal {\n        basket.singleCall(\n            address(basket),\n            abi.encodeWithSelector(basket.setLock.selector, _block),\n            0\n        );\n    }\n\n    /**\n        @notice Rebalance underling token\n        @param _swapsV2 Swaps to perform\n        @param _swapsV3 Swaps to perform\n        @param _deadline Unix timestamp after which the transaction will revert.\n    */\n    function rebalance(\n        UniswapV2SwapStruct[] calldata _swapsV2,\n        UniswapV3SwapStruct[] calldata _swapsV3,\n        uint256 _deadline\n    ) external override onlyRebalanceManager {\n        lockBasketData(block.number + 30);\n\n        // remove token from array\n        for (uint256 i; i < _swapsV2.length; i++) {\n            require(\n                exchanges[_swapsV2[i].exchange] == ExchangeType.UniswapV2,\n                \"NOT_UNISWAP_V2\"\n            );\n\n            //swap token\n            _swapUniswapV2(_swapsV2[i], address(basket), _deadline);\n\n            //add to token if missing\n            addToken(_swapsV2[i].path[_swapsV2[i].path.length - 1]);\n\n            //remove from token if resulting quantity is 0\n            removeToken(_swapsV2[i].path[0]);\n        }\n\n        for (uint256 i; i < _swapsV3.length; i++) {\n            require(\n                exchanges[_swapsV3[i].exchange] == ExchangeType.UniswapV3,\n                \"NOT_UNISWAP_V3\"\n            );\n\n            //swap token\n            _swapUniswapV3(_swapsV3[i], address(basket), _deadline);\n\n            //add to token if missing\n            addToken(_swapsV3[i].tokenOut);\n\n            //remove from token if resulting quantity is 0\n            removeToken(_swapsV3[i].tokenIn);\n        }\n        emit Rebalanced(address(basket));\n    }\n}\ncontract SingleNativeTokenExitV2 {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Can be any IPangolinRouter or IUniRouter ...\n    IPangolinRouter public immutable uniSwapLikeRouter;\n    // WETH or WAVAX ...\n    IERC20 public immutable INTERMEDIATE_TOKEN;\n\n    struct ExitUnderlyingTrade {\n        ExitUniswapV2SwapStruct[] swaps;\n    }\n\n    struct ExitUniswapV2SwapStruct {\n        address exchange;\n        address[] path;\n    }\n    struct ExitTokenStructV2 {\n        address inputBasket;\n        uint256 inputAmount;\n        uint256 minAmount;\n        uint256 deadline;\n        uint16 referral;\n        ExitUnderlyingTrade[] trades;\n    }\n\n    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter) {\n        require(_INTERMEDIATE_TOKEN != address(0), \"INTERMEDIATE_ZERO\");\n        require(_uniSwapLikeRouter != address(0), \"UNI_ROUTER_ZERO\");\n\n        INTERMEDIATE_TOKEN = IERC20(_INTERMEDIATE_TOKEN);\n        uniSwapLikeRouter = IPangolinRouter(_uniSwapLikeRouter);\n    }\n\n    receive() external payable {}\n\n    function _maxApprove(IERC20 token, address spender) internal {\n        if (\n            token.allowance(address(this), spender) <\n            token.balanceOf(address(this))\n        ) {\n            token.approve(spender, uint256(-1));\n        }\n    }\n\n    function _exit(ExitTokenStructV2 calldata _exitTokenStruct) internal {\n        // ######## INIT TOKEN #########\n        IERC20 inputBasket = IERC20(_exitTokenStruct.inputBasket);\n\n        inputBasket.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _exitTokenStruct.inputAmount\n        );\n\n        IBasketFacet(address(inputBasket)).exitPool(\n            _exitTokenStruct.inputAmount,\n            _exitTokenStruct.referral\n        );\n\n        for (uint256 i; i < _exitTokenStruct.trades.length; i++) {\n            ExitUnderlyingTrade calldata trade = _exitTokenStruct.trades[i];\n            for (uint256 j; j < trade.swaps.length; j++) {\n                ExitUniswapV2SwapStruct calldata swap = trade.swaps[j];\n                _maxApprove(IERC20(swap.path[0]), address(swap.exchange));\n                IPangolinRouter(swap.exchange).swapExactTokensForTokens(\n                    IERC20(swap.path[0]).balanceOf(address(this)),\n                    0,\n                    swap.path,\n                    address(this),\n                    block.timestamp\n                );\n            }\n        }\n    }\n\n    function exit(ExitTokenStructV2 calldata _exitTokenStruct) external {\n        _exit(_exitTokenStruct);\n        address[] calldata path = _exitTokenStruct\n            .trades[0]\n            .swaps[_exitTokenStruct.trades[0].swaps.length - 1]\n            .path;\n        IERC20 outputToken = IERC20(path[path.length - 1]); //this could be not the target token\n\n        uint256 outputTokenBalance = outputToken.balanceOf(address(this));\n        require(\n            outputTokenBalance >= _exitTokenStruct.minAmount,\n            \"Insufficient output\"\n        );\n\n        outputToken.transfer(msg.sender, outputTokenBalance);\n    }\n\n    function exitEth(ExitTokenStructV2 calldata _exitTokenStruct) external {\n        _exit(_exitTokenStruct);\n\n        uint256 intermediateTokenBalance = INTERMEDIATE_TOKEN.balanceOf(\n            address(this)\n        );\n        require(\n            intermediateTokenBalance >= _exitTokenStruct.minAmount,\n            \"Insufficient output\"\n        );\n\n        IWrappedNativeToken(address(INTERMEDIATE_TOKEN)).withdraw(\n            intermediateTokenBalance\n        );\n        msg.sender.transfer(intermediateTokenBalance);\n    }\n}\ncontract SingleTokenJoin {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Can be any IPangolinRouter or IUniRouter ...\n    IPangolinRouter public immutable uniSwapLikeRouter;\n    // WETH or WAVAX ...\n    IERC20 public immutable INTERMEDIATE_TOKEN;\n    struct JoinTokenStruct {\n        address inputToken;\n        address outputBasket;\n        uint256 inputAmount;\n        uint256 outputAmount;\n        uint256 deadline;\n        uint16 referral;\n    }\n\n    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter) {\n        require(_INTERMEDIATE_TOKEN != address(0), \"INTERMEDIATE_ZERO\");\n        require(_uniSwapLikeRouter != address(0), \"UNI_ROUTER_ZERO\");\n\n        INTERMEDIATE_TOKEN = IERC20(_INTERMEDIATE_TOKEN);\n        uniSwapLikeRouter = IPangolinRouter(_uniSwapLikeRouter);\n    }\n\n    function _maxApprove(IERC20 token, address spender) internal {\n        if (\n            token.allowance(address(this), spender) <\n            token.balanceOf(address(this))\n        ) {\n            token.approve(spender, uint256(-1));\n        }\n    }\n\n    function joinTokenSingle(JoinTokenStruct calldata _joinTokenStruct)\n        external\n    {\n        // ######## INIT TOKEN #########\n        IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);\n\n        inputToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _joinTokenStruct.inputAmount\n        );\n\n        _joinTokenSingle(_joinTokenStruct);\n\n        // ######## SEND TOKEN #########\n        uint256 remainingIntermediateBalance = INTERMEDIATE_TOKEN.balanceOf(\n            address(this)\n        );\n        if (remainingIntermediateBalance > 0) {\n            INTERMEDIATE_TOKEN.safeTransfer(\n                msg.sender,\n                remainingIntermediateBalance\n            );\n        }\n    }\n\n    function _joinTokenSingle(JoinTokenStruct calldata _joinTokenStruct)\n        internal\n    {\n        // ######## INIT TOKEN #########\n        IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);\n        IERC20 outputToken = IERC20(_joinTokenStruct.outputBasket);\n\n        (address[] memory tokens, uint256[] memory amounts) = IBasketFacet(\n            _joinTokenStruct.outputBasket\n        ).calcTokensForAmount(_joinTokenStruct.outputAmount);\n\n        // ######## SWAP TOKEN #########\n        address[] memory path = new address[](2);\n        if (_joinTokenStruct.inputToken != address(INTERMEDIATE_TOKEN)) {\n            _maxApprove(inputToken, address(uniSwapLikeRouter));\n\n            path[0] = _joinTokenStruct.inputToken;\n            path[1] = address(INTERMEDIATE_TOKEN);\n            uint256[] memory amountsOut = uniSwapLikeRouter.getAmountsOut(\n                _joinTokenStruct.inputAmount,\n                path\n            );\n\n            uniSwapLikeRouter.swapExactTokensForTokens(\n                _joinTokenStruct.inputAmount,\n                amountsOut[amountsOut.length - 1],\n                path,\n                address(this),\n                _joinTokenStruct.deadline\n            );\n        }\n\n        path[0] = address(INTERMEDIATE_TOKEN);\n\n        _maxApprove(INTERMEDIATE_TOKEN, address(uniSwapLikeRouter));\n        for (uint256 i; i < tokens.length; i++) {\n            path[1] = tokens[i];\n\n            uint256[] memory amountsIn = uniSwapLikeRouter.getAmountsIn(\n                amounts[i],\n                path\n            );\n\n            uniSwapLikeRouter.swapTokensForExactTokens(\n                amounts[i],\n                amountsIn[0],\n                path,\n                address(this),\n                _joinTokenStruct.deadline\n            );\n            _maxApprove(IERC20(tokens[i]), _joinTokenStruct.outputBasket);\n        }\n\n        IBasketFacet(_joinTokenStruct.outputBasket).joinPool(\n            _joinTokenStruct.outputAmount,\n            _joinTokenStruct.referral\n        );\n\n        // ######## SEND TOKEN #########\n\n        uint256 outputAmount = outputToken.balanceOf(address(this));\n        require(\n            outputAmount == _joinTokenStruct.outputAmount,\n            \"FAILED_OUTPUT_AMOUNT\"\n        );\n\n        outputToken.safeTransfer(msg.sender, outputAmount);\n    }\n}\ncontract CallProtection {\n    modifier protectedCall() {\n        require(\n            msg.sender == LibDiamond.diamondStorage().contractOwner ||\n                msg.sender == address(this),\n            \"NOT_ALLOWED\"\n        );\n        _;\n    }\n}\ncontract PieFactoryContract is Ownable {\n    using SafeERC20 for IERC20;\n\n    address[] public pies;\n    mapping(address => bool) public isPie;\n    address public defaultController;\n    address public diamondImplementation;\n\n    IDiamondCut.FacetCut[] public defaultCut;\n\n    event PieCreated(\n        address indexed pieAddress,\n        address indexed deployer,\n        uint256 indexed index\n    );\n\n    event DefaultControllerSet(address indexed controller);\n    event FacetAdded(IDiamondCut.FacetCut);\n    event FacetRemoved(IDiamondCut.FacetCut);\n\n    constructor() {\n        defaultController = msg.sender;\n    }\n\n    function setDefaultController(address _controller) external onlyOwner {\n        defaultController = _controller;\n        emit DefaultControllerSet(_controller);\n    }\n\n    function removeFacet(uint256 _index) external onlyOwner {\n        require(_index < defaultCut.length, \"INVALID_INDEX\");\n        emit FacetRemoved(defaultCut[_index]);\n        defaultCut[_index] = defaultCut[defaultCut.length - 1];\n        defaultCut.pop();\n    }\n\n    function addFacet(IDiamondCut.FacetCut memory _facet) external onlyOwner {\n        defaultCut.push(_facet);\n        emit FacetAdded(_facet);\n    }\n\n    // Diamond should be Initialized to prevent it from being selfdestructed\n    function setDiamondImplementation(address _diamondImplementation)\n        external\n        onlyOwner\n    {\n        diamondImplementation = _diamondImplementation;\n    }\n\n    function bakePie(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _initialSupply,\n        string memory _symbol,\n        string memory _name\n    ) external {\n        PProxy proxy = new PProxy();\n        Diamond d = Diamond(address(proxy));\n\n        proxy.setImplementation(diamondImplementation);\n\n        d.initialize(defaultCut, address(this));\n\n        pies.push(address(d));\n        isPie[address(d)] = true;\n\n        // emit DiamondCreated(address(d));\n        require(_tokens.length != 0, \"CANNOT_CREATE_ZERO_TOKEN_LENGTH_PIE\");\n        require(_tokens.length == _amounts.length, \"ARRAY_LENGTH_MISMATCH\");\n\n        IExperiPie pie = IExperiPie(address(d));\n\n        // Init erc20 facet\n        pie.initialize(_initialSupply, _name, _symbol);\n\n        // Transfer and add tokens\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20 token = IERC20(_tokens[i]);\n            token.safeTransferFrom(msg.sender, address(pie), _amounts[i]);\n            pie.addToken(_tokens[i]);\n        }\n\n        // Unlock pool\n        pie.setLock(1);\n\n        // Uncap pool\n        pie.setCap(uint256(-1));\n\n        // Send minted pie to msg.sender\n        pie.transfer(msg.sender, _initialSupply);\n        pie.transferOwnership(defaultController);\n        proxy.setProxyOwner(defaultController);\n\n        emit PieCreated(address(d), msg.sender, pies.length - 1);\n    }\n\n    function getDefaultCut()\n        external\n        view\n        returns (IDiamondCut.FacetCut[] memory)\n    {\n        return defaultCut;\n    }\n\n    function getDefaultCutCount() external view returns (uint256) {\n        return defaultCut.length;\n    }\n}\ncontract EthSingleTokenJoinV2 is SingleTokenJoinV2 {\n    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter)\n        SingleTokenJoinV2(_INTERMEDIATE_TOKEN, _uniSwapLikeRouter)\n    {}\n\n    receive() external payable {}\n\n    function joinTokenEth(JoinTokenStructV2 calldata _joinTokenStruct)\n        external\n        payable\n    {\n        require(\n            _joinTokenStruct.inputToken == address(INTERMEDIATE_TOKEN),\n            \"Wrong input token\"\n        );\n        require(msg.value > 0, \"No native token passed\");\n\n        // ######## Wrap TOKEN #########\n        address(INTERMEDIATE_TOKEN).call{value: msg.value}(\"\");\n\n        _joinTokenSingle(_joinTokenStruct);\n\n        uint256 remainingIntermediateBalance = INTERMEDIATE_TOKEN.balanceOf(\n            address(this)\n        );\n        if (remainingIntermediateBalance > 0) {\n            IWrappedNativeToken(address(INTERMEDIATE_TOKEN)).withdraw(\n                remainingIntermediateBalance\n            );\n            msg.sender.transfer(remainingIntermediateBalance);\n        }\n    }\n}\n",
    "bin": []
}