{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/69/nftx-protocol-v2",
    "external_functions": [
        [
            "NFTXEligibilityManager",
            "INFTXEligibility"
        ],
        [
            "NFTXInventoryStaking",
            "INFTXVaultFactory",
            "XTokenUpgradeable",
            "IERC20Upgradeable",
            "IERC20Metadata"
        ],
        [
            "NFTXLPStaking",
            "TimelockRewardDistributionTokenImpl",
            "INFTXVaultFactory",
            "StakingTokenProvider",
            "IERC20Metadata",
            "IRewardDistributionToken"
        ],
        [
            "IWETH"
        ],
        [
            "ReentrancyGuard"
        ],
        [
            "Ownable"
        ],
        [
            "NFTXMarketplaceZap",
            "IUniswapV2Router01",
            "INFTXVaultFactory",
            "IERC20Upgradeable",
            "INFTXFeeDistributor",
            "IWETH",
            "INFTXVault",
            "IERC1155Upgradeable"
        ],
        [
            "NFTXSimpleFeeDistributor",
            "INFTXVaultFactory",
            "IERC20Upgradeable",
            "INFTXInventoryStaking",
            "INFTXLPStaking"
        ],
        [
            "NFTXStakingZap",
            "IERC20Upgradeable",
            "INFTXVaultFactory",
            "INFTXSimpleFeeDistributor",
            "IUniswapV2Router01",
            "INFTXVault",
            "INFTXInventoryStaking",
            "IERC1155Upgradeable",
            "IWETH",
            "INFTXLPStaking"
        ],
        [
            "NFTXVaultFactoryUpgradeable",
            "INFTXFeeDistributor",
            "NFTXVaultUpgradeable",
            "IERC3156FlashBorrowerUpgradeable",
            "INFTXVaultFactory",
            "INFTXEligibilityManager",
            "INFTXEligibility",
            "IERC1155Upgradeable",
            "IERC721Upgradeable"
        ]
    ],
    "new_contract": "contract NFTXVaultFactoryUpgradeable is\n    PausableUpgradeable,\n    UpgradeableBeacon,\n    INFTXVaultFactory\n{\n    uint256 private NOT_USED1; // Removed, no longer needed.\n    address public override zapContract;\n    address public override feeDistributor;\n    address public override eligibilityManager;\n\n    mapping(uint256 => address) private NOT_USED2; // Removed, no longer needed.\n    mapping(address => address[]) _vaultsForAsset;\n    \n    address[] internal vaults;\n\n    // v1.0.1\n    mapping(address => bool) public override excludedFromFees;\n\n    // v1.0.2\n    struct VaultFees {\n        bool active;\n        uint64 mintFee;\n        uint64 randomRedeemFee;\n        uint64 targetRedeemFee;\n        uint64 randomSwapFee;\n        uint64 targetSwapFee;\n    }\n    mapping(uint256 => VaultFees) private _vaultFees;\n    uint64 public override factoryMintFee;\n    uint64 public override factoryRandomRedeemFee;\n    uint64 public override factoryTargetRedeemFee;\n    uint64 public override factoryRandomSwapFee;\n    uint64 public override factoryTargetSwapFee;\n\n    function __NFTXVaultFactory_init(address _vaultImpl, address _feeDistributor) public override initializer {\n        __Pausable_init();\n        // We use a beacon proxy so that every child contract follows the same implementation code.\n        __UpgradeableBeacon__init(_vaultImpl);\n        setFeeDistributor(_feeDistributor);\n        setFactoryFees(0.1 ether, 0.05 ether, 0.1 ether, 0.05 ether, 0.1 ether);\n    }\n\n    function assignFees() public {\n        require(factoryMintFee == 0 && factoryTargetRedeemFee == 0, \"Assigned\");\n        factoryMintFee = uint64(0.1 ether);\n        factoryRandomRedeemFee = uint64(0.05 ether);\n        factoryTargetRedeemFee = uint64(0.1 ether);\n        factoryRandomSwapFee = uint64(0.05 ether);\n        factoryTargetSwapFee = uint64(0.1 ether);\n\n        emit UpdateFactoryFees(0.1 ether, 0.05 ether, 0.1 ether, 0.05 ether, 0.1 ether);\n    }\n\n    function createVault(\n        string memory name,\n        string memory symbol,\n        address _assetAddress,\n        bool is1155,\n        bool allowAllItems\n    ) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(0);\n        require(feeDistributor != address(0), \"NFTX: Fee receiver unset\");\n        require(childImplementation() != address(0), \"NFTX: Vault implementation unset\");\n        address vaultAddr = deployVault(name, symbol, _assetAddress, is1155, allowAllItems);\n        uint256 _vaultId = vaults.length;\n        _vaultsForAsset[_assetAddress].push(vaultAddr);\n        vaults.push(vaultAddr);\n        INFTXFeeDistributor(feeDistributor).initializeVaultReceivers(_vaultId);\n        emit NewVault(_vaultId, vaultAddr, _assetAddress);\n        return _vaultId;\n    }\n\n    function setFactoryFees(\n        uint256 mintFee, \n        uint256 randomRedeemFee, \n        uint256 targetRedeemFee,\n        uint256 randomSwapFee, \n        uint256 targetSwapFee\n    ) public onlyOwner virtual override {\n        require(mintFee <= 1 ether, \"Cannot > 1 ether\");\n        require(randomRedeemFee <= 1 ether, \"Cannot > 1 ether\");\n        require(targetRedeemFee <= 1 ether, \"Cannot > 1 ether\");\n        require(randomSwapFee <= 1 ether, \"Cannot > 1 ether\");\n        require(targetSwapFee <= 1 ether, \"Cannot > 1 ether\");\n\n        factoryMintFee = uint64(mintFee);\n        factoryRandomRedeemFee = uint64(randomRedeemFee);\n        factoryTargetRedeemFee = uint64(targetRedeemFee);\n        factoryRandomSwapFee = uint64(randomSwapFee);\n        factoryTargetSwapFee = uint64(targetSwapFee);\n\n        emit UpdateFactoryFees(mintFee, randomRedeemFee, targetRedeemFee, randomSwapFee, targetSwapFee);\n    }\n\n    function setVaultFees(\n        uint256 vaultId, \n        uint256 mintFee, \n        uint256 randomRedeemFee, \n        uint256 targetRedeemFee,\n        uint256 randomSwapFee, \n        uint256 targetSwapFee\n    ) public virtual override {\n        if (msg.sender != owner()) {\n            address vaultAddr = vaults[vaultId];\n            require(msg.sender == vaultAddr, \"Not from vault\");\n        }\n        require(mintFee <= 1 ether, \"Cannot > 1 ether\");\n        require(randomRedeemFee <= 1 ether, \"Cannot > 1 ether\");\n        require(targetRedeemFee <= 1 ether, \"Cannot > 1 ether\");\n        require(randomSwapFee <= 1 ether, \"Cannot > 1 ether\");\n        require(targetSwapFee <= 1 ether, \"Cannot > 1 ether\");\n\n        _vaultFees[vaultId] = VaultFees(\n            true, \n            uint64(mintFee),\n            uint64(randomRedeemFee),\n            uint64(targetRedeemFee),\n            uint64(randomSwapFee), \n            uint64(targetSwapFee)\n        );\n        emit UpdateVaultFees(vaultId, mintFee, randomRedeemFee, targetRedeemFee, randomSwapFee, targetSwapFee);\n    }\n\n    function disableVaultFees(uint256 vaultId) public virtual override {\n        if (msg.sender != owner()) {\n            address vaultAddr = vaults[vaultId];\n            require(msg.sender == vaultAddr, \"Not vault\");\n        }\n        delete _vaultFees[vaultId];\n        emit DisableVaultFees(vaultId);\n    }\n\n    function setFeeDistributor(address _feeDistributor) public onlyOwner virtual override {\n        require(_feeDistributor != address(0));\n        emit NewFeeDistributor(feeDistributor, _feeDistributor);\n        feeDistributor = _feeDistributor;\n    }\n\n    function setZapContract(address _zapContract) public onlyOwner virtual override {\n        emit NewZapContract(zapContract, _zapContract);\n        zapContract = _zapContract;\n    }\n\n    function setFeeExclusion(address _excludedAddr, bool excluded) public onlyOwner virtual override {\n        emit FeeExclusion(_excludedAddr, excluded);\n        excludedFromFees[_excludedAddr] = excluded;\n    }\n\n    function setEligibilityManager(address _eligibilityManager) external onlyOwner virtual override {\n        emit NewEligibilityManager(eligibilityManager, _eligibilityManager);\n        eligibilityManager = _eligibilityManager;\n    }\n\n    function vaultFees(uint256 vaultId) external view virtual override returns (uint256, uint256, uint256, uint256, uint256) {\n        VaultFees memory fees = _vaultFees[vaultId];\n        if (fees.active) {\n            return (\n                uint256(fees.mintFee), \n                uint256(fees.randomRedeemFee), \n                uint256(fees.targetRedeemFee), \n                uint256(fees.randomSwapFee), \n                uint256(fees.targetSwapFee)\n            );\n        }\n        \n        return (uint256(factoryMintFee), uint256(factoryRandomRedeemFee), uint256(factoryTargetRedeemFee), uint256(factoryRandomSwapFee), uint256(factoryTargetSwapFee));\n    }\n\n    function isLocked(uint256 lockId) external view override virtual returns (bool) {\n        return isPaused[lockId];\n    }\n\n    function vaultsForAsset(address assetAddress) external view override virtual returns (address[] memory) {\n        return _vaultsForAsset[assetAddress];\n    }\n\n    function vault(uint256 vaultId) external view override virtual returns (address) {\n        return vaults[vaultId];\n    }\n\n    function allVaults() external view override virtual returns (address[] memory) {\n        return vaults;\n    }\n\n    function numVaults() external view override virtual returns (uint256) {\n        return vaults.length;\n    }\n    \n    function deployVault(\n        string memory name,\n        string memory symbol,\n        address _assetAddress,\n        bool is1155,\n        bool allowAllItems\n    ) internal returns (address) {\n        address newBeaconProxy = address(new BeaconProxy(address(this), \"\"));\n        NFTXVaultUpgradeable(newBeaconProxy).__NFTXVault_init(name, symbol, _assetAddress, is1155, allowAllItems);\n        // Manager for configuration.\n        NFTXVaultUpgradeable(newBeaconProxy).setManager(msg.sender);\n        // Owner for administrative functions.\n        NFTXVaultUpgradeable(newBeaconProxy).transferOwnership(owner());\n        return newBeaconProxy;\n    }\n}\ncontract XTokenUpgradeable is OwnableUpgradeable, ERC20Upgradeable {\n    IERC20Upgradeable public baseToken;\n    mapping(address => uint256) internal timelock;\n\n    event Timelocked(address user, uint256 until);\n\n    function __XToken_init(address _baseToken, string memory name, string memory symbol) public initializer {\n        __Ownable_init();\n        // string memory _name = INFTXInventoryStaking(msg.sender).nftxVaultFactory().vault();\n        __ERC20_init(name, symbol);\n        baseToken = IERC20Upgradeable(_baseToken);\n    }\n\n    // Needs to be called BEFORE new base tokens are deposited.\n    function mintXTokens(address account, uint256 _amount, uint256 timelockLength) external onlyOwner returns (uint256) {\n        // Gets the amount of Base Token locked in the contract\n        uint256 totalBaseToken = baseToken.balanceOf(address(this));\n        // Gets the amount of xTokens in existence\n        uint256 totalShares = totalSupply();\n        // If no xTokens exist, mint it 1:1 to the amount put in\n        if (totalShares == 0 || totalBaseToken == 0) {\n            _timelockMint(account, _amount, timelockLength);\n            return _amount;\n        }\n        // Calculate and mint the amount of xTokens the base tokens are worth. The ratio will change overtime, as xTokens are burned/minted and base tokens deposited + gained from fees / withdrawn.\n        else {\n            uint256 what = (_amount * totalShares) / totalBaseToken;\n            _timelockMint(account, what, timelockLength);\n            return what;\n        }\n    }\n\n    function burnXTokens(address who, uint256 _share) external onlyOwner returns (uint256) {\n        // Gets the amount of xToken in existence\n        uint256 totalShares = totalSupply();\n        // Calculates the amount of base tokens the xToken is worth\n        uint256 what = (_share * baseToken.balanceOf(address(this))) / totalShares;\n        _burn(who, _share);\n        baseToken.transfer(who, what);\n        return what;\n    }\n\n    function timelockAccount(address account , uint256 timelockLength) public onlyOwner virtual {\n        uint256 timelockFinish = block.timestamp + timelockLength;\n        timelock[account] = timelockFinish;\n        emit Timelocked(account, timelockFinish);\n    }\n\n    function _burn(address who, uint256 amount) internal override {\n        require(block.timestamp > timelock[who], \"User locked\");\n        super._burn(who, amount);\n    }\n\n    function timelockUntil(address account) public view returns (uint256) {\n        return timelock[account];\n    }\n\n    function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {\n        uint256 timelockFinish = block.timestamp + timelockLength;\n        timelock[account] = timelockFinish;\n        emit Timelocked(account, timelockFinish);\n        _mint(account, amount);\n    }\n    \n    function _transfer(address from, address to, uint256 value) internal override {\n        require(block.timestamp > timelock[from], \"User locked\");\n        super._transfer(from, to, value);\n    }\n}contract NFTXEligibilityManager is OwnableUpgradeable {\n    struct EligibilityModule {\n        address implementation;\n        address targetAsset;\n        string name;\n    }\n    EligibilityModule[] public modules;\n\n    event ModuleAdded(\n        address implementation,\n        address targetAsset,\n        string name,\n        bool finalizedOnDeploy\n    );\n    event ModuleUpdated(\n        address implementation,\n        string name,\n        bool finalizedOnDeploy\n    );\n\n    function __NFTXEligibilityManager_init() public initializer {\n        __Ownable_init();\n    }\n\n    function addModule(address implementation) external onlyOwner {\n        require(implementation != address(0), \"Impl != address(0)\");\n        INFTXEligibility elig = INFTXEligibility(implementation);\n        string memory name = elig.name();\n        EligibilityModule memory module = EligibilityModule(\n            implementation,\n            elig.targetAsset(),\n            name\n        );\n        modules.push(module);\n        emit ModuleAdded(\n            implementation,\n            module.targetAsset,\n            name,\n            elig.finalized()\n        );\n    }\n\n    function updateModule(uint256 moduleIndex, address implementation)\n        external\n        onlyOwner\n    {\n        require(moduleIndex < modules.length, \"Out of bounds\");\n        require(implementation != address(0), \"Impl != address(0)\");\n        modules[moduleIndex].implementation = implementation;\n        INFTXEligibility elig = INFTXEligibility(implementation);\n        emit ModuleUpdated(implementation, elig.name(), elig.finalized());\n    }\n\n    function deployEligibility(uint256 moduleIndex, bytes calldata configData)\n        external\n        virtual\n        returns (address)\n    {\n        require(moduleIndex < modules.length, \"Out of bounds\");\n        address eligImpl = modules[moduleIndex].implementation;\n        address eligibilityClone = ClonesUpgradeable.clone(eligImpl);\n        INFTXEligibility(eligibilityClone).__NFTXEligibility_init_bytes(\n            configData\n        );\n        return eligibilityClone;\n    }\n\n    function allModules() external view returns (EligibilityModule[] memory) {\n        return modules;\n    }\n\n    function allModuleNames() external view returns (string[] memory) {\n        EligibilityModule[] memory modulesCopy = modules;\n        string[] memory names = new string[](modulesCopy.length);\n        for (uint256 i = 0; i < modulesCopy.length; i++) {\n            names[i] = modulesCopy[i].name;\n        }\n        return names;\n    }\n}\ncontract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 constant BASE = 10**18;\n\n  event Buy(uint256 count, uint256 ethSpent, address to);\n  event Sell(uint256 count, uint256 ethReceived, address to);\n  event Swap(uint256 count, uint256 ethSpent, address to);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function mintAndSell721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function mintAndSell721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\n    emit Sell(ids.length, amounts[1], to);\n  }\n\n  function buyAndSwap721(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap721WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndSwap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    WETH.deposit{value: msg.value}();\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndSwap1155WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory amounts, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    uint256 count;\n    for (uint256 i = 0; i < idsIn.length; i++) {\n        uint256 amount = amounts[i];\n        require(amount > 0, \"Transferring < 1\");\n        count += amount;\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (count - specificIds.length)\n    );\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n    emit Swap(count, swapAmounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function buyAndRedeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    address[] calldata path,\n    address to\n  ) public payable nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    WETH.deposit{value: msg.value}();\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.withdraw(remaining);\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function buyAndRedeemWETH(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(amount != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n        vault.randomRedeemFee() * (amount - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);\n    _redeem(vaultId, amount, specificIds, to);\n\n    emit Buy(amount, amounts[0], to);\n\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n\n  function mintAndSell1155(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function mintAndSell1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minWethOut, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(ids.length != 0);\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n    uint256 count;\n    for (uint256 i = 0; i < ids.length; i++) {\n        count += amounts[i];\n    }\n    emit Sell(count, amounts[1], to);\n  }\n\n  function _mint721(\n    uint256 vaultId, \n    uint256[] memory ids\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); \n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _swap721(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < idsIn.length; i++) {\n      transferFromERC721(assetAddress, idsIn[i], vault);\n      approveERC721(assetAddress, vault, idsIn[i]);\n    }\n    uint256[] memory emptyIds;\n    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _swap1155(\n    uint256 vaultId, \n    uint256[] memory idsIn,\n    uint256[] memory amounts,\n    uint256[] memory idsOut,\n    address to\n  ) internal returns (address) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);\n    \n    return (vault);\n  }\n\n  function _redeem(\n    uint256 vaultId, \n    uint256 amount,\n    uint256[] memory specificIds,\n    address to\n  ) internal {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n    INFTXVault(vault).redeemTo(amount, specificIds, to);\n  }\n\n  function _mint1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts\n  ) internal returns (address, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return (vault, balance);\n  }\n\n  function _buyVaultToken(\n    address vault, \n    uint256 minTokenOut, \n    uint256 maxWethIn, \n    address[] calldata path\n  ) internal returns (uint256[] memory) {\n    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n      minTokenOut,\n      maxWethIn,\n      path, \n      address(this),\n      block.timestamp\n    );\n\n    return amounts;\n  }\n  function _sellVaultTokenWETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function _sellVaultTokenETH(\n    address vault, \n    uint256 minWethOut, \n    uint256 maxTokenIn, \n    address[] calldata path,\n    address to\n  ) internal returns (uint256[] memory) {\n    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);\n    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(\n      maxTokenIn,\n      minWethOut,\n      path, \n      to,\n      block.timestamp\n    );\n\n    return amounts;\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n}\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\nabstract contract ERC1155HolderUpgradeable is ERC1155ReceiverUpgradeable {\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\ncontract NFTXInventoryStaking is PausableUpgradeable, UpgradeableBeacon, INFTXInventoryStaking {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant BASE = 10**18;\n    // Small locktime to prevent flash deposits.\n    uint256 public constant DEFAULT_LOCKTIME = 2;\n\n    INFTXVaultFactory public override nftxVaultFactory;\n    mapping(uint256 => address) internal UNUSED;\n\n    event XTokenCreated(uint256 vaultId, address baseToken, address xToken);\n    event Deposit(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, uint256 timelockUntil, address sender);\n    event Withdraw(uint256 vaultId, uint256 baseTokenAmount, uint256 xTokenAmount, address sender);\n\n    function __NFTXInventoryStaking_init(address _nftxVaultFactory) external virtual override initializer {\n        __Ownable_init();\n        nftxVaultFactory = INFTXVaultFactory(_nftxVaultFactory);\n        address xTokenImpl = address(new XTokenUpgradeable());\n        __UpgradeableBeacon__init(xTokenImpl);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || msg.sender == nftxVaultFactory.feeDistributor(), \"LPStaking: Not authorized\");\n        _;\n    }\n    \n    function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n        require(newFactory != address(0));\n        nftxVaultFactory = INFTXVaultFactory(newFactory);\n    }\n\n    function deployXTokenForVault(uint256 vaultId) public virtual override {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n\n        if (isContract(deployedXToken)) {\n            return;\n        }\n\n        address xToken = _deployXToken(baseToken);\n        emit XTokenCreated(vaultId, baseToken, xToken);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external virtual override onlyAdmin returns (bool) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address deployedXToken = xTokenAddr(address(baseToken));\n        \n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!isContract(deployedXToken) || XTokenUpgradeable(deployedXToken).totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the fee distributor only needs to approve this contract.\n        IERC20Upgradeable(baseToken).safeTransferFrom(msg.sender, deployedXToken, amount);\n        return true;\n    }\n\n    // Enter staking. Staking, get minted shares and\n    // locks base tokens and mints xTokens.\n    function deposit(uint256 vaultId, uint256 _amount) public virtual override {\n        onlyOwnerIfPaused(10);\n\n        (IERC20Upgradeable baseToken, XTokenUpgradeable xToken, uint256 xTokensMinted) = _timelockMintFor(vaultId, msg.sender, _amount, DEFAULT_LOCKTIME);\n        // Lock the base token in the xtoken contract\n        baseToken.safeTransferFrom(msg.sender, address(xToken), _amount);\n        emit Deposit(vaultId, _amount, xTokensMinted, DEFAULT_LOCKTIME, msg.sender);\n    }\n\n    function timelockMintFor(uint256 vaultId, uint256 amount, address to, uint256 timelockLength) external virtual override returns (uint256) {\n        onlyOwnerIfPaused(10);\n        require(nftxVaultFactory.excludedFromFees(msg.sender), \"Not a zap\");\n\n        (, , uint256 xTokensMinted) = _timelockMintFor(vaultId, to, amount, timelockLength);\n        emit Deposit(vaultId, amount, xTokensMinted, timelockLength, to);\n        return xTokensMinted;\n    }\n\n    // Leave the bar. Claim back your tokens.\n    // Unlocks the staked + gained tokens and burns xTokens.\n    function withdraw(uint256 vaultId, uint256 _share) public virtual override {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n\n        uint256 baseTokensRedeemed = xToken.burnXTokens(msg.sender, _share);\n        emit Withdraw(vaultId, baseTokensRedeemed, _share, msg.sender);\n    }\n\n   function xTokenShareValue(uint256 vaultId) external view virtual override returns (uint256) {\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable(xTokenAddr(address(baseToken)));\n        require(address(xToken) != address(0), \"XToken not deployed\");\n\n        uint256 multiplier = 10 ** 18;\n        return xToken.totalSupply() > 0 \n            ? multiplier * baseToken.balanceOf(address(xToken)) / xToken.totalSupply() \n            : multiplier;\n    }\n\n    function timelockUntil(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.timelockUntil(who);\n    }\n\n    function balanceOf(uint256 vaultId, address who) external view returns (uint256) {\n        XTokenUpgradeable xToken = XTokenUpgradeable(vaultXToken(vaultId));\n        return xToken.balanceOf(who);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function xTokenAddr(address baseToken) public view virtual override returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(baseToken));\n        address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode));\n        return tokenAddr;\n    }\n    \n    function vaultXToken(uint256 vaultId) public view virtual override returns (address) {\n        address baseToken = nftxVaultFactory.vault(vaultId);\n        address xToken = xTokenAddr(baseToken);\n        require(isContract(xToken), \"XToken not deployed\");\n        return xToken;\n    } \n\n    function _timelockMintFor(uint256 vaultId, address account, uint256 _amount, uint256 timelockLength) internal returns (IERC20Upgradeable, XTokenUpgradeable, uint256) {\n        deployXTokenForVault(vaultId);\n        IERC20Upgradeable baseToken = IERC20Upgradeable(nftxVaultFactory.vault(vaultId));\n        XTokenUpgradeable xToken = XTokenUpgradeable((xTokenAddr(address(baseToken))));\n\n        uint256 xTokensMinted = xToken.mintXTokens(account, _amount, timelockLength);\n        return (baseToken, xToken, xTokensMinted);\n    }\n\n    function _deployXToken(address vaultToken) internal returns (address) {\n        string memory symbol = IERC20Metadata(vaultToken).symbol();\n        symbol = string(abi.encodePacked(\"x\", symbol));\n        bytes32 salt = keccak256(abi.encodePacked(vaultToken));\n        address deployedXToken = Create2.deploy(0, salt, type(Create2BeaconProxy).creationCode);\n        XTokenUpgradeable(deployedXToken).__XToken_init(vaultToken, symbol, symbol);\n        return deployedXToken;\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n  IWETH public immutable WETH; \n  INFTXLPStaking public immutable lpStaking;\n  INFTXInventoryStaking public immutable inventoryStaking;\n  INFTXVaultFactory public immutable nftxFactory;\n  IUniswapV2Router01 public immutable sushiRouter;\n\n  uint256 public lpLockTime = 48 hours; \n  uint256 public inventoryLockTime = 7 days; \n  uint256 constant BASE = 10**18;\n\n  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);\n\n  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\n    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\n    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\n  }\n\n  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {\n    require(newLPLockTime <= 7 days, \"Lock too long\");\n    lpLockTime = newLPLockTime;\n  } \n\n  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {\n    require(newInventoryLockTime <= 14 days, \"Lock too long\");\n    inventoryLockTime = newInventoryLockTime;\n  }\n\n  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {\n    uint256 count = tokenIds.length;\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);\n    address xToken = inventoryStaking.vaultXToken(vaultId);\n    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);\n    uint256[] memory amounts = new uint256[](0);\n    address assetAddress = vault.assetAddress();\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      transferFromERC721(assetAddress, tokenIds[i], address(vault));\n      approveERC721(assetAddress, address(vault), tokenIds[i]);\n    }\n    vault.mintTo(tokenIds, amounts, address(xToken));\n    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);\n    require(newBal == oldBal + count*BASE, \"Incorrect vtokens minted\");\n  }\n\n  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {\n    uint256 count;\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      count += amounts[i];\n    }\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);\n    address xToken = inventoryStaking.vaultXToken(vaultId);\n    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));\n    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());\n    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, \"\");\n    nft.setApprovalForAll(address(vault), true);\n    vault.mintTo(tokenIds, amounts, address(xToken));\n    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));\n    require(newBal == oldBal + count*BASE, \"Incorrect vtokens minted\");\n  }\n\n  function addLiquidity721ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn\n  ) public payable returns (uint256) {\n    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);\n  }\n\n  function addLiquidity721ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    address to\n  ) public payable nonReentrant returns (uint256) {\n    WETH.deposit{value: msg.value}();\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);\n\n    // Return extras.\n    if (amountEth < msg.value) {\n      WETH.withdraw(msg.value-amountEth);\n      payable(to).call{value: msg.value-amountEth};\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity1155ETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn\n  ) public payable returns (uint256) {\n    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);\n  }\n\n  function addLiquidity1155ETHTo(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256[] memory amounts,\n    uint256 minEthIn,\n    address to\n  ) public payable nonReentrant returns (uint256) {\n    WETH.deposit{value: msg.value}();\n    // Finish this.\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);\n\n    // Return extras.\n    if (amountEth < msg.value) {\n      WETH.withdraw(msg.value-amountEth);\n      payable(to).call{value: msg.value-amountEth};\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity721(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn\n  ) public returns (uint256) {\n    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);\n  }\n\n  function addLiquidity721To(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);\n\n    // Return extras.\n    if (amountEth < wethIn) {\n      WETH.transfer(to, wethIn-amountEth);\n    }\n\n    return liquidity;\n  }\n\n  function addLiquidity1155(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn\n  ) public returns (uint256) {\n    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);\n  }\n\n  function addLiquidity1155To(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) public nonReentrant returns (uint256) {\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);\n    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);\n\n    // Return extras.\n    if (amountEth < wethIn) {\n      WETH.transfer(to, wethIn-amountEth);\n    }\n\n    return liquidity;\n  }\n\n  function _addLiquidity721WETH(\n    uint256 vaultId, \n    uint256[] memory ids, \n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    for (uint256 i = 0; i < ids.length; i++) {\n      transferFromERC721(assetAddress, ids[i], vault);\n      approveERC721(assetAddress, vault, ids[i]);\n    }\n    uint256[] memory emptyIds;\n    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n    uint256 balance = (count * BASE); // We should not be experiencing fees.\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);\n  }\n\n  function _addLiquidity1155WETH(\n    uint256 vaultId, \n    uint256[] memory ids,\n    uint256[] memory amounts,\n    uint256 minWethIn,\n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    address vault = nftxFactory.vault(vaultId);\n    require(vault != address(0), \"NFTXZap: Vault does not exist\");\n\n    // Transfer tokens to zap and mint to NFTX.\n    address assetAddress = INFTXVault(vault).assetAddress();\n    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n    uint256 count = INFTXVault(vault).mint(ids, amounts);\n    uint256 balance = (count * BASE); // We should not be experiencing fees.\n    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n    \n    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);\n  }\n\n  function _addLiquidityAndLock(\n    uint256 vaultId, \n    address vault, \n    uint256 minTokenIn, \n    uint256 minWethIn, \n    uint256 wethIn,\n    address to\n  ) internal returns (uint256, uint256, uint256) {\n    // Provide liquidity.\n    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);\n    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(\n      address(vault), \n      sushiRouter.WETH(),\n      minTokenIn, \n      wethIn, \n      minTokenIn,\n      minWethIn,\n      address(this), \n      block.timestamp\n    );\n\n    // Stake in LP rewards contract \n    address lpToken = pairFor(vault, address(WETH));\n    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);\n    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);\n    \n    if (amountToken < minTokenIn) {\n      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);\n    }\n\n    uint256 lockEndTime = block.timestamp + lpLockTime;\n    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);\n    return (amountToken, amountEth, liquidity);\n  }\n\n  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        // Fix here for frontrun attack. Added in v1.0.2.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n        (address owner) = abi.decode(result, (address));\n        require(checkSuccess && owner == msg.sender, \"Not the owner\");\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    } else {\n        // Default.\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n    bytes memory data;\n    if (assetAddr == kitties) {\n        // Cryptokitties.\n        data = abi.encodeWithSignature(\"approve(address,uint256)\", to, tokenId);\n    } else if (assetAddr == punks) {\n        // CryptoPunks.\n        data = abi.encodeWithSignature(\"offerPunkForSaleToAddress(uint256,uint256,address)\", tokenId, 0, to);\n    } else {\n      // No longer needed to approve with pushing.\n      return;\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n      hex'ff',\n      sushiRouter.factory(),\n      keccak256(abi.encodePacked(token0, token1)),\n      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n    )))));\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  receive() external payable {\n\n  }\n\n  function rescue(address token) external onlyOwner {\n    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));\n  }\n}\nabstract contract ERC1155SafeHolderUpgradeable is ERC1155ReceiverUpgradeable {\n    function onERC1155Received(address operator, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address operator, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function _setMetadata(string memory name_, string memory symbol_) internal {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[45] private __gap;\n}\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\ncontract TimelockRewardDistributionTokenImpl is OwnableUpgradeable, ERC20Upgradeable {\n  using SafeMathUpgradeable for uint256;\n  using SafeMathInt for int256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  \n  IERC20Upgradeable public target;\n\n  // With `magnitude`, we can properly distribute dividends even if the amount of received target is small.\n  // For more discussion about choosing the value of `magnitude`,\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n  uint256 constant internal magnitude = 2**128;\n\n  uint256 internal magnifiedRewardPerShare;\n\n  // About dividendCorrection:\n  // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\n  // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\n  //   `dividendOf(_user)` should not be changed,\n  //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\n  // To keep the `dividendOf(_user)` unchanged, we add a correction term:\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\n  //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\n  //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\n  // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\n  mapping(address => int256) internal magnifiedRewardCorrections;\n  mapping(address => uint256) internal withdrawnRewards;\n\n  mapping(address => uint256) internal timelock;\n\n  event Timelocked(address user, uint256 amount, uint256 until);\n\n  function __TimelockRewardDistributionToken_init(IERC20Upgradeable _target, string memory _name, string memory _symbol) public initializer {\n    __Ownable_init();\n    __ERC20_init(_name, _symbol);\n    target = _target;\n  }\n\n  function transfer(address recipient, uint256 amount)\n      public\n      virtual\n      override\n      returns (bool)\n  {\n      _transfer(_msgSender(), recipient, amount);\n      return true;\n  }\n\n  /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Emits an {Approval} event indicating the updated allowance. This is not\n    * required by the EIP. See the note at the beginning of {ERC20}.\n    *\n    * Requirements:\n    *\n    * - `sender` and `recipient` cannot be the zero address.\n    * - `sender` must have a balance of at least `amount`.\n    * - the caller must have allowance for ``sender``'s tokens of at least\n    * `amount`.\n    */\n  function transferFrom(address sender, address recipient, uint256 amount)\n      public\n      virtual\n      override\n      returns (bool)\n  {\n      _transfer(sender, recipient, amount);\n      _approve(\n          sender,\n          _msgSender(),\n          allowance(sender, _msgSender()).sub(\n              amount,\n              \"ERC20: transfer amount exceeds allowance\"\n          )\n      );\n      return true;\n  }\n\n  function mint(address account, uint256 amount) public onlyOwner virtual {\n      _mint(account, amount);\n  }\n\n  function timelockMint(address account, uint256 amount, uint256 timelockLength) public onlyOwner virtual {\n    uint256 timelockFinish = block.timestamp + timelockLength;\n    timelock[account] = timelockFinish;\n    emit Timelocked(account, amount, timelockFinish);\n    _mint(account, amount);\n  }\n\n  function timelockUntil(address account) public view returns (uint256) {\n    return timelock[account];\n  }\n\n  /**\n    * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n    * allowance.\n    *\n    * See {ERC20-_burn} and {ERC20-allowance}.\n    *\n    * Requirements:\n    *\n    * - the caller must have allowance for ``accounts``'s tokens of at least\n    * `amount`.\n    */\n  function burnFrom(address account, uint256 amount) public virtual onlyOwner {\n      _burn(account, amount);\n  }\n\n  /// @notice Distributes target to token holders as dividends.\n  /// @dev It reverts if the total supply of tokens is 0.\n  /// It emits the `RewardsDistributed` event if the amount of received target is greater than 0.\n  /// About undistributed target tokens:\n  ///   In each distribution, there is a small amount of target not distributed,\n  ///     the magnified amount of which is\n  ///     `(amount * magnitude) % totalSupply()`.\n  ///   With a well-chosen `magnitude`, the amount of undistributed target\n  ///     (de-magnified) in a distribution can be less than 1 wei.\n  ///   We can actually keep track of the undistributed target in a distribution\n  ///     and try to distribute it in the next distribution,\n  ///     but keeping track of such data on-chain costs much more than\n  ///     the saved target, so we don't do that.\n  function distributeRewards(uint amount) external virtual onlyOwner {\n    require(totalSupply() > 0, \"RewardDist: 0 supply\");\n    require(amount > 0, \"RewardDist: 0 amount\");\n\n    // Because we receive the tokens from the staking contract, we assume the tokens have been received.\n    magnifiedRewardPerShare = magnifiedRewardPerShare.add(\n      (amount).mul(magnitude) / totalSupply()\n    );\n\n    emit RewardsDistributed(msg.sender, amount);\n  }\n\n  /// @notice Withdraws the target distributed to the sender.\n  /// @dev It emits a `RewardWithdrawn` event if the amount of withdrawn target is greater than 0.\n  function withdrawReward(address user) external onlyOwner {\n    uint256 _withdrawableReward = withdrawableRewardOf(user);\n    if (_withdrawableReward > 0) {\n      withdrawnRewards[user] = withdrawnRewards[user].add(_withdrawableReward);\n      target.safeTransfer(user, _withdrawableReward);\n      emit RewardWithdrawn(user, _withdrawableReward);\n    }\n  }\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function dividendOf(address _owner) public view returns(uint256) {\n    return withdrawableRewardOf(_owner);\n  }\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function withdrawableRewardOf(address _owner) internal view returns(uint256) {\n    return accumulativeRewardOf(_owner).sub(withdrawnRewards[_owner]);\n  }\n\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\n  function withdrawnRewardOf(address _owner) public view returns(uint256) {\n    return withdrawnRewards[_owner];\n  }\n\n\n  /// @notice View the amount of dividend in wei that an address has earned in total.\n  /// @dev accumulativeRewardOf(_owner) = withdrawableRewardOf(_owner) + withdrawnRewardOf(_owner)\n  /// = (magnifiedRewardPerShare * balanceOf(_owner) + magnifiedRewardCorrections[_owner]) / magnitude\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\n  function accumulativeRewardOf(address _owner) public view returns(uint256) {\n    return magnifiedRewardPerShare.mul(balanceOf(_owner)).toInt256()\n      .add(magnifiedRewardCorrections[_owner]).toUint256Safe() / magnitude;\n  }\n\n  /// @dev Internal function that transfer tokens from one address to another.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param from The address to transfer from.\n  /// @param to The address to transfer to.\n  /// @param value The amount to be transferred.\n  function _transfer(address from, address to, uint256 value) internal override {\n    require(block.timestamp > timelock[from], \"User locked\");\n    super._transfer(from, to, value);\n\n    int256 _magCorrection = magnifiedRewardPerShare.mul(value).toInt256();\n    magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from].add(_magCorrection);\n    magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to].sub(_magCorrection);\n  }\n\n  /// @dev Internal function that mints tokens to an account.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param account The account that will receive the created tokens.\n  /// @param value The amount that will be created.\n  function _mint(address account, uint256 value) internal override {\n    super._mint(account, value);\n\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account]\n      .sub( (magnifiedRewardPerShare.mul(value)).toInt256() );\n  }\n\n  /// @dev Internal function that burns an amount of the token of a given account.\n  /// Update magnifiedRewardCorrections to keep dividends unchanged.\n  /// @param account The account whose tokens will be burnt.\n  /// @param value The amount that will be burnt.\n  function _burn(address account, uint256 value) internal override {\n    require(block.timestamp > timelock[account], \"User locked\");\n    super._burn(account, value);\n\n    magnifiedRewardCorrections[account] = magnifiedRewardCorrections[account]\n      .add( (magnifiedRewardPerShare.mul(value)).toInt256() );\n  }\n\n  /// @dev This event MUST emit when target is distributed to token holders.\n  /// @param from The address which sends target to this contract.\n  /// @param weiAmount The amount of distributed target in wei.\n  event RewardsDistributed(\n    address indexed from,\n    uint256 weiAmount\n  );\n\n  /// @dev This event MUST emit when an address withdraws their dividend.\n  /// @param to The address which withdraws target from this contract.\n  /// @param weiAmount The amount of withdrawn target in wei.\n  event RewardWithdrawn(\n    address indexed to,\n    uint256 weiAmount\n  );\n}contract ERC721SafeHolderUpgradeable is IERC721ReceiverUpgradeable {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\ncontract ERC721HolderUpgradeable is IERC721ReceiverUpgradeable {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\nabstract contract ERC20FlashMintUpgradeable is Initializable, ERC20Upgradeable, IERC3156FlashLenderUpgradeable {\n    function __ERC20FlashMint_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20FlashMint_init_unchained();\n    }\n\n    function __ERC20FlashMint_init_unchained() internal initializer {\n    }\n    bytes32 constant private RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     * @param token The address of the token that is requested.\n     * @return The amont of token that can be loaned.\n     */\n    function maxFlashLoan(address token) public view override returns (uint256) {\n        return token == address(this) ? type(uint256).max - totalSupply() : 0;\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. By default this\n     * implementation has 0 fees. This function can be overloaded to make\n     * the flash loan mechanism deflationary.\n     * @param token The token to be flash loaned.\n     * @param amount The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        // silence warning about unused variable without the addition of bytecode.\n        amount;\n        return 0;\n    }\n\n    /**\n     * @dev Performs a flash loan. New tokens are minted and sent to the\n     * `receiver`, who is required to implement the {IERC3156FlashBorrower}\n     * interface. By the end of the flash loan, the receiver is expected to own\n     * amount + fee tokens and have them approved back to the token contract itself so\n     * they can be burned.\n     * @param receiver The receiver of the flash loan. Should implement the\n     * {IERC3156FlashBorrower.onFlashLoan} interface.\n     * @param token The token to be flash loaned. Only `address(this)` is\n     * supported.\n     * @param amount The amount of tokens to be loaned.\n     * @param data An arbitrary datafield that is passed to the receiver.\n     * @return `true` is the flash loan was successfull.\n     */\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        bytes memory data\n    )\n        public virtual override returns (bool)\n    {\n        uint256 fee = flashFee(token, amount);\n        _mint(address(receiver), amount);\n        require(receiver.onFlashLoan(msg.sender, token, amount, fee, data) == RETURN_VALUE, \"ERC20FlashMint: invalid return value\");\n        uint256 currentAllowance = allowance(address(receiver), address(this));\n        require(currentAllowance >= amount + fee, \"ERC20FlashMint: allowance does not allow refund\");\n        _approve(address(receiver), address(this), currentAllowance - amount - fee);\n        _burn(address(receiver), amount + fee);\n        return true;\n    }\n    uint256[50] private __gap;\n}contract NFTXVaultUpgradeable is\n    OwnableUpgradeable,\n    ERC20FlashMintUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC721SafeHolderUpgradeable,\n    ERC1155SafeHolderUpgradeable,\n    INFTXVault\n{\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    uint256 constant base = 10**18;\n\n    uint256 public override vaultId;\n    address public override manager;\n    address public override assetAddress;\n    INFTXVaultFactory public override vaultFactory;\n    INFTXEligibility public override eligibilityStorage;\n\n    uint256 randNonce;\n    uint256 private UNUSED_FEE1;\n    uint256 private UNUSED_FEE2;\n    uint256 private UNUSED_FEE3;\n\n    bool public override is1155;\n    bool public override allowAllItems;\n    bool public override enableMint;\n    bool public override enableRandomRedeem;\n    bool public override enableTargetRedeem;\n\n    EnumerableSetUpgradeable.UintSet holdings;\n    mapping(uint256 => uint256) quantity1155;\n\n    bool public override enableRandomSwap;\n    bool public override enableTargetSwap;\n\n    function __NFTXVault_init(\n        string memory _name,\n        string memory _symbol,\n        address _assetAddress,\n        bool _is1155,\n        bool _allowAllItems\n    ) public override virtual initializer {\n        __Ownable_init();\n        __ERC20_init(_name, _symbol);\n        require(_assetAddress != address(0), \"Asset != address(0)\");\n        assetAddress = _assetAddress;\n        vaultFactory = INFTXVaultFactory(msg.sender);\n        vaultId = vaultFactory.numVaults();\n        is1155 = _is1155;\n        allowAllItems = _allowAllItems;\n        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);\n        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);\n    }\n\n    function finalizeVault() external override virtual {\n        setManager(address(0));\n    }\n\n    // Added in v1.0.3.\n    function setVaultMetadata(\n        string memory name_, \n        string memory symbol_\n    ) public override virtual {\n        onlyPrivileged();\n        _setMetadata(name_, symbol_);\n    }\n\n    function setVaultFeatures(\n        bool _enableMint,\n        bool _enableRandomRedeem,\n        bool _enableTargetRedeem,\n        bool _enableRandomSwap,\n        bool _enableTargetSwap\n    ) public override virtual {\n        onlyPrivileged();\n        enableMint = _enableMint;\n        enableRandomRedeem = _enableRandomRedeem;\n        enableTargetRedeem = _enableTargetRedeem;\n        enableRandomSwap = _enableRandomSwap;\n        enableTargetSwap = _enableTargetSwap;\n\n        emit EnableMintUpdated(_enableMint);\n        emit EnableRandomRedeemUpdated(_enableRandomRedeem);\n        emit EnableTargetRedeemUpdated(_enableTargetRedeem);\n        emit EnableRandomSwapUpdated(_enableRandomSwap);\n        emit EnableTargetSwapUpdated(_enableTargetSwap);\n    }\n\n    function assignDefaultFeatures() external {\n        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, \"Not dev\");\n        enableRandomSwap = enableRandomRedeem;\n        enableTargetSwap = enableTargetRedeem;\n        emit EnableRandomSwapUpdated(enableRandomSwap);\n        emit EnableTargetSwapUpdated(enableTargetSwap);\n    }\n\n    function setFees(\n        uint256 _mintFee,\n        uint256 _randomRedeemFee,\n        uint256 _targetRedeemFee,\n        uint256 _randomSwapFee,\n        uint256 _targetSwapFee\n    ) public override virtual {\n        onlyPrivileged();\n        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);\n    }\n\n    function disableVaultFees() public override virtual {\n        onlyPrivileged();\n        vaultFactory.disableVaultFees(vaultId);\n    }\n\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow \n    // a similar interface.\n    function deployEligibilityStorage(\n        uint256 moduleIndex,\n        bytes calldata initData\n    ) external override virtual returns (address) {\n        onlyPrivileged();\n        require(\n            address(eligibilityStorage) == address(0),\n            \"NFTXVault: eligibility already set\"\n        );\n        INFTXEligibilityManager eligManager = INFTXEligibilityManager(\n            vaultFactory.eligibilityManager()\n        );\n        address _eligibility = eligManager.deployEligibility(\n            moduleIndex,\n            initData\n        );\n        eligibilityStorage = INFTXEligibility(_eligibility);\n        // Toggle this to let the contract know to check eligibility now.\n        allowAllItems = false;\n        emit EligibilityDeployed(moduleIndex, _eligibility);\n        return _eligibility;\n    }\n\n    // // This function allows for the manager to set their own arbitrary eligibility contract.\n    // // Once eligiblity is set, it cannot be unset or changed.\n    // Disabled for launch.\n    // function setEligibilityStorage(address _newEligibility) public virtual {\n    //     onlyPrivileged();\n    //     require(\n    //         address(eligibilityStorage) == address(0),\n    //         \"NFTXVault: eligibility already set\"\n    //     );\n    //     eligibilityStorage = INFTXEligibility(_newEligibility);\n    //     // Toggle this to let the contract know to check eligibility now.\n    //     allowAllItems = false;\n    //     emit CustomEligibilityDeployed(address(_newEligibility));\n    // }\n\n    // The manager has control over options like fees and features\n    function setManager(address _manager) public override virtual {\n        onlyPrivileged();\n        manager = _manager;\n        emit ManagerSet(_manager);\n    }\n\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\n    ) external override virtual returns (uint256) {\n        return mintTo(tokenIds, amounts, msg.sender);\n    }\n\n    function mintTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        address to\n    ) public override virtual nonReentrant returns (uint256) {\n        onlyOwnerIfPaused(1);\n        require(enableMint, \"Minting not enabled\");\n        // Take the NFTs.\n        uint256 count = receiveNFTs(tokenIds, amounts);\n\n        // Mint to the user.\n        _mint(to, base * count);\n        uint256 totalFee = mintFee() * count;\n        _chargeAndDistributeFees(to, totalFee);\n\n        emit Minted(tokenIds, amounts, to);\n        return count;\n    }\n\n    function redeem(uint256 amount, uint256[] calldata specificIds)\n        external\n        override\n        virtual\n        returns (uint256[] memory)\n    {\n        return redeemTo(amount, specificIds, msg.sender);\n    }\n\n    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)\n        public\n        override\n        virtual\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        onlyOwnerIfPaused(2);\n        require(\n            amount == specificIds.length || enableRandomRedeem,\n            \"NFTXVault: Random redeem not enabled\"\n        );\n        require(\n            specificIds.length == 0 || enableTargetRedeem,\n            \"NFTXVault: Target redeem not enabled\"\n        );\n        \n        // We burn all from sender and mint to fee receiver to reduce costs.\n        _burn(msg.sender, base * amount);\n\n        // Pay the tokens + toll.\n        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (\n            randomRedeemFee() * (amount - specificIds.length)\n        );\n        _chargeAndDistributeFees(msg.sender, totalFee);\n\n        // Withdraw from vault.\n        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);\n        emit Redeemed(redeemedIds, specificIds, to);\n        return redeemedIds;\n    }\n    \n    function swap(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n        uint256[] calldata specificIds\n    ) external override virtual returns (uint256[] memory) {\n        return swapTo(tokenIds, amounts, specificIds, msg.sender);\n    }\n\n    function swapTo(\n        uint256[] memory tokenIds,\n        uint256[] memory amounts, /* ignored for ERC721 vaults */\n        uint256[] memory specificIds,\n        address to\n    ) public override virtual nonReentrant returns (uint256[] memory) {\n        onlyOwnerIfPaused(3);\n        uint256 count;\n        if (is1155) {\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 amount = amounts[i];\n                require(amount > 0, \"NFTXVault: transferring < 1\");\n                count += amount;\n            }\n        } else {\n            count = tokenIds.length;\n        }\n\n        require(\n            count == specificIds.length || enableRandomSwap,\n            \"NFTXVault: Random swap disabled\"\n        );\n        require(\n            specificIds.length == 0 || enableTargetSwap,\n            \"NFTXVault: Target swap disabled\"\n        );\n\n        uint256 totalFee = (targetSwapFee() * specificIds.length) + (\n            randomSwapFee() * (count - specificIds.length)\n        );\n        _chargeAndDistributeFees(msg.sender, totalFee);\n        \n        // Give the NFTs first, so the user wont get the same thing back, just to be nice. \n        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);\n\n        receiveNFTs(tokenIds, amounts);\n\n        emit Swapped(tokenIds, amounts, specificIds, ids, to);\n        return ids;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrowerUpgradeable receiver,\n        address token,\n        uint256 amount,\n        bytes memory data\n    ) public override virtual returns (bool) {\n        onlyOwnerIfPaused(4);\n        return super.flashLoan(receiver, token, amount, data);\n    }\n\n    function mintFee() public view override virtual returns (uint256) {\n        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);\n        return _mintFee;\n    }\n\n    function randomRedeemFee() public view override virtual returns (uint256) {\n        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);\n        return _randomRedeemFee;\n    }\n\n    function targetRedeemFee() public view override virtual returns (uint256) {\n        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);\n        return _targetRedeemFee;\n    }\n\n    function randomSwapFee() public view override virtual returns (uint256) {\n        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);\n        return _randomSwapFee;\n    }\n\n    function targetSwapFee() public view override virtual returns (uint256) {\n        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);\n        return _targetSwapFee;\n    }\n\n    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {\n        return vaultFactory.vaultFees(vaultId);\n    }\n\n    function allValidNFTs(uint256[] memory tokenIds)\n        public\n        view\n        override\n        virtual\n        returns (bool)\n    {\n        if (allowAllItems) {\n            return true;\n        }\n\n        INFTXEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return false;\n        }\n        return _eligibilityStorage.checkAllEligible(tokenIds);\n    }\n\n    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {\n        return holdings.at(holdingsIndex);\n    }\n\n    // Added in v1.0.3.\n    function allHoldings() external view override virtual returns (uint256[] memory) {\n        uint256 len = holdings.length();\n        uint256[] memory idArray = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            idArray[i] = holdings.at(i);\n        }\n        return idArray;\n    }\n\n    // Added in v1.0.3.\n    function totalHoldings() external view override virtual returns (uint256) {\n        return holdings.length();\n    }\n\n    // Added in v1.0.3.\n    function version() external pure returns (string memory) {\n        return \"v1.0.5\";\n    } \n\n    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.\n    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {\n        INFTXEligibility _eligibilityStorage = eligibilityStorage;\n        if (address(_eligibilityStorage) == address(0)) {\n            return;\n        }\n        _eligibilityStorage.afterRedeemHook(tokenIds);\n    }\n\n    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)\n        internal\n        virtual\n        returns (uint256)\n    {\n        require(allValidNFTs(tokenIds), \"NFTXVault: not eligible\");\n        if (is1155) {\n            // This is technically a check, so placing it before the effect.\n            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(\n                msg.sender,\n                address(this),\n                tokenIds,\n                amounts,\n                \"\"\n            );\n\n            uint256 count;\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                uint256 amount = amounts[i];\n                require(amount > 0, \"NFTXVault: transferring < 1\");\n                if (quantity1155[tokenId] == 0) {\n                    holdings.add(tokenId);\n                }\n                quantity1155[tokenId] += amount;\n                count += amount;\n            }\n            return count;\n        } else {\n            address _assetAddress = assetAddress;\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                // We may already own the NFT here so we check in order:\n                // Does the vault own it?\n                //   - If so, check if its in holdings list\n                //      - If so, we reject. This means the NFT has already been claimed for.\n                //      - If not, it means we have not yet accounted for this NFT, so we continue.\n                //   -If not, we \"pull\" it from the msg.sender and add to holdings.\n                transferFromERC721(_assetAddress, tokenId);\n                holdings.add(tokenId);\n            }\n            return tokenIds.length;\n        }\n    }\n\n    function withdrawNFTsTo(\n        uint256 amount,\n        uint256[] memory specificIds,\n        address to\n    ) internal virtual returns (uint256[] memory) {\n        bool _is1155 = is1155;\n        address _assetAddress = assetAddress;\n        uint256[] memory redeemedIds = new uint256[](amount);\n        for (uint256 i = 0; i < amount; i++) {\n            // This will always be fine considering the validations made above. \n            uint256 tokenId = i < specificIds.length ? \n                specificIds[i] : getRandomTokenIdFromVault();\n            redeemedIds[i] = tokenId;\n\n            if (_is1155) {\n                quantity1155[tokenId] -= 1;\n                if (quantity1155[tokenId] == 0) {\n                    holdings.remove(tokenId);\n                }\n\n                IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n                    address(this),\n                    to,\n                    tokenId,\n                    1,\n                    \"\"\n                );\n            } else {\n                holdings.remove(tokenId);\n                transferERC721(_assetAddress, to, tokenId);\n            }\n        }\n        afterRedeemHook(redeemedIds);\n        return redeemedIds;\n    }\n\n    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {\n        // Do not charge fees if the zap contract is calling\n        // Added in v1.0.3. Changed to mapping in v1.0.5.\n        if (vaultFactory.excludedFromFees(msg.sender)) {\n            return;\n        }\n        \n        // Mint fees directly to the distributor and distribute.\n        if (amount > 0) {\n            address feeDistributor = vaultFactory.feeDistributor();\n            // Changed to a _transfer() in v1.0.3.\n            _transfer(user, feeDistributor, amount);\n            INFTXFeeDistributor(feeDistributor).distribute(vaultId);\n        }\n    }\n\n    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n        bytes memory data;\n        if (assetAddr == kitties) {\n            // Changed in v1.0.4.\n            data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, tokenId);\n        } else if (assetAddr == punks) {\n            // CryptoPunks.\n            data = abi.encodeWithSignature(\"transferPunk(address,uint256)\", to, tokenId);\n        } else {\n            // Default.\n            data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", address(this), to, tokenId);\n        }\n        (bool success,) = address(assetAddr).call(data);\n        require(success);\n    }\n\n    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {\n        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n        bytes memory data;\n        if (assetAddr == kitties) {\n            // Cryptokitties.\n            data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n        } else if (assetAddr == punks) {\n            // CryptoPunks.\n            // Fix here for frontrun attack. Added in v1.0.2.\n            bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenId);\n            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n            (address owner) = abi.decode(result, (address));\n            require(checkSuccess && owner == msg.sender, \"Not the owner\");\n            data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n        } else {\n            // Default.\n            // Allow other contracts to \"push\" into the vault, safely.\n            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.\n            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {\n                require(!holdings.contains(tokenId), \"Trying to use an owned NFT\");\n                return;\n            } else {\n                data = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n            }\n        }\n        (bool success, bytes memory resultData) = address(assetAddr).call(data);\n        require(success, string(resultData));\n    }\n\n    function getRandomTokenIdFromVault() internal virtual returns (uint256) {\n        uint256 randomIndex = uint256(\n            keccak256(\n                abi.encodePacked(\n                    blockhash(block.number - 1), \n                    randNonce,\n                    block.coinbase,\n                    block.difficulty,\n                    block.timestamp\n                )\n            )\n        ) % holdings.length();\n        randNonce += 1;\n        return holdings.at(randomIndex);\n    }\n\n    function onlyPrivileged() internal view {\n        if (manager == address(0)) {\n            require(msg.sender == owner(), \"Not owner\");\n        } else {\n            require(msg.sender == manager, \"Not manager\");\n        }\n    }\n\n    function onlyOwnerIfPaused(uint256 lockId) internal view {\n        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), \"Paused\");\n    }\n}\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\ncontract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  bool public distributionPaused;\n\n  address public override nftxVaultFactory;\n  address public override lpStaking;\n  address public override treasury;\n\n  // Total allocation points per vault. \n  uint256 public override allocTotal;\n  FeeReceiver[] public feeReceivers;\n\n  address public override inventoryStaking;\n\n  event UpdateTreasuryAddress(address newTreasury);\n  event UpdateLPStakingAddress(address newLPStaking);\n  event UpdateInventoryStakingAddress(address newInventoryStaking);\n  event UpdateNFTXVaultFactory(address factory);\n  event PauseDistribution(bool paused); \n\n  event AddFeeReceiver(address receiver, uint256 allocPoint);\n  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);\n  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);\n  event RemoveFeeReceiver(address receiver);\n  \n  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {\n    __Pausable_init();\n    setTreasuryAddress(_treasury);\n    setLPStakingAddress(_lpStaking);\n\n    _addReceiver(0.8 ether, lpStaking, true);\n  }\n\n  function distribute(uint256 vaultId) external override virtual nonReentrant {\n    require(nftxVaultFactory != address(0));\n    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n    if (distributionPaused || allocTotal == 0) {\n      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n      return;\n    } \n\n    uint256 length = feeReceivers.length;\n    uint256 leftover;\n    for (uint256 i = 0; i < length; i++) {\n      FeeReceiver memory _feeReceiver = feeReceivers[i];\n      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;\n      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n      if (!complete) {\n        leftover = amountToSend;\n      } else {\n        leftover = 0;\n      }\n    }\n\n    if (leftover > 0) {\n      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);\n    }\n  }\n\n  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {\n    _addReceiver(_allocPoint, _receiver, _isContract);\n  }\n\n  function initializeVaultReceivers(uint256 _vaultId) external override {\n    require(msg.sender == nftxVaultFactory, \"FeeReceiver: not factory\");\n    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);\n    if (inventoryStaking != address(0))\n      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);\n  }\n\n  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    allocTotal -= feeReceiver.allocPoint;\n    feeReceiver.allocPoint = _allocPoint;\n    allocTotal += _allocPoint;\n    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);\n  }\n\n  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {\n    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];\n    address oldReceiver = feeReceiver.receiver;\n    feeReceiver.receiver = _address;\n    feeReceiver.isContract = _isContract;\n    emit UpdateFeeReceiverAddress(oldReceiver, _address);\n  }\n\n  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {\n    uint256 arrLength = feeReceivers.length;\n    require(_receiverIdx < arrLength, \"FeeDistributor: Out of bounds\");\n    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);\n    allocTotal -= feeReceivers[_receiverIdx].allocPoint;\n    // Copy the last element to what is being removed and remove the last element.\n    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];\n    feeReceivers.pop();\n  }\n\n  function setTreasuryAddress(address _treasury) public override onlyOwner {\n    require(_treasury != address(0), \"Treasury != address(0)\");\n    treasury = _treasury;\n    emit UpdateTreasuryAddress(_treasury);\n  }\n\n  function setLPStakingAddress(address _lpStaking) public override onlyOwner {\n    require(_lpStaking != address(0), \"LPStaking != address(0)\");\n    lpStaking = _lpStaking;\n    emit UpdateLPStakingAddress(_lpStaking);\n  }\n\n  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {\n    inventoryStaking = _inventoryStaking;\n    emit UpdateInventoryStakingAddress(_inventoryStaking);\n  }\n\n  function setNFTXVaultFactory(address _factory) external override onlyOwner {\n    nftxVaultFactory = _factory;\n    emit UpdateNFTXVaultFactory(_factory);\n  }\n\n  function pauseFeeDistribution(bool pause) external onlyOwner {\n    distributionPaused = pause;\n    emit PauseDistribution(pause);\n  }\n\n  function rescueTokens(address _address) external override onlyOwner {\n    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));\n    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);\n  }\n\n  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {\n    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);\n    feeReceivers.push(_feeReceiver);\n    allocTotal += _allocPoint;\n    emit AddFeeReceiver(_receiver, _allocPoint);\n  }\n\n  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n    if (_receiver.isContract) {\n      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n      // If the receive is not properly processed, send it to the treasury instead.\n       \n      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n      (bool success, ) = address(_receiver.receiver).call(payload);\n\n      // If the allowance has not been spent, it means we can pass it forward to next.\n      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n    } else {\n      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    }\n  }\n} contract StakingTokenProvider is OwnableUpgradeable {\n\n  address public uniLikeExchange;\n  address public defaultPairedToken;\n  string public defaultPrefix;\n  mapping(address => address) public pairedToken;\n  mapping(address => string) public pairedPrefix;\n\n  event NewDefaultPaired(address oldPaired, address newPaired);\n  event NewPairedTokenForVault(address vaultToken, address oldPairedtoken, address newPairedToken);\n\n  // This is an address provder to allow us to abstract out what liquidity \n  // our vault tokens should be paired with. \n  function __StakingTokenProvider_init(address _uniLikeExchange, address _defaultPairedtoken, string memory _defaultPrefix) public initializer {\n    __Ownable_init();\n    require(_uniLikeExchange != address(0), \"Cannot be address(0)\");\n    require(_defaultPairedtoken != address(0), \"Cannot be address(0)\");\n    uniLikeExchange = _uniLikeExchange;\n    defaultPairedToken = _defaultPairedtoken;\n    defaultPrefix = _defaultPrefix;\n  }\n\n  function setPairedTokenForVaultToken(address _vaultToken, address _newPairedToken, string calldata _newPrefix) external onlyOwner {\n    require(_newPairedToken != address(0), \"Cannot be address(0)\");\n    emit NewPairedTokenForVault(_vaultToken, pairedToken[_vaultToken], _newPairedToken);\n    pairedToken[_vaultToken] = _newPairedToken;\n    pairedPrefix[_vaultToken] = _newPrefix;\n  }\n\n  function setDefaultPairedToken(address _newDefaultPaired, string calldata _newDefaultPrefix) external onlyOwner {\n    emit NewDefaultPaired(defaultPairedToken, _newDefaultPaired);\n    defaultPairedToken = _newDefaultPaired;\n    defaultPrefix = _newDefaultPrefix;\n  }\n\n  function stakingTokenForVaultToken(address _vaultToken) external view returns (address) {\n    address _pairedToken = pairedToken[_vaultToken];\n    if (_pairedToken == address(0)) {\n      _pairedToken = defaultPairedToken;\n    }\n    return pairFor(uniLikeExchange, _vaultToken, _pairedToken);\n  }\n\n  function nameForStakingToken(address _vaultToken) external view returns (string memory) {\n    string memory _pairedPrefix = pairedPrefix[_vaultToken];\n    if (bytes(_pairedPrefix).length == 0) {\n      _pairedPrefix = defaultPrefix;\n    }\n    address _pairedToken = pairedToken[_vaultToken];\n    if (_pairedToken == address(0)) {\n      _pairedToken = defaultPairedToken;\n    }\n\n    string memory symbol1 = IERC20Metadata(_vaultToken).symbol();\n    string memory symbol2 = IERC20Metadata(_pairedToken).symbol();\n    return string(abi.encodePacked(_pairedPrefix, symbol1, symbol2));\n  }\n\n  function pairForVaultToken(address _vaultToken, address _pairedToken) external view returns (address) {\n    return pairFor(uniLikeExchange, _vaultToken, _pairedToken);\n  }\n  \n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n      (address token0, address token1) = sortTokens(tokenA, tokenB);\n      pair = address(uint160(uint256(keccak256(abi.encodePacked(\n              hex'ff',\n              factory,\n              keccak256(abi.encodePacked(token0, token1)),\n              hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n      )))));\n  }\n}abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\ncontract PausableUpgradeable is OwnableUpgradeable {\n\n    function __Pausable_init() internal initializer {\n        __Ownable_init();\n    }\n\n    event SetPaused(uint256 lockId, bool paused);\n    event SetIsGuardian(address addr, bool isGuardian);\n\n    mapping(address => bool) public isGuardian;\n    mapping(uint256 => bool) public isPaused;\n    // 0 : createVault\n    // 1 : mint\n    // 2 : redeem\n    // 3 : swap\n    // 4 : flashloan\n\n    function onlyOwnerIfPaused(uint256 lockId) public view virtual {\n        require(!isPaused[lockId] || msg.sender == owner(), \"Paused\");\n    }\n\n    function unpause(uint256 lockId)\n        public\n        virtual\n        onlyOwner\n    {\n        isPaused[lockId] = false;\n        emit SetPaused(lockId, false);\n    }\n\n    function pause(uint256 lockId) public virtual {\n        require(isGuardian[msg.sender], \"Can't pause\");\n        isPaused[lockId] = true;\n        emit SetPaused(lockId, true);\n    }\n\n    function setIsGuardian(address addr, bool _isGuardian) public virtual onlyOwner {\n        isGuardian[addr] = _isGuardian;\n        emit SetIsGuardian(addr, _isGuardian);\n    }\n}\nabstract contract ERC1155ReceiverUpgradeable is ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n}\ncontract NFTXLPStaking is PausableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    INFTXVaultFactory public nftxVaultFactory;\n    IRewardDistributionToken public rewardDistTokenImpl;\n    StakingTokenProvider public stakingTokenProvider;\n\n    event PoolCreated(uint256 vaultId, address pool);\n    event PoolUpdated(uint256 vaultId, address pool);\n    event FeesReceived(uint256 vaultId, uint256 amount);\n\n    struct StakingPool {\n        address stakingToken;\n        address rewardToken;\n    }\n    mapping(uint256 => StakingPool) public vaultStakingInfo;\n\n    TimelockRewardDistributionTokenImpl public newTimelockRewardDistTokenImpl;\n\n    function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer {\n        __Ownable_init();\n        require(_stakingTokenProvider != address(0), \"Provider != address(0)\");\n        assignNewImpl();\n        stakingTokenProvider = StakingTokenProvider(_stakingTokenProvider);\n    }\n\n    function assignNewImpl() public {\n        require(address(newTimelockRewardDistTokenImpl) == address(0), \"Already assigned\");\n        newTimelockRewardDistTokenImpl = new TimelockRewardDistributionTokenImpl();\n        newTimelockRewardDistTokenImpl.__TimelockRewardDistributionToken_init(IERC20Upgradeable(address(0)), \"\", \"\");\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || msg.sender == nftxVaultFactory.feeDistributor(), \"LPStaking: Not authorized\");\n        _;\n    }\n\n    function setNFTXVaultFactory(address newFactory) external onlyOwner {\n        require(newFactory != address(0));\n        nftxVaultFactory = INFTXVaultFactory(newFactory);\n    }\n\n    function setStakingTokenProvider(address newProvider) external onlyOwner {\n        require(newProvider != address(0));\n        stakingTokenProvider = StakingTokenProvider(newProvider);\n    }\n\n    function addPoolForVault(uint256 vaultId) external onlyAdmin {\n        require(address(nftxVaultFactory) != address(0), \"LPStaking: Factory not set\");\n        require(vaultStakingInfo[vaultId].stakingToken == address(0), \"LPStaking: Pool already exists\");\n        address _rewardToken = nftxVaultFactory.vault(vaultId);\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(_rewardToken);\n        StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);\n        vaultStakingInfo[vaultId] = pool;\n        address newRewardDistToken = _deployDividendToken(pool);\n        emit PoolCreated(vaultId, newRewardDistToken);\n    }\n\n    function updatePoolForVaults(uint256[] calldata vaultIds) external {\n        for (uint256 i = 0; i < vaultIds.length; i++) {\n            updatePoolForVault(vaultIds[i]);\n        }\n    }\n\n    // In case the provider changes, this lets the pool be updated. Anyone can call it.\n    function updatePoolForVault(uint256 vaultId) public {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        // Not letting people use this function to create new pools.\n        require(pool.stakingToken != address(0), \"LPStaking: Pool doesn't exist\");\n        address _stakingToken = stakingTokenProvider.stakingTokenForVaultToken(pool.rewardToken);\n        StakingPool memory newPool = StakingPool(_stakingToken, pool.rewardToken);\n        vaultStakingInfo[vaultId] = newPool;\n        \n        // If the pool is already deployed, ignore the update.\n        address addr = address(_rewardDistributionTokenAddr(newPool));\n        if (isContract(addr)) {\n            return;\n        }\n        address newRewardDistToken = _deployDividendToken(newPool);\n        emit PoolUpdated(vaultId, newRewardDistToken);\n    }\n\n    function receiveRewards(uint256 vaultId, uint256 amount) external onlyAdmin returns (bool) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            // In case the pair is updated, but not yet \n            return false;\n        }\n        \n        TimelockRewardDistributionTokenImpl rewardDistToken = _rewardDistributionTokenAddr(pool);\n        // Don't distribute rewards unless there are people to distribute to.\n        // Also added here if the distribution token is not deployed, just forfeit rewards for now.\n        if (!isContract(address(rewardDistToken)) || rewardDistToken.totalSupply() == 0) {\n            return false;\n        }\n        // We \"pull\" to the dividend tokens so the vault only needs to approve this contract.\n        IERC20Upgradeable(pool.rewardToken).safeTransferFrom(msg.sender, address(rewardDistToken), amount);\n        rewardDistToken.distributeRewards(amount);\n        emit FeesReceived(vaultId, amount);\n        return true;\n    }\n\n    function deposit(uint256 vaultId, uint256 amount) external {\n        onlyOwnerIfPaused(10);\n        // Check the pool in case its been updated.\n        updatePoolForVault(vaultId);\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        _deposit(pool, amount);\n    }\n\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external {\n        require(nftxVaultFactory.excludedFromFees(msg.sender), \"Not zap\");\n        onlyOwnerIfPaused(10);\n        // Check the pool in case its been updated.\n        updatePoolForVault(vaultId);\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);\n        _rewardDistributionTokenAddr(pool).timelockMint(account, amount, timelockLength);\n    }\n\n    function exit(uint256 vaultId) external {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        _claimRewards(pool, msg.sender);\n        _withdraw(pool, balanceOf(vaultId, msg.sender), msg.sender);\n    }\n\n    function emergencyExitAndClaim(address _stakingToken, address _rewardToken) external {\n        StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);\n        TimelockRewardDistributionTokenImpl dist = _rewardDistributionTokenAddr(pool);\n        require(isContract(address(dist)), \"Not a pool\");\n        _claimRewards(pool, msg.sender);\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\n    }\n\n    function emergencyExit(address _stakingToken, address _rewardToken) external {\n        StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);\n        TimelockRewardDistributionTokenImpl dist = _rewardDistributionTokenAddr(pool);\n        require(isContract(address(dist)), \"Not a pool\");\n        _withdraw(pool, dist.balanceOf(msg.sender), msg.sender);\n    }\n\n    function emergencyMigrate(uint256 vaultId) external {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        IRewardDistributionToken unusedDist = _unusedRewardDistributionTokenAddr(pool);\n        IRewardDistributionToken oldDist = _oldRewardDistributionTokenAddr(pool);\n\n        uint256 unusedDistBal; \n        if (isContract(address(unusedDist))) {\n            unusedDistBal = unusedDist.balanceOf(msg.sender);\n            if (unusedDistBal > 0) {\n                unusedDist.burnFrom(msg.sender, unusedDistBal);\n            }\n        }\n        uint256 oldDistBal; \n        if (isContract(address(oldDist))) {\n            oldDistBal = oldDist.balanceOf(msg.sender);\n            if (oldDistBal > 0) {\n                oldDist.withdrawReward(msg.sender); \n                oldDist.burnFrom(msg.sender, oldDistBal);\n            }\n        }\n        \n        TimelockRewardDistributionTokenImpl newDist = _rewardDistributionTokenAddr(pool);\n        if (!isContract(address(newDist))) {\n            address deployedDist = _deployDividendToken(pool);\n            require(deployedDist == address(newDist), \"Not deploying proper distro\");\n            emit PoolUpdated(vaultId, deployedDist);\n        }\n        require(unusedDistBal + oldDistBal > 0, \"Nothing to migrate\");\n        newDist.mint(msg.sender, unusedDistBal + oldDistBal);\n    }\n\n    function withdraw(uint256 vaultId, uint256 amount) external {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        _withdraw(pool, amount, msg.sender);\n    }\n\n    function claimRewards(uint256 vaultId) public {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        _claimRewards(pool, msg.sender);\n    }\n\n    function claimMultipleRewards(uint256[] memory vaultIds) external {\n        for (uint256 i = 0; i < vaultIds.length; i++) {\n            claimRewards(vaultIds[i]);\n        }\n    }\n\n    function newRewardDistributionToken(uint256 vaultId) external view returns (TimelockRewardDistributionTokenImpl) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            return TimelockRewardDistributionTokenImpl(address(0));\n        }\n        return _rewardDistributionTokenAddr(pool);\n    }\n\n   function rewardDistributionToken(uint256 vaultId) external view returns (IRewardDistributionToken) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            return IRewardDistributionToken(address(0));\n        }\n        return _unusedRewardDistributionTokenAddr(pool);\n    }\n\n    function oldRewardDistributionToken(uint256 vaultId) external view returns (address) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            return address(0);\n        }\n        return address(_oldRewardDistributionTokenAddr(pool));\n    }\n\n    function unusedRewardDistributionToken(uint256 vaultId) external view returns (address) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        if (pool.stakingToken == address(0)) {\n            return address(0);\n        }\n        return address(_unusedRewardDistributionTokenAddr(pool));\n    }\n\n    function rewardDistributionTokenAddr(address stakingToken, address rewardToken) public view returns (address) {\n        StakingPool memory pool = StakingPool(stakingToken, rewardToken);\n        return address(_rewardDistributionTokenAddr(pool));\n    }\n\n    function balanceOf(uint256 vaultId, address addr) public view returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        TimelockRewardDistributionTokenImpl dist = _rewardDistributionTokenAddr(pool);\n        require(isContract(address(dist)), \"Not a pool\");\n        return dist.balanceOf(addr);\n    }\n\n    function oldBalanceOf(uint256 vaultId, address addr) public view returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        IRewardDistributionToken dist = _oldRewardDistributionTokenAddr(pool);\n        require(isContract(address(dist)), \"Not a pool\");\n        return dist.balanceOf(addr);\n    }\n\n    function unusedBalanceOf(uint256 vaultId, address addr) public view returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        IRewardDistributionToken dist = _unusedRewardDistributionTokenAddr(pool);\n        require(isContract(address(dist)), \"Not a pool\");\n        return dist.balanceOf(addr);\n    }\n\n\n    function lockedUntil(uint256 vaultId, address who) external view returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        TimelockRewardDistributionTokenImpl dist = _rewardDistributionTokenAddr(pool);\n        return dist.timelockUntil(who);\n    }\n\n    function lockedLPBalance(uint256 vaultId, address who) external view returns (uint256) {\n        StakingPool memory pool = vaultStakingInfo[vaultId];\n        TimelockRewardDistributionTokenImpl dist = _rewardDistributionTokenAddr(pool);\n        if(block.timestamp > dist.timelockUntil(who)) {\n            return 0;\n        }\n        return dist.balanceOf(who);\n    }\n\n    function _deposit(StakingPool memory pool, uint256 amount) internal {\n        require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");\n        IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);\n        // Timelock for 2 seconds to prevent flash loans.\n        _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);\n    }\n\n    function _claimRewards(StakingPool memory pool, address account) internal {\n        require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");\n        _rewardDistributionTokenAddr(pool).withdrawReward(account);\n    }\n\n    function _withdraw(StakingPool memory pool, uint256 amount, address account) internal {\n        require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");\n        _rewardDistributionTokenAddr(pool).burnFrom(account, amount);\n        IERC20Upgradeable(pool.stakingToken).safeTransfer(account, amount);\n    }\n\n    function _deployDividendToken(StakingPool memory pool) internal returns (address) {\n        // Changed to use new nonces.\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.rewardToken, uint256(2)));\n        address rewardDistToken = ClonesUpgradeable.cloneDeterministic(address(newTimelockRewardDistTokenImpl), salt);\n        string memory name = stakingTokenProvider.nameForStakingToken(pool.rewardToken);\n        TimelockRewardDistributionTokenImpl(rewardDistToken).__TimelockRewardDistributionToken_init(IERC20Upgradeable(pool.rewardToken), name, name);\n        return rewardDistToken;\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function _rewardDistributionTokenAddr(StakingPool memory pool) public view returns (TimelockRewardDistributionTokenImpl) {\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.rewardToken, uint256(2) /* small nonce to change tokens */));\n        address tokenAddr = ClonesUpgradeable.predictDeterministicAddress(address(newTimelockRewardDistTokenImpl), salt);\n        return TimelockRewardDistributionTokenImpl(tokenAddr);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function _oldRewardDistributionTokenAddr(StakingPool memory pool) public view returns (IRewardDistributionToken) {\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.rewardToken, uint256(1)));\n        address tokenAddr = ClonesUpgradeable.predictDeterministicAddress(address(rewardDistTokenImpl), salt);\n        return IRewardDistributionToken(tokenAddr);\n    }\n\n    // Note: this function does not guarantee the token is deployed, we leave that check to elsewhere to save gas.\n    function _unusedRewardDistributionTokenAddr(StakingPool memory pool) public view returns (IRewardDistributionToken) {\n        bytes32 salt = keccak256(abi.encodePacked(pool.stakingToken, pool.rewardToken));\n        address tokenAddr = ClonesUpgradeable.predictDeterministicAddress(address(rewardDistTokenImpl), salt);\n        return IRewardDistributionToken(tokenAddr);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}contract UpgradeableBeacon is IBeacon, OwnableUpgradeable {\n    address private _childImplementation;\n\n    /**\n     * @dev Emitted when the child implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed childImplementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    function __UpgradeableBeacon__init(address childImplementation_) public initializer {\n        _setChildImplementation(childImplementation_);\n    }\n\n    /**\n     * @dev Returns the current child implementation address.\n     */\n    function childImplementation() public view virtual override returns (address) {\n        return _childImplementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newChildImplementation` must be a contract.\n     */\n    function upgradeChildTo(address newChildImplementation) public virtual override onlyOwner {\n        _setChildImplementation(newChildImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newChildImplementation` must be a contract.\n     */\n    function _setChildImplementation(address newChildImplementation) private {\n        require(Address.isContract(newChildImplementation), \"UpgradeableBeacon: child implementation is not a contract\");\n        _childImplementation = newChildImplementation;\n        emit Upgraded(newChildImplementation);\n    }\n}abstract contract ERC165Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n}\n",
    "bin": []
}