{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/71",
    "external_functions": [
        [
            "CDSTemplate",
            "IParameters",
            "IERC20Metadata",
            "IVault",
            "IRegistry"
        ],
        [
            "Factory",
            "IUniversalMarket",
            "IRegistry",
            "IOwnership"
        ],
        [
            "IndexTemplate",
            "IParameters",
            "IERC20Metadata",
            "IVault",
            "IPoolTemplate",
            "IRegistry",
            "ICDSTemplate"
        ],
        [
            "InsureDAOERC20"
        ],
        [
            "Ownership"
        ],
        [
            "Parameters",
            "IOwnership",
            "IPremiumModel"
        ],
        [
            "PoolTemplate",
            "IERC20Metadata",
            "IParameters",
            "IVault",
            "IRegistry",
            "IIndexTemplate"
        ],
        [
            "BondingPremium"
        ],
        [
            "Registry",
            "IOwnership"
        ],
        [
            "Vault",
            "IController",
            "IERC20"
        ]
    ],
    "new_contract": "abstract contract IParameters {\n    function setVault(address _token, address _vault) external virtual;\n\n    function setLockup(address _address, uint256 _target) external virtual;\n\n    function setGrace(address _address, uint256 _target) external virtual;\n\n    function setMinDate(address _address, uint256 _target) external virtual;\n\n    function setUpperSlack(address _address, uint256 _target) external virtual;\n\n    function setLowerSlack(address _address, uint256 _target) external virtual;\n\n    function setWithdrawable(address _address, uint256 _target)\n        external\n        virtual;\n\n    function setPremiumModel(address _address, address _target)\n        external\n        virtual;\n\n    function setFeeRate(address _address, uint256 _target) external virtual;\n\n    function setMaxList(address _address, uint256 _target) external virtual;\n\n    function setCondition(bytes32 _reference, bytes32 _target) external virtual;\n\n    function getOwner() external view virtual returns (address);\n\n    function getVault(address _token) external view virtual returns (address);\n\n    function getPremium(\n        uint256 _amount,\n        uint256 _term,\n        uint256 _totalLiquidity,\n        uint256 _lockedAmount,\n        address _target\n    ) external view virtual returns (uint256);\n\n    function getFeeRate(address _target) external view virtual returns (uint256);\n\n    function getUpperSlack(address _target)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function getLowerSlack(address _target)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function getLockup(address _target) external view virtual returns (uint256);\n\n    function getWithdrawable(address _target)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function getGrace(address _target) external view virtual returns (uint256);\n\n    function getMinDate(address _target) external view virtual returns (uint256);\n\n    function getMaxList(address _target)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function getCondition(bytes32 _reference)\n        external\n        view\n        virtual\n        returns (bytes32);\n}\ncontract Parameters is IParameters {\n    event VaultSet(address indexed token, address vault);\n    event FeeRateSet(address indexed target, uint256 rate);\n    event PremiumSet(address indexed target, address model);\n    event UpperSlack(address indexed target, uint256 rate);\n    event LowerSlack(address indexed target, uint256 rate);\n    event LockupSet(address indexed target, uint256 span);\n    event GraceSet(address indexed target, uint256 span);\n    event MinDateSet(address indexed target, uint256 span);\n    event WithdrawableSet(address indexed target, uint256 span);\n    event ConditionSet(bytes32 indexed ref, bytes32 condition);\n    event MaxListSet(address target, uint256 max);\n\n    address public ownership;\n\n    mapping(address => address) private _vaults; //address of the vault contract for each token\n    mapping(address => uint256) private _fee; //fee rate in 1e6 (100% = 1e6)\n    mapping(address => address) private _premium; //address for each premium model contract\n    mapping(address => uint256) private _lowerSlack; //lower slack range before adjustAlloc for index\n    mapping(address => uint256) private _upperSlack; //upper slack range before adjustAlloc for index\n    mapping(address => uint256) private _grace; //grace before an insurance policy expires\n    mapping(address => uint256) private _lockup; //funds lock up period after user requested to withdraw liquidity\n    mapping(address => uint256) private _min; //minimum period to purchase an insurance policy\n    mapping(address => uint256) private _maxList; //maximum number of pools one index can allocate\n    mapping(address => uint256) private _withdawable; //a certain period a user can withdraw after lock up ends\n    mapping(bytes32 => bytes32) private _conditions; //condition mapping for future use cases\n\n    constructor(address _ownership) {\n        ownership = _ownership;\n    }\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            IOwnership(ownership).owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    /**\n     * @notice set the vault address corresponding to the token address\n     * @param _token address of token\n     * @param _vault vault for token\n     */\n    function setVault(address _token, address _vault)\n        external\n        override\n        onlyOwner\n    {\n        require(_vaults[_token] == address(0), \"dev: already initialized\");\n        require(_vault != address(0), \"dev: zero address\");\n        _vaults[_token] = _vault;\n        emit VaultSet(_token, _vault);\n    }\n\n    /**\n     * @notice set lock up periods in unix timestamp length (1 day = 86400)\n     * @param _address address to set the parameter\n     * @param _target parameter\n     */\n    function setLockup(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _lockup[_address] = _target;\n        emit LockupSet(_address, _target);\n    }\n\n    /**\n     * @notice set grace period length in unix timestamp length (1 day = 86400)\n     * @param _address address to set the parameter\n     * @param _target parameter\n     */\n    function setGrace(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _grace[_address] = _target;\n        emit GraceSet(_address, _target);\n    }\n\n    /**\n     * @notice set min length in unix timestamp length (1 day = 86400)\n     * @param _address address to set the parameter\n     * @param _target parameter\n     */\n    function setMinDate(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _min[_address] = _target;\n        emit MinDateSet(_address, _target);\n    }\n\n    /**\n     * @notice set slack rate of leverage before adjustAlloc\n     * @param _address address to set the parameter\n     * @param _target parameter (slack rate 100% = 1000\n     */\n    function setUpperSlack(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _upperSlack[_address] = _target;\n        emit UpperSlack(_address, _target);\n    }\n\n    /**\n     * @notice set slack rate of leverage before adjustAlloc\n     * @param _address address to set the parameter\n     * @param _target parameter (slack rate 100% = 1000\n     */\n    function setLowerSlack(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _lowerSlack[_address] = _target;\n        emit LowerSlack(_address, _target);\n    }\n\n    /**\n     * @notice set withdrawable period in unixtimestamp length (1 day = 86400)\n     * @param _address address to set the parameter\n     * @param _target parameter\n     */\n    function setWithdrawable(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _withdawable[_address] = _target;\n        emit WithdrawableSet(_address, _target);\n    }\n\n    /**\n     * @notice set the contract address of premium model\n     * @param _address address to set the premium model\n     * @param _target premium model contract address\n     */\n    function setPremiumModel(address _address, address _target)\n        external\n        override\n        onlyOwner\n    {\n        require(_target != address(0), \"dev: zero address\");\n        _premium[_address] = _target;\n        emit PremiumSet(_address, _target);\n    }\n\n    /**\n     * @notice set the contract address of fee model\n     * @param _address address to set the fee model\n     * @param _target fee rate\n     */\n    function setFeeRate(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _fee[_address] = _target;\n        emit FeeRateSet(_address, _target);\n    }\n\n    /**\n     * @notice set the max list number (e.g. 10)\n     * @param _address address to set the parameter\n     * @param _target parameter\n     */\n    function setMaxList(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _maxList[_address] = _target;\n        emit MaxListSet(_address, _target);\n    }\n\n    /**\n     * @notice set the condition in bytes32 corresponding to bytes32\n     * @param _reference bytes32 value to refer the parameter\n     * @param _target parameter\n     */\n    function setCondition(bytes32 _reference, bytes32 _target)\n        external\n        override\n        onlyOwner\n    {\n        _conditions[_reference] = _target;\n        emit ConditionSet(_reference, _target);\n    }\n\n    /**\n     * @notice Get the address of the owner\n     * @return owner's address\n     */\n    function getOwner() public view override returns (address) {\n        return IOwnership(ownership).owner();\n    }\n\n    /**\n     * @notice get the address of the vault contract\n     * @param _token token address\n     * @return vault address\n     */\n    function getVault(address _token) external view override returns (address) {\n        return _vaults[_token];\n    }\n\n    /**\n     * @notice get premium amount for the specified conditions\n     * @param _amount amount to get insured\n     * @param _term term length\n     * @param _totalLiquidity liquidity of the target contract's pool\n     * @param _lockedAmount locked amount of the total liquidity\n     * @param _target address of insurance market\n     * @return premium amount\n     */\n    function getPremium(\n        uint256 _amount,\n        uint256 _term,\n        uint256 _totalLiquidity,\n        uint256 _lockedAmount,\n        address _target\n    ) external view override returns (uint256) {\n        if (_premium[_target] == address(0)) {\n            return\n                IPremiumModel(_premium[address(0)]).getPremium(\n                    _amount,\n                    _term,\n                    _totalLiquidity,\n                    _lockedAmount\n                );\n        } else {\n            return\n                IPremiumModel(_premium[_target]).getPremium(\n                    _amount,\n                    _term,\n                    _totalLiquidity,\n                    _lockedAmount\n                );\n        }\n    }\n\n    /**\n     * @notice get fee rate for the specified conditions\n     * @param _target address of insurance market\n     * @return fee rate\n     */\n    function getFeeRate(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_fee[_target] == 0) {\n            return _fee[address(0)];\n        } else {\n            return _fee[_target];\n        }\n    }\n\n    /**\n     * @notice get slack rate of leverage before adjustAlloc\n     * @param _target target contract's address\n     * @return upper slack(slack above target)\n     */\n    function getUpperSlack(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_upperSlack[_target] == 0) {\n            return _upperSlack[address(0)];\n        } else {\n            return _upperSlack[_target];\n        }\n    }\n\n    /**\n     * @notice get slack rate of leverage before adjustAlloc\n     * @param _target target contract's address\n     * @return lower slack(slack below target)\n     */\n    function getLowerSlack(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_lowerSlack[_target] == 0) {\n            return _lowerSlack[address(0)];\n        } else {\n            return _lowerSlack[_target];\n        }\n    }\n\n    /**\n     * @notice get lock up period length\n     * @param _target target contract's address\n     * @return lock up period\n     */\n    function getLockup(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_lockup[_target] == 0) {\n            return _lockup[address(0)];\n        } else {\n            return _lockup[_target];\n        }\n    }\n\n    /**\n     * @notice get withdrawable period length\n     * @param _target target contract's address\n     * @return withdrawable period\n     */\n    function getWithdrawable(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_withdawable[_target] == 0) {\n            return _withdawable[address(0)];\n        } else {\n            return _withdawable[_target];\n        }\n    }\n\n    /**\n     * @notice get grace period length\n     * @param _target target contract's address\n     * @return grace period\n     */\n    function getGrace(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_grace[_target] == 0) {\n            return _grace[address(0)];\n        } else {\n            return _grace[_target];\n        }\n    }\n\n    /**\n     * @notice get minimum period length for an insurance policy\n     * @param _target target contract's address\n     * @return minimum lenght of policy\n     */\n    function getMinDate(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_min[_target] == 0) {\n            return _min[address(0)];\n        } else {\n            return _min[_target];\n        }\n    }\n\n    /**\n     * @notice get max number of pools for an index\n     * @param _target target contract's address\n     * @return maximum number of pools\n     */\n    function getMaxList(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_maxList[_target] == 0) {\n            return _maxList[address(0)];\n        } else {\n            return _maxList[_target];\n        }\n    }\n\n    /**\n     * @notice get conditions for the corresponding reference parameter in bytes32\n     * @param _reference reference address\n     * @return condition parameter\n     */\n    function getCondition(bytes32 _reference)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return _conditions[_reference];\n    }\n}\ncontract Vault is IVault {\n    using SafeERC20 for IERC20;\n\n    /**\n     * Storage\n     */\n\n    address public override token;\n    IController public controller;\n    IRegistry public registry;\n    IOwnership public ownership;\n\n    mapping(address => uint256) public override debts;\n    mapping(address => uint256) public attributions;\n    uint256 public totalAttributions;\n\n    address public keeper; //keeper can operate utilize(), if address zero, anyone can operate.\n    uint256 public balance; //balance of underlying token\n    uint256 public totalDebt; //total debt balance. 1debt:1token\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n\n\n    event ControllerSet(address controller);\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    modifier onlyMarket() {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR_ONLY_MARKET\"\n        );\n        _;\n    }\n\n    constructor(\n        address _token,\n        address _registry,\n        address _controller,\n        address _ownership\n    ) {\n        require(_token != address(0));\n        require(_registry != address(0));\n        require(_ownership != address(0));\n        //controller can be zero\n\n        token = _token;\n        registry = IRegistry(_registry);\n        controller = IController(_controller);\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * Vault Functions\n     */\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiaries beneficiary's address array\n     * @param _shares funds share within beneficiaries (100% = 1e6)\n     * @return _allocations attribution amount generated from the transaction\n     */\n    function addValueBatch(\n        uint256 _amount,\n        address _from,\n        address[2] memory _beneficiaries,\n        uint256[2] memory _shares\n    ) external override onlyMarket returns (uint256[2] memory _allocations) {\n        \n        require(_shares[0] + _shares[1] == 1000000, \"ERROR_INCORRECT_SHARE\");\n\n        uint256 _attributions;\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n\n        balance += _amount;\n        totalAttributions += _attributions;\n        for (uint128 i = 0; i < 2; i++) {\n            uint256 _allocation = (_shares[i] * _attributions) / MAGIC_SCALE_1E6;\n            attributions[_beneficiaries[i]] += _allocation;\n            _allocations[i] = _allocation;\n        }\n    }\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiary beneficiary's address\n     * @return _attributions attribution amount generated from the transaction\n     */\n\n    function addValue(\n        uint256 _amount,\n        address _from,\n        address _beneficiary\n    ) external override onlyMarket returns (uint256 _attributions) {\n\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n        balance += _amount;\n        totalAttributions += _attributions;\n        attributions[_beneficiary] += _attributions;\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw underlying value\n     * @param _amount amount of tokens to withdraw\n     * @param _to address to get underlying tokens\n     * @return _attributions amount of attributions burnet\n     */\n    function withdrawValue(uint256 _amount, address _to)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_WITHDRAW-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (totalAttributions * _amount) / valueAll();\n\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n\n        if (available() < _amount) {\n            //when USDC in this contract isn't enough\n            uint256 _shortage = _amount - available();\n            _unutilize(_shortage);\n\n            assert(available() >= _amount);\n        }\n\n        balance -= _amount;\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer underlying value\n     * @param _amount sender of value\n     * @param _destination reciepient of value\n     */\n\n    function transferValue(uint256 _amount, address _destination)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_TRANSFER-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        attributions[_destination] += _attributions;\n    }\n\n    /**\n     * @notice a registered contract can borrow balance from the vault\n     * @param _amount borrow amount\n     * @param _to borrower's address\n     */\n    function borrowValue(uint256 _amount, address _to) external onlyMarket override {\n        debts[msg.sender] += _amount;\n        totalDebt += _amount;\n\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can offset an address's debt\n     * @param _amount debt amount to offset\n     * @param _target borrower's address\n     */\n\n    function offsetDebt(uint256 _amount, address _target)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_REPAY_DEBT_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n        balance -= _amount;\n        debts[_target] -= _amount;\n        totalDebt -= _amount;\n    }\n\n    /**\n     * @notice a registerd market can transfer their debt to system debt\n     * @param _amount debt amount to transfer\n     * @dev will be called when CDS could not afford when resume the market.\n     */\n    function transferDebt(uint256 _amount) external onlyMarket override {\n\n        if(_amount != 0){\n            debts[msg.sender] -= _amount;\n            debts[address(0)] += _amount;\n        }\n    }\n\n    /**\n     * @notice anyone can repay the system debt by sending tokens to this contract\n     * @param _amount debt amount to repay\n     * @param _target borrower's address\n     */\n    function repayDebt(uint256 _amount, address _target) external override {\n        uint256 _debt = debts[_target];\n        if (_debt >= _amount) {\n            debts[_target] -= _amount;\n            totalDebt -= _amount;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        } else {\n            debts[_target] = 0;\n            totalDebt -= _debt;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);\n        }\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw value denominated in attribution\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAttribution(uint256 _attribution, address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(_attribution, _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAllAttribution(address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(attributions[msg.sender], _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function _withdrawAttribution(uint256 _attribution, address _to)\n        internal\n        returns (uint256 _retVal)\n    {\n        require(\n            attributions[msg.sender] >= _attribution,\n            \"ERROR_WITHDRAW-ATTRIBUTION_BADCONDITOONS\"\n        );\n        _retVal = (_attribution * valueAll()) / totalAttributions;\n\n        attributions[msg.sender] -= _attribution;\n        totalAttributions -= _attribution;\n\n        if (available() < _retVal) {\n            uint256 _shortage = _retVal - available();\n            _unutilize(_shortage);\n        }\n\n        balance -= _retVal;\n        IERC20(token).safeTransfer(_to, _retVal);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer value denominated in attribution\n     * @param _amount amount of attribution to transfer\n     * @param _destination reciepient of attribution\n     */\n    function transferAttribution(uint256 _amount, address _destination)\n        external\n        override\n    {\n        require(_destination != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        require(\n            _amount != 0 && attributions[msg.sender] >= _amount,\n            \"ERROR_TRANSFER-ATTRIBUTION_BADCONDITOONS\"\n        );\n\n        attributions[msg.sender] -= _amount;\n        attributions[_destination] += _amount;\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @return _amount amount of tokens utilized\n     */\n    function utilize() external override returns (uint256 _amount) {\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n        }\n        _amount = available(); //balance\n        if (_amount > 0) {\n            IERC20(token).safeTransfer(address(controller), _amount);\n            balance -= _amount;\n            controller.earn(address(token), _amount);\n        }\n    }\n\n    /**\n     * @notice get attribution number for the specified address\n     * @param _target target address\n     * @return amount of attritbution\n     */\n\n    function attributionOf(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return attributions[_target];\n    }\n\n    /**\n     * @notice get all attribution number for this contract\n     * @return amount of all attribution\n     */\n    function attributionAll() external view returns (uint256) {\n        return totalAttributions;\n    }\n\n    /**\n     * @notice Convert attribution number into underlying assset value\n     * @param _attribution amount of attribution\n     * @return token value of input attribution\n     */\n    function attributionValue(uint256 _attribution)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalAttributions > 0 && _attribution > 0) {\n            return (_attribution * valueAll()) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of the specified address\n     * @param _target target address\n     * @return token value of target address\n     */\n    function underlyingValue(address _target)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (attributions[_target] > 0) {\n            return (valueAll() * attributions[_target]) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of this contract\n     * @return all token value of the vault\n     */\n    function valueAll() public view returns (uint256) {\n        if (address(controller) != address(0)) {\n            return balance + controller.valueAll();\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     * @notice internal function to unutilize the funds and keep utilization rate\n     * @param _amount amount to withdraw from controller\n     */\n    function _unutilize(uint256 _amount) internal {\n        require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");\n\n        controller.withdraw(address(this), _amount);\n        balance += _amount;\n    }\n\n    /**\n     * @notice return how much funds in this contract is available to be utilized\n     * @return available balance to utilize\n     */\n    function available() public view returns (uint256) {\n        return balance - totalDebt;\n    }\n\n    /**\n     * @notice return how much price for each attribution\n     * @return value of one share of attribution\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return (valueAll() * MAGIC_SCALE_1E6) / totalAttributions;\n    }\n\n    /**\n     * onlyOwner\n     */\n\n    /**\n     * @notice withdraw redundant token stored in this contract\n     * @param _token token address\n     * @param _to beneficiary's address\n     */\n    function withdrawRedundant(address _token, address _to)\n        external\n        override\n        onlyOwner\n    {\n        if (\n            _token == address(token) &&\n            balance < IERC20(token).balanceOf(address(this))\n        ) {\n            uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                balance;\n            IERC20(token).safeTransfer(_to, _redundant);\n        } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n            IERC20(_token).safeTransfer(\n                _to,\n                IERC20(_token).balanceOf(address(this))\n            );\n        }\n    }\n\n    /**\n     * @notice admin function to set controller address\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) public override onlyOwner {\n        require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        if (address(controller) != address(0)) {\n            controller.migrate(address(_controller));\n            controller = IController(_controller);\n        } else {\n            controller = IController(_controller);\n        }\n\n        emit ControllerSet(_controller);\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @param _keeper keeper address\n     */\n    function setKeeper(address _keeper) external override onlyOwner {\n        if (keeper != _keeper) {\n            keeper = _keeper;\n        }\n    }\n}\nabstract contract IPoolTemplate {\n    function allocateCredit(uint256 _credit)\n        external\n        virtual\n        returns (uint256 _mintAmount);\n\n    function allocatedCredit(address _index)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function withdrawCredit(uint256 _credit)\n        external\n        virtual\n        returns (uint256 _retVal);\n\n    function availableBalance() public view virtual returns (uint256 _balance);\n\n    function utilizationRate() public view virtual returns (uint256 _rate);\n    function totalLiquidity() public view virtual returns (uint256 _balance);\n    function totalCredit() external view virtual returns (uint256);\n    function lockedAmount() external view virtual returns (uint256);\n\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        virtual\n        returns (uint256);\n\n    function pendingPremium(address _index)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function paused() external view virtual returns (bool);\n\n    //onlyOwner\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external virtual;\n}\ncontract InsureDAOERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    bool tokenInitialized;\n    string private _name = \"InsureDAO LP Token\";\n    string private _symbol = \"iLP\";\n    uint8 private _decimals = 18;\n\n    constructor() {}\n\n    function initializeToken(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) internal {\n        /***\n         *@notice initialize token. Only called internally.\n         *\n         */\n        assert(!tokenInitialized);\n        tokenInitialized = true;\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n\n        _balances[sender] = senderBalance - amount;\n\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\ncontract Ownership is IOwnership {\n    address private _owner;\n    address private _futureOwner;\n\n    event CommitNewOwnership(address indexed futureOwner);\n    event AcceptNewOwnership(address indexed owner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _owner = msg.sender;\n        emit AcceptNewOwnership(_owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() external view override returns (address) {\n        return _owner;\n    }\n\n    function futureOwner() external view override returns (address) {\n        return _futureOwner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            _owner == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    modifier onlyFutureOwner() {\n        require(\n            _futureOwner == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    function commitTransferOwnership(address newOwner)\n        external\n        override\n        onlyOwner\n    {\n        /***\n         *@notice Transfer ownership of GaugeController to `newOwner`\n         *@param newOwner Address to have ownership transferred to\n         */\n        _futureOwner = newOwner;\n        emit CommitNewOwnership(_futureOwner);\n    }\n\n    function acceptTransferOwnership() external override onlyFutureOwner {\n        /***\n         *@notice Accept a transfer of ownership\n         */\n        _owner = _futureOwner;\n        emit AcceptNewOwnership(_owner);\n    }\n}\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\ncontract IndexTemplate is InsureDAOERC20, IIndexTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event Resumed();\n    event Locked();\n    event MetadataChanged(string metadata);\n    event LeverageSet(uint256 target);\n    event AllocationSet(\n        uint256 indexed _index,\n        address indexed pool,\n        uint256 allocPoint\n    );\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    bool public locked;\n    uint256 public pendingEnd;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IVault public vault;\n    IRegistry public registry;\n\n    /// @notice Market variables for margin account\n    uint256 public totalAllocatedCredit; //total allocated credit(liquidity)\n    mapping(address => uint256) public allocPoints; //allocation point for each pool\n    uint256 public totalAllocPoint; //total allocation point\n    address[] public poolList; //list of all pools\n    uint256 public targetLev; //1x = MAGIC_SCALE_1E6\n    //The allocated credits are deemed as liquidity in each underlying pool\n    //Credit amount(liquidity) will be determined by the following math\n    //credit for a pool = total liquidity of this pool * leverage rate * allocation point for a pool / total allocation point\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    struct PoolStatus {\n        uint256 current;\n        uint256 available;\n        uint256 allocation;\n        address addr;\n    }\n\n    ///@notice magic numbers\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-Index\";\n        string memory _symbol = \"iIndex\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collateral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     * @return _mintAmount the amount of iToken minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(locked == false && paused == false, \"ERROR: DEPOSIT_DISABLED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        uint256 _supply = totalSupply();\n        uint256 _totalLiquidity = totalLiquidity();\n        vault.addValue(_amount, msg.sender, address(this));\n\n        if (_supply > 0 && _totalLiquidity > 0) {\n            _mintAmount = (_amount * _supply) / _totalLiquidity;\n        } else if (_supply > 0 && _totalLiquidity == 0) {\n            //when\n            _mintAmount = _amount * _supply;\n        } else {\n            _mintAmount = _amount;\n        }\n        emit Deposit(msg.sender, _amount, _mintAmount);\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n        uint256 _liquidityAfter = _totalLiquidity + _amount;\n        uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n            _liquidityAfter;\n        //execut adjustAlloc only when the leverage became below target - lower-slack\n        if (targetLev - parameters.getLowerSlack(address(this)) > _leverage) {\n            _adjustAlloc(_liquidityAfter);\n        }\n    }\n\n    /**\n     * @notice A liquidity provider requests withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collateral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        //Calculate underlying value\n\n        uint256 _liquidty = totalLiquidity();\n        uint256 _lockup = parameters.getLockup(msg.sender);\n        uint256 _requestTime = withdrawalReq[msg.sender].timestamp;\n        _retVal = (_liquidty * _amount) / totalSupply();\n        require(locked == false, \"ERROR: WITHDRAWAL_PENDING\");\n        require(\n            _requestTime + _lockup < block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        require(\n            _retVal <= withdrawable(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Check current leverage rate and get updated target total credit allocation\n        uint256 _liquidityAfter = _liquidty - _retVal;\n\n        if (_liquidityAfter > 0) {\n            uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n                _liquidityAfter;\n            //execute adjustAlloc only when the leverage became above target + upper-slack\n            if (\n                targetLev + parameters.getUpperSlack(address(this)) < _leverage\n            ) {\n                _adjustAlloc(_liquidityAfter);\n            }\n        } else {\n            _adjustAlloc(0);\n        }\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Get how much can a user withdraw from this index\n     * Withdrawable amount = Index liquidity - necessary amount to support credit liquidity\n     * Necessary amoount Locked * totalAllocPoint / allocpoint of the lowest available liquidity market\n     * Otherwise, the allocation to a specific pool may take up the overall allocation, and may break the risk sharing.\n     * @return _retVal withdrawable amount\n     */\n    function withdrawable() public view returns (uint256 _retVal) {\n        uint256 _totalLiquidity = totalLiquidity();\n        if(_totalLiquidity > 0){\n            uint256 _length = poolList.length;\n            uint256 _lowestAvailableRate = MAGIC_SCALE_1E6;\n            uint256 _targetAllocPoint;\n            uint256 _targetLockedCreditScore;\n            //Check which pool has the lowest available rate and keep stats\n            for (uint256 i = 0; i < _length; i++) {\n                address _poolAddress = poolList[i];\n                uint256 _allocPoint = allocPoints[_poolAddress];\n                if (_allocPoint > 0) {\n                    uint256 _allocated = IPoolTemplate(_poolAddress)\n                        .allocatedCredit(address(this));\n                    uint256 _availableBalance = IPoolTemplate(_poolAddress)\n                        .availableBalance();\n                    //check if some portion of credit is locked\n                    if (_allocated > _availableBalance) {\n                        uint256 _availableRate = (_availableBalance *\n                            MAGIC_SCALE_1E6) / _allocated;\n                        uint256 _lockedCredit = _allocated - _availableBalance;\n                        if (i == 0 || _availableRate < _lowestAvailableRate) {\n                            _lowestAvailableRate = _availableRate;\n                            _targetLockedCreditScore = _lockedCredit;\n                            _targetAllocPoint = _allocPoint;\n                        }\n                    }\n                }\n            }\n            //Calculate the return value\n            if (_lowestAvailableRate == MAGIC_SCALE_1E6) {\n                _retVal = _totalLiquidity;\n            } else {\n                uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;\n                _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev;\n                if(_necessaryAmount < _totalLiquidity){\n                    _retVal = _totalLiquidity - _necessaryAmount;\n                }else{\n                    _retVal = 0;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Adjust allocation of credit based on the target leverage rate\n     */\n    function adjustAlloc() public {\n        _adjustAlloc(totalLiquidity());\n    }\n\n    /**\n     * @notice Internal function to adjust allocation\n     * @param _liquidity available liquidity of the index\n     * Allocation adjustment of credit is done by the following steps\n     * 1)Check total allocatable balance of the index\n     * 2)Calculate ideal allocation for each pool\n     * 3)Check Current allocated balance for each pool\n     * 4)Adjust (withdraw/deposit) allocation for each Pool*\n     *\n     * Liquidity in pool may be locked and cannot withdraw. In that case, the index try to withdraw all available liquidity first,\n     * then recalculated available balance and iterate 1)~4) for the remaining.\n     *\n     * The index may allocate credit beyond the share settings to maintain the leverage rate not to surpass the leverage setting.\n     *\n     * Along with adjustment the index clears accrued premiums in underlying pools to this pool during allocation.\n     */\n    function _adjustAlloc(uint256 _liquidity) internal {\n        //Check current leverage rate and get target total credit allocation\n        uint256 _targetCredit = (targetLev * _liquidity) / MAGIC_SCALE_1E6;\n        uint256 _allocatable = _targetCredit;\n        uint256 _allocatablePoints = totalAllocPoint;\n        uint256 _length = poolList.length;\n        PoolStatus[] memory _poolList = new PoolStatus[](_length);\n\n        //Check each pool and if current credit allocation > target && it is impossible to adjust, then withdraw all availablle credit\n        for (uint256 i = 0; i < _length; i++) {\n            address _pool = poolList[i];\n            if (_pool != address(0)) {\n                uint256 _allocation = allocPoints[_pool];\n                //Target credit allocation for a pool\n                uint256 _target = (_targetCredit * _allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = IPoolTemplate(_pool).allocatedCredit(\n                    address(this)\n                );\n                //get how much liquidty is available to withdraw\n                uint256 _available = IPoolTemplate(_pool).availableBalance();\n                //if needed to withdraw credit but unable, then withdraw all available.\n                //Otherwise, skip.\n                if (\n                    (_current > _target && _current - _target > _available) ||\n                    IPoolTemplate(_pool).paused() == true\n                ) {\n                    IPoolTemplate(_pool).withdrawCredit(_available);\n                    totalAllocatedCredit -= _available;\n                    _poolList[i].addr = address(0);\n                    _allocatable -= _current - _available;\n                    _allocatablePoints -= _allocation;\n                } else {\n                    _poolList[i].addr = _pool;\n                    _poolList[i].current = _current;\n                    _poolList[i].available = _available;\n                    _poolList[i].allocation = _allocation;\n                }\n            }\n        }\n        //Check pools that was not falling under the previous criteria, then adjust to meet the target credit allocation.\n        for (uint256 i = 0; i < _length; i++) {\n            if (_poolList[i].addr != address(0)) {\n                //Target credit allocation for a pool\n                uint256 _target = (_allocatable * _poolList[i].allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = _poolList[i].current;\n                //get how much liquidty is available to withdraw\n                uint256 _available = _poolList[i].available;\n                //Withdraw or Deposit credit\n                if (_current > _target && _available != 0) {\n                    //if allocated credit is higher than the target, try to decrease\n                    uint256 _decrease = _current - _target;\n                    IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);\n                    totalAllocatedCredit -= _decrease;\n                }\n                if (_current < _target) {\n                    //Sometimes we need to allocate more\n                    uint256 _allocate = _target - _current;\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);\n                    totalAllocatedCredit += _allocate;\n                }\n                if (_current == _target) {\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Make a payout if an accident occured in a underlying pool\n     * @param _amount amount of liquidity to compensate for the called pool\n     * We compensate underlying pools by the following steps\n     * 1) Compensate underlying pools from the liquidity of this pool\n     * 2) If this pool is unable to cover a compensation, can get compensated from the CDS pool\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(\n            allocPoints[msg.sender] > 0,\n            \"ERROR_COMPENSATE_UNAUTHORIZED_CALLER\"\n        );\n        uint256 _value = vault.underlyingValue(address(this));\n        if (_value >= _amount) {\n            //When the deposited value without earned premium is enough to cover\n            vault.offsetDebt(_amount, msg.sender);\n            //vault.transferValue(_amount, msg.sender);\n            _compensated = _amount;\n        } else {\n            //Withdraw credit to cashout the earnings\n            uint256 _shortage;\n            if (totalLiquidity() < _amount) {\n                //Insolvency case\n                _shortage = _amount - _value;\n                uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n                    .compensate(_shortage);\n                _compensated = _value + _cds;\n            }\n            vault.offsetDebt(_compensated, msg.sender);\n        }\n        adjustAlloc();\n        emit Compensated(msg.sender, _compensated);\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Resume market\n     */\n    function resume() external override {\n        uint256 _poolLength = poolList.length;\n\n        for (uint256 i = 0; i < _poolLength; i++) {\n            require(\n                IPoolTemplate(poolList[i]).paused() == false,\n                \"ERROR: POOL_IS_PAUSED\"\n            );\n        }\n\n        locked = false;\n        emit Resumed();\n    }\n\n    /**\n     * @notice lock market withdrawal\n     */\n    function lock() external override {\n        require(allocPoints[msg.sender] > 0);\n\n        locked = true;\n        emit Locked();\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice get the current leverage rate 1e6x\n     * @return _rate leverage rate\n     */\n    function leverage() public view returns (uint256 _rate) {\n        //check current leverage rate\n        if (totalLiquidity() > 0) {\n            return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance total liquidity of the pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this)) + _accruedPremiums();\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * totalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get all underlying pools\n     * @return pool array\n     */\n    function getAllPools() external view returns (address[] memory) {\n        return poolList;\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Change target leverate rate for this index x 1e6\n     * @param _target new leverage rate\n     */\n    function setLeverage(uint256 _target) external override onlyOwner {\n        targetLev = _target;\n        adjustAlloc();\n        emit LeverageSet(_target);\n    }\n\n    /**\n     * @notice Change allocation point for each pool\n     * @param _index target id of the underlying pool\n     * @param _pool address of pool\n     * @param _allocPoint new allocation point\n     */\n    function set(\n        uint256 _index,\n        address _pool,\n        uint256 _allocPoint\n    ) public override onlyOwner {\n        require(registry.isListed(_pool), \"ERROR:UNREGISTERED_POOL\");\n        require(\n            _index <= parameters.getMaxList(address(this)),\n            \"ERROR: EXCEEEDED_MAX_INDEX\"\n        );\n        uint256 _length = poolList.length;\n\n        //create a new pool or replace existing\n        if (_length <= _index) {\n            require(_length == _index, \"ERROR: BAD_INDEX\");\n            poolList.push(_pool);\n        } else {\n            address _poolAddress = poolList[_index];\n            if (_poolAddress != address(0) && _poolAddress != _pool) {\n                uint256 _current = IPoolTemplate(_poolAddress).allocatedCredit(\n                    address(this)\n                );\n                IPoolTemplate(_poolAddress).withdrawCredit(_current);\n            }\n            poolList[_index] = _pool;\n        }\n        if (totalAllocPoint > 0) {\n            totalAllocPoint =\n                totalAllocPoint -\n                allocPoints[_pool] +\n                _allocPoint;\n        } else {\n            totalAllocPoint = _allocPoint;\n        }\n        allocPoints[_pool] = _allocPoint;\n        adjustAlloc();\n        emit AllocationSet(_index, _pool, _allocPoint);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Get the total equivalent value of credit to token\n     * @return _totalValue accrued but yet claimed premium within underlying pools\n     */\n    function _accruedPremiums() internal view returns (uint256 _totalValue) {\n        for (uint256 i = 0; i < poolList.length; i++) {\n            if (allocPoints[poolList[i]] > 0) {\n                _totalValue =\n                    _totalValue +\n                    IPoolTemplate(poolList[i]).pendingPremium(address(this));\n            }\n        }\n    }\n}\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\ncontract Factory is IFactory {\n    event MarketCreated(\n        address indexed market,\n        address indexed template,\n        string _metaData,\n        uint256[] conditions,\n        address[] references\n    );\n    event TemplateApproval(\n        IUniversalMarket indexed template,\n        bool approval,\n        bool isOpen,\n        bool duplicate\n    );\n    event ReferenceApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        address target,\n        bool approval\n    );\n    event ConditionApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        uint256 target\n    );\n\n    address[] public markets;\n\n    struct Template {\n        bool isOpen; //true if the market allows anyone to create a market\n        bool approval; //true if the template exists\n        bool allowDuplicate; //true if the market with same ID is allowed\n    }\n    mapping(address => Template) public templates;\n    //mapping of authorized market template address\n\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        public reflist;\n    //Authorized reference(address) list for market market template\n    //Each template has different set of references\n    //true if that address is authorized within the template\n    // Example reference list for pool template v1\n    // references[0] = target governance token address\n    // references[1] = underlying token address\n    // references[2] = registry\n    // references[3] = parameter\n\n    mapping(address => mapping(uint256 => uint256)) public conditionlist;\n    //Authorized condition(uint256) list for market temaplate\n    //Each template has different set of conditions\n    //true if that address is authorized within the template\n    // Example condition list for pool template v1\n    // conditions[0] = minimim deposit amount\n\n    address public registry;\n    IOwnership public ownership;\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor(address _registry, address _ownership) {\n        registry = _registry;\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * @notice A function to approve or disapprove templates.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _approval true if a market is allowed to create based on the template\n     * @param _isOpen true if anyone can create a market based on the template\n     * @param _duplicate true if a market with duplicate target id is allowed\n     */\n    function approveTemplate(\n        IUniversalMarket _template,\n        bool _approval,\n        bool _isOpen,\n        bool _duplicate\n    ) external override onlyOwner {\n        require(address(_template) != address(0));\n        templates[address(_template)].approval = _approval;\n        templates[address(_template)].isOpen = _isOpen;\n        templates[address(_template)].allowDuplicate = _duplicate;\n        emit TemplateApproval(_template, _approval, _isOpen, _duplicate);\n    }\n\n    /**\n     * @notice A function to preset reference.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _slot the index within reference array\n     * @param _target the reference  address\n     * @param _approval true if the reference is approved\n     */\n    function approveReference(\n        IUniversalMarket _template,\n        uint256 _slot,\n        address _target,\n        bool _approval\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        reflist[address(_template)][_slot][_target] = _approval;\n        emit ReferenceApproval(_template, _slot, _target, _approval);\n    }\n\n    /**\n     * @notice A function to preset reference.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _slot the index within condition array\n     * @param _target the condition uint\n     */\n    function setCondition(\n        IUniversalMarket _template,\n        uint256 _slot,\n        uint256 _target\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        conditionlist[address(_template)][_slot] = _target;\n        emit ConditionApproval(_template, _slot, _target);\n    }\n\n    /**\n     * @notice A function to create markets.\n     * This function is market model agnostic.\n     * @param _template template address, which must be registered\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     * @return created market address\n     */\n    function createMarket(\n        IUniversalMarket _template,\n        string memory _metaData,\n        uint256[] memory _conditions,\n        address[] memory _references\n    ) public override returns (address) {\n        //check eligibility\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        if (templates[address(_template)].isOpen == false) {\n            require(\n                ownership.owner() == msg.sender,\n                \"ERROR: UNAUTHORIZED_SENDER\"\n            );\n        }\n        if (_references.length > 0) {\n            for (uint256 i = 0; i < _references.length; i++) {\n                require(\n                    reflist[address(_template)][i][_references[i]] == true ||\n                        reflist[address(_template)][i][address(0)] == true,\n                    \"ERROR: UNAUTHORIZED_REFERENCE\"\n                );\n            }\n        }\n\n        if (_conditions.length > 0) {\n            for (uint256 i = 0; i < _conditions.length; i++) {\n                if (conditionlist[address(_template)][i] > 0) {\n                    _conditions[i] = conditionlist[address(_template)][i];\n                }\n            }\n        }\n\n        if (\n            IRegistry(registry).confirmExistence(\n                address(_template),\n                _references[0]\n            ) == false\n        ) {\n            IRegistry(registry).setExistence(\n                address(_template),\n                _references[0]\n            );\n        } else {\n            if (templates[address(_template)].allowDuplicate == false) {\n                revert(\"ERROR: DUPLICATE_MARKET\");\n            }\n        }\n\n        //create market\n        IUniversalMarket market = IUniversalMarket(\n            _createClone(address(_template))\n        );\n\n        IRegistry(registry).supportMarket(address(market));\n        \n        markets.push(address(market));\n\n\n        //initialize\n        market.initialize(_metaData, _conditions, _references);\n\n        emit MarketCreated(\n            address(market),\n            address(_template),\n            _metaData,\n            _conditions,\n            _references\n        );\n\n        return address(market);\n    }\n\n    /**\n     * @notice Template Code for the create clone method:\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\n     */\n    function _createClone(address target) internal returns (address result) {\n        // convert address to bytes20 for assembly use\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            // allocate clone memory\n            let clone := mload(0x40)\n            // store initial portion of the delegation contract code in bytes form\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            // store the provided address\n            mstore(add(clone, 0x14), targetBytes)\n            // store the remaining delegation contract code\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            // create the actual delegate contract reference and return its address\n            result := create(0, clone, 0x37)\n        }\n    }\n}\ncontract BondingPremium is IPremiumModel {\n    using ABDKMath64x64 for uint256;\n    using ABDKMath64x64 for int128;\n\n    IOwnership public ownership;\n\n    //variables\n    uint256 public k; //final curve rate of the dynamic pricing\n    uint256 public c; //initial base fee\n    uint256 public b; //final base fee\n    uint256 public T_1; //goal TVL (USDC)\n\n    //constants\n    uint256 public constant DECIMAL = uint256(1e6); //Decimals of USDC\n    uint256 public constant BASE = uint256(1e6); //bonding curve graph takes 1e6 as 100.0000%\n    uint256 public constant BASE_x2 = uint256(1e12); //BASE^2\n    uint256 public constant ADJUSTER = uint256(10); //adjuster of 1e6 to 1e5 (100.0000% to 100.000%)\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor(address _ownership) {\n        ownership = IOwnership(_ownership);\n\n        //setPremium()\n        k = 200100000;\n        c = 10000;\n        b = 1000;\n        T_1 = 1000000 * DECIMAL;\n    }\n\n    /***\n     * References\n     * - Gitbook: https://app.gitbook.com/s/-Mb5ZmIrwF8VtxMhMijC/advanced/premium-pricing\n     * - Desmos: https://www.desmos.com/calculator/7pmqdvaj5o\n     */\n\n    /***\n     * @notice Get the current premium rate. 100% = 1e6\n     * @param _totalLiquidity total liquidity token amount in the insurance pool.\n     * @param _lockedAmount utilized token amount of the insurance pool.\n     */\n    function getCurrentPremiumRate(\n        uint256 _totalLiquidity,\n        uint256 _lockedAmount\n    ) public view override returns (uint256) {\n        require(\n            _totalLiquidity >= _lockedAmount,\n            \"ERROR: _lockedAmount > _totalLiquidity\"\n        );\n        // utilization rate (0~1000000)\n        uint256 _util = (_lockedAmount * BASE) / _totalLiquidity;\n\n        // yearly premium rate\n        uint256 _premiumRate;\n\n        uint256 T_0 = _totalLiquidity;\n        if (T_0 > T_1) {\n            T_0 = T_1;\n        }\n\n        uint256 a = (sqrt(\n            (BASE_x2 * BASE_x2 * T_1 + 4 * k * T_0 * BASE_x2) / T_1\n        ) - BASE_x2) / 2; //a*BASE (in calc)\n\n        uint256 Q = (BASE - _util) + a / BASE; //x+a (in calc)\n\n        _premiumRate =\n            365 *\n            (k * T_0 * BASE - a * Q * T_1) +\n            Q *\n            (c - b) *\n            (T_1 - T_0) *\n            BASE +\n            b *\n            Q *\n            T_1 *\n            BASE;\n\n        _premiumRate = _premiumRate / Q / T_1 / BASE;\n\n        //Return premium\n        return _premiumRate;\n    }\n\n    /***\n     * @notice Get premium rate.\n     * @param _amount  token amount of insurance be bought\n     * @param _totalLiquidity total liquidity token amount in the insurance pool.\n     * @param _lockedAmount utilized token amount of the insurance pool.\n     */\n    struct Temp {\n        int128 u;\n        int128 a;\n        int128 BASE_temp;\n    }\n\n    function getPremiumRate(\n        uint256 _amount,\n        uint256 _totalLiquidity,\n        uint256 _lockedAmount\n    ) public view override returns (uint256) {\n        require(\n            _amount + _lockedAmount <= _totalLiquidity,\n            \"exceed available balance\"\n        );\n\n        if (_totalLiquidity == 0 || _amount == 0) {\n            return 0;\n        }\n\n        uint256 u1 = BASE - ((_lockedAmount * BASE) / _totalLiquidity); //util rate before. 1000000 = 100.000%\n        uint256 u2 = BASE -\n            (((_lockedAmount + _amount) * BASE) / _totalLiquidity); //util rate after. 1000000 = 100.000%\n\n        uint256 T_0 = _totalLiquidity;\n        if (T_0 > T_1) {\n            T_0 = T_1;\n        }\n\n        uint256 a = (sqrt(\n            (BASE_x2 * BASE_x2 * T_1 + 4 * k * T_0 * BASE_x2) / T_1\n        ) - BASE_x2) / 2; //a*BASE (in calc)\n\n        Temp memory temp;\n        temp.a = a.fromUInt();\n        temp.BASE_temp = BASE.fromUInt();\n        temp.a = temp.a.div(temp.BASE_temp);\n\n        //calc 0=>u1 area\n        temp.u = u1.fromUInt();\n        int128 ln_u1 = (temp.u).add(temp.a).ln();\n        uint256 ln_res_u1 = ln_u1.mulu(k); //k*ln(x+a) //very percise.\n\n        uint256 _premium_u1 = (365 * T_0 * ln_res_u1 * BASE) +\n            u1 *\n            ((T_1 - T_0) * c * BASE + T_0 * b * BASE) -\n            T_1 *\n            365 *\n            a *\n            u1;\n\n        //calc 0=>u2 area\n        temp.u = u2.fromUInt();\n        int128 ln_u2 = (temp.u).add(temp.a).ln();\n        uint256 ln_res_u2 = ln_u2.mulu(k); //k*ln(x+a) //very percise.\n\n        uint256 _premium_u2 = (365 * T_0 * ln_res_u2 * BASE) +\n            u2 *\n            ((T_1 - T_0) * c * BASE + T_0 * b * BASE) -\n            T_1 *\n            365 *\n            a *\n            u2;\n\n        //(u1 area) - (u2 area) = premium rate between u1 and u2\n        uint256 premiumRate = _premium_u1 - _premium_u2;\n        premiumRate = premiumRate / T_1 / (u1 - u2) / BASE;\n\n        return premiumRate;\n    }\n\n    /***\n     * @notice Get premium. This returns token amount of premium buyer has to pay.\n     * @param _amount\n     * @param _term\n     * @param _totalLiquidity total liquidity token amount in the insurance pool.\n     * @param _lockedAmount utilized token amount of the insurance pool.\n     */\n    function getPremium(\n        uint256 _amount,\n        uint256 _term,\n        uint256 _totalLiquidity,\n        uint256 _lockedAmount\n    ) external view override returns (uint256) {\n        require(_amount + _lockedAmount <= _totalLiquidity, \"Amount exceeds.\");\n        require(_totalLiquidity != 0, \"_totalLiquidity cannnot be 0\");\n\n        if (_amount == 0) {\n            return 0;\n        }\n\n        uint256 premiumRate = getPremiumRate(\n            _amount,\n            _totalLiquidity,\n            _lockedAmount\n        );\n\n        uint256 premium = (_amount * premiumRate * _term) / 365 days / BASE;\n\n        return premium;\n    }\n\n    /**\n     * @notice Set a premium model\n     * @param _multiplierPerYear The curve rate of premium per year.\n     * @param _initialBaseRatePerYear The Initial Base rate addition to the bonding curve.\n     * @param _finalBaseRatePerYear The Final Base rate addition to the bonding curve.\n     * @param _goalTVL As TVL grows towards goalTVL, parameters gradually shift from initial to final value.\n     */\n    function setPremiumParameters(\n        uint256 _multiplierPerYear,\n        uint256 _initialBaseRatePerYear,\n        uint256 _finalBaseRatePerYear,\n        uint256 _goalTVL\n    ) external override onlyOwner {\n        require(\n            _multiplierPerYear != 0 &&\n                _initialBaseRatePerYear != 0 &&\n                _finalBaseRatePerYear != 0 &&\n                _goalTVL != 0,\n            \"ERROR_ZERO_VALUE_PROHIBITED\"\n        );\n        k = _multiplierPerYear;\n        c = _initialBaseRatePerYear;\n        b = _finalBaseRatePerYear;\n        T_1 = _goalTVL;\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\ncontract Registry is IRegistry {\n    event ExistenceSet(address indexed template, address indexed target);\n    event NewMarketRegistered(address market);\n    event FactorySet(address factory);\n    event CDSSet(address indexed target, address cds);\n\n    address public factory;\n\n    mapping(address => address) cds; //index => cds\n    mapping(address => bool) markets; //true if the market is registered\n    mapping(address => mapping(address => bool)) existence; //true if the certain id is already registered in market\n    address[] allMarkets;\n\n    IOwnership public ownership;\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor(address _ownership) {\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * @notice Set the factory address and allow it to regiser a new market\n     * @param _factory factory address\n     */\n    function setFactory(address _factory) external override onlyOwner {\n        require(_factory != address(0), \"ERROR: ZERO_ADDRESS\");\n\n        factory = _factory;\n        emit FactorySet(_factory);\n    }\n\n    /**\n     * @notice Register a new market.\n     * @param _market market address to register\n     */\n    function supportMarket(address _market) external override {\n        require(!markets[_market], \"ERROR: ALREADY_REGISTERED\");\n        require(\n            msg.sender == factory || msg.sender == ownership.owner(),\n            \"ERROR: UNAUTHORIZED_CALLER\"\n        );\n        require(_market != address(0), \"ERROR: ZERO_ADDRESS\");\n\n        allMarkets.push(_market);\n        markets[_market] = true;\n        emit NewMarketRegistered(_market);\n    }\n\n    /**\n     * @notice Register a new target address id and template address set.\n     * @param _template template address\n     * @param _target target address\n     */\n    function setExistence(address _template, address _target)\n        external\n        override\n    {\n        require(\n            msg.sender == factory || msg.sender == ownership.owner(),\n            \"ERROR: UNAUTHORIZED_CALLER\"\n        );\n\n        existence[_template][_target] = true;\n        emit ExistenceSet(_template, _target);\n    }\n\n    /**\n     * @notice Register the cds address for a particular address\n     * @param _address address to set CDS\n     * @param _cds CDS contract address\n     */\n    function setCDS(address _address, address _cds)\n        external\n        override\n        onlyOwner\n    {\n        require(_cds != address(0), \"ERROR: ZERO_ADDRESS\");\n\n        cds[_address] = _cds;\n        emit CDSSet(_address, _cds);\n    }\n\n    /**\n     * @notice Get the cds address for a particular address\n     * @param _address address covered by CDS\n     * @return true if the id within the market already exists\n     */\n    function getCDS(address _address) external view override returns (address) {\n        if (cds[_address] == address(0)) {\n            return cds[address(0)];\n        } else {\n            return cds[_address];\n        }\n    }\n\n    /**\n     * @notice Get whether the target address and id set exists\n     * @param _template template address\n     * @param _target target address\n     * @return true if the id within the market already exists\n     */\n    function confirmExistence(address _template, address _target)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return existence[_template][_target];\n    }\n\n    /**\n     * @notice Get whether market is registered\n     * @param _market market address to inquire\n     * @return true if listed\n     */\n    function isListed(address _market) external view override returns (bool) {\n        return markets[_market];\n    }\n\n    /**\n     * @notice Get all market\n     * @return all markets\n     */\n    function getAllMarkets() external view returns (address[] memory) {\n        return allMarkets;\n    }\n}\n",
    "bin": []
}