{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/73/protocol",
    "external_functions": [
        [
            "ServiceRegistry",
            "IController"
        ],
        [
            "BondingManager",
            "IController",
            "IRoundsManager",
            "IMinter",
            "IMerkleSnapshot",
            "ILivepeerToken"
        ],
        [
            "TicketBroker",
            "IMinter",
            "IBondingManager",
            "IRoundsManager",
            "IController"
        ],
        [
            "PollCreator",
            "ILivepeerToken"
        ],
        [
            "AdjustableRoundsManager",
            "IMinter",
            "IBondingManager",
            "IController"
        ],
        [
            "RoundsManager",
            "IController",
            "IMinter",
            "IBondingManager"
        ],
        [
            "MerkleSnapshot",
            "IController"
        ],
        [
            "IL1GatewayRouter"
        ],
        [
            "ArbitrumLivepeerToken",
            "IL1GatewayRouter"
        ],
        [
            "LivepeerToken"
        ],
        [
            "LivepeerTokenFaucet",
            "ILivepeerToken"
        ],
        [
            "Minter",
            "IController",
            "ILivepeerToken",
            "IMinter",
            "IBondingManager"
        ]
    ],
    "new_contract": "contract AdjustableRoundsManager is RoundsManager {\n    uint256 num;\n    bytes32 hash;\n\n    constructor(address _controller) public RoundsManager(_controller) {}\n\n    function setBlockNum(uint256 _num) external {\n        num = _num;\n    }\n\n    function setBlockHash(bytes32 _hash) external {\n        hash = _hash;\n    }\n\n    function mineBlocks(uint256 _blocks) external {\n        num += _blocks;\n    }\n\n    function blockNum() public view returns (uint256) {\n        return num;\n    }\n\n    function blockHash(uint256 _block) public view returns (bytes32) {\n        require(_block >= blockNum() - 256);\n\n        return hash;\n    }\n}\ncontract RoundsManager is ManagerProxyTarget, IRoundsManager {\n    using SafeMath for uint256;\n\n    // Round length in blocks\n    uint256 public roundLength;\n    // Lock period of a round as a % of round length\n    // Transcoders cannot join the transcoder pool or change their rates during the lock period at the end of a round\n    // The lock period provides delegators time to review transcoder information without changes\n    // # of blocks in the lock period = (roundLength * roundLockAmount) / PERC_DIVISOR\n    uint256 public roundLockAmount;\n    // Last initialized round. After first round, this is the last round during which initializeRound() was called\n    uint256 public lastInitializedRound;\n    // Round in which roundLength was last updated\n    uint256 public lastRoundLengthUpdateRound;\n    // Start block of the round in which roundLength was last updated\n    uint256 public lastRoundLengthUpdateStartBlock;\n\n    // Mapping round number => block hash for the round\n    mapping(uint256 => bytes32) internal _blockHashForRound;\n\n    // LIP Upgrade Rounds\n    // These can be used in conditionals to ensure backwards compatibility or skip such backwards compatibility logic\n    // in case 'currentRound' > LIP-X upgrade round\n    mapping(uint256 => uint256) public lipUpgradeRound; // mapping (LIP-number > round number)\n\n    /**\n     * @notice RoundsManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\n     * should be used to initialize state variables post-deployment:\n     * - setRoundLength()\n     * - setRoundLockAmount()\n     * @param _controller Address of Controller that this contract will be registered with\n     */\n    constructor(address _controller) public Manager(_controller) {}\n\n    /**\n     * @notice Set round length. Only callable by the controller owner\n     * @param _roundLength Round length in blocks\n     */\n    function setRoundLength(uint256 _roundLength) external onlyControllerOwner {\n        require(_roundLength > 0, \"round length cannot be 0\");\n\n        if (roundLength == 0) {\n            // If first time initializing roundLength, set roundLength before\n            // lastRoundLengthUpdateRound and lastRoundLengthUpdateStartBlock\n            roundLength = _roundLength;\n            lastRoundLengthUpdateRound = currentRound();\n            lastRoundLengthUpdateStartBlock = currentRoundStartBlock();\n        } else {\n            // If updating roundLength, set roundLength after\n            // lastRoundLengthUpdateRound and lastRoundLengthUpdateStartBlock\n            lastRoundLengthUpdateRound = currentRound();\n            lastRoundLengthUpdateStartBlock = currentRoundStartBlock();\n            roundLength = _roundLength;\n        }\n\n        emit ParameterUpdate(\"roundLength\");\n    }\n\n    /**\n     * @notice Set round lock amount. Only callable by the controller owner\n     * @param _roundLockAmount Round lock amount as a % of the number of blocks in a round\n     */\n    function setRoundLockAmount(uint256 _roundLockAmount) external onlyControllerOwner {\n        require(MathUtils.validPerc(_roundLockAmount), \"round lock amount must be a valid percentage\");\n\n        roundLockAmount = _roundLockAmount;\n\n        emit ParameterUpdate(\"roundLockAmount\");\n    }\n\n    /**\n     * @notice Initialize the current round. Called once at the start of any round\n     */\n    function initializeRound() external whenSystemNotPaused {\n        uint256 currRound = currentRound();\n\n        uint256 lip73Round = lipUpgradeRound[73];\n        require(lip73Round == 0 || currRound < lip73Round, \"cannot initialize past LIP-73 round\");\n\n        // Check if already called for the current round\n        require(lastInitializedRound < currRound, \"round already initialized\");\n\n        // Set current round as initialized\n        lastInitializedRound = currRound;\n        // Store block hash for round\n        bytes32 roundBlockHash = blockHash(blockNum().sub(1));\n        _blockHashForRound[currRound] = roundBlockHash;\n        // Set total active stake for the round\n        bondingManager().setCurrentRoundTotalActiveStake();\n        // Set mintable rewards for the round\n        minter().setCurrentRewardTokens();\n\n        emit NewRound(currRound, roundBlockHash);\n    }\n\n    /**\n     * @notice setLIPUpgradeRound sets the round an LIP upgrade would become active.\n     * @param _lip the LIP number.\n     * @param _round (optional) the round in which the LIP becomes active\n     */\n    function setLIPUpgradeRound(uint256 _lip, uint256 _round) external onlyControllerOwner {\n        require(lipUpgradeRound[_lip] == 0, \"LIP upgrade round already set\");\n        lipUpgradeRound[_lip] = _round;\n    }\n\n    /**\n     * @notice Return current block number\n     */\n    function blockNum() public view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Return blockhash for a block\n     */\n    function blockHash(uint256 _block) public view returns (bytes32) {\n        uint256 currentBlock = blockNum();\n        require(_block < currentBlock, \"can only retrieve past block hashes\");\n        require(currentBlock < 256 || _block >= currentBlock - 256, \"can only retrieve hashes for last 256 blocks\");\n\n        return blockhash(_block);\n    }\n\n    /**\n     * @notice Return blockhash for a round\n     * @param _round Round number\n     * @return Blockhash for `_round`\n     */\n    function blockHashForRound(uint256 _round) public view returns (bytes32) {\n        return _blockHashForRound[_round];\n    }\n\n    /**\n     * @notice Return current round\n     */\n    function currentRound() public view returns (uint256) {\n        // Compute # of rounds since roundLength was last updated\n        uint256 roundsSinceUpdate = blockNum().sub(lastRoundLengthUpdateStartBlock).div(roundLength);\n        // Current round = round that roundLength was last updated + # of rounds since roundLength was last updated\n        return lastRoundLengthUpdateRound.add(roundsSinceUpdate);\n    }\n\n    /**\n     * @notice Return start block of current round\n     */\n    function currentRoundStartBlock() public view returns (uint256) {\n        // Compute # of rounds since roundLength was last updated\n        uint256 roundsSinceUpdate = blockNum().sub(lastRoundLengthUpdateStartBlock).div(roundLength);\n        // Current round start block = start block of round that roundLength was last updated + (# of rounds since roundLenght was last updated * roundLength)\n        return lastRoundLengthUpdateStartBlock.add(roundsSinceUpdate.mul(roundLength));\n    }\n\n    /**\n     * @notice Check if current round is initialized\n     */\n    function currentRoundInitialized() public view returns (bool) {\n        return lastInitializedRound == currentRound();\n    }\n\n    /**\n     * @notice Check if we are in the lock period of the current round\n     */\n    function currentRoundLocked() public view returns (bool) {\n        uint256 lockedBlocks = MathUtils.percOf(roundLength, roundLockAmount);\n        return blockNum().sub(currentRoundStartBlock()) >= roundLength.sub(lockedBlocks);\n    }\n\n    /**\n     * @dev Return BondingManager interface\n     */\n    function bondingManager() internal view returns (IBondingManager) {\n        return IBondingManager(controller.getContract(keccak256(\"BondingManager\")));\n    }\n\n    /**\n     * @dev Return Minter interface\n     */\n    function minter() internal view returns (IMinter) {\n        return IMinter(controller.getContract(keccak256(\"Minter\")));\n    }\n}\ncontract MContractRegistry {\n    /**\n     * @notice Checks if the system is paused\n     * @dev Executes the 'whenSystemNotPaused' modifier 'MixinContractRegistry' inherits from 'Manager.sol'\n     */\n    modifier whenSystemNotPaused() {\n        _;\n    }\n\n    /**\n     * @notice Checks if the current round has been initialized\n     * @dev Executes the 'currentRoundInitialized' modifier in 'MixinContractRegistry'\n     */\n    modifier currentRoundInitialized() {\n        _;\n    }\n\n    /**\n     * @dev Returns an instance of the IBondingManager interface\n     */\n    function bondingManager() internal view returns (IBondingManager);\n\n    /**\n     * @dev Returns an instance of the IMinter interface\n     */\n    function minter() internal view returns (IMinter);\n\n    /**\n     * @dev Returns an instance of the IRoundsManager interface\n     */\n    function roundsManager() internal view returns (IRoundsManager);\n}\ncontract PollCreator {\n    // 33.33%\n    uint256 public constant QUORUM = 333300;\n    // 50%\n    uint256 public constant QUOTA = 500000;\n    // 10 rounds\n    uint256 public constant POLL_PERIOD = 10 * 5760;\n    uint256 public constant POLL_CREATION_COST = 100 * 1 ether;\n\n    ILivepeerToken public token;\n\n    event PollCreated(address indexed poll, bytes proposal, uint256 endBlock, uint256 quorum, uint256 quota);\n\n    constructor(address _tokenAddr) public {\n        token = ILivepeerToken(_tokenAddr);\n    }\n\n    /**\n     * @dev Create a poll by burning POLL_CREATION_COST LPT.\n     *      Reverts if this contract's LPT allowance for the sender < POLL_CREATION_COST.\n     * @param _proposal The IPFS multihash for the proposal.\n     */\n    function createPoll(bytes calldata _proposal) external {\n        uint256 endBlock = block.number + POLL_PERIOD;\n        Poll poll = new Poll(endBlock);\n\n        require(token.transferFrom(msg.sender, address(this), POLL_CREATION_COST), \"LivepeerToken transferFrom failed\");\n\n        token.burn(POLL_CREATION_COST);\n\n        emit PollCreated(address(poll), _proposal, endBlock, QUORUM, QUOTA);\n    }\n}\ncontract IManager {\n    event SetController(address controller);\n    event ParameterUpdate(string param);\n\n    function setController(address _controller) external;\n}\ncontract LivepeerTokenFaucet is Ownable {\n    // Token\n    ILivepeerToken public token;\n\n    // Amount of token sent to sender for a request\n    uint256 public requestAmount;\n\n    // Amount of time a sender must wait between requests\n    uint256 public requestWait;\n\n    // sender => timestamp at which sender can make another request\n    mapping(address => uint256) public nextValidRequest;\n\n    // Whitelist addresses that can bypass faucet request rate limit\n    mapping(address => bool) public isWhitelisted;\n\n    // Checks if a request is valid (sender is whitelisted or has waited the rate limit time)\n    modifier validRequest() {\n        require(isWhitelisted[msg.sender] || block.timestamp >= nextValidRequest[msg.sender]);\n        _;\n    }\n\n    event Request(address indexed to, uint256 amount);\n\n    /**\n     * @notice LivepeerTokenFacuet constructor\n     * @param _token Address of LivepeerToken\n     * @param _requestAmount Amount of token sent to sender for a request\n     * @param _requestWait Amount of time a sender must wait between request (denominated in hours)\n     */\n    constructor(\n        address _token,\n        uint256 _requestAmount,\n        uint256 _requestWait\n    ) public {\n        token = ILivepeerToken(_token);\n        requestAmount = _requestAmount;\n        requestWait = _requestWait;\n    }\n\n    /**\n     * @notice Add an address to the whitelist\n     * @param _addr Address to be whitelisted\n     */\n    function addToWhitelist(address _addr) external onlyOwner {\n        isWhitelisted[_addr] = true;\n    }\n\n    /**\n     * @notice Remove an address from the whitelist\n     * @param _addr Address to be removed from whitelist\n     */\n    function removeFromWhitelist(address _addr) external onlyOwner {\n        isWhitelisted[_addr] = false;\n    }\n\n    /**\n     * @notice Request an amount of token to be sent to sender\n     */\n    function request() external validRequest {\n        if (!isWhitelisted[msg.sender]) {\n            nextValidRequest[msg.sender] = block.timestamp + requestWait * 1 hours;\n        }\n\n        token.transfer(msg.sender, requestAmount);\n\n        emit Request(msg.sender, requestAmount);\n    }\n}\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\ncontract VariableSupplyToken is MintableToken {\n    event Burn(address indexed burner, uint256 value);\n\n    /**\n     * @dev Burns a specific amount of the sender's tokens\n     * @param _amount The amount of tokens to be burned\n     */\n    function burn(uint256 _amount) public {\n        _burn(msg.sender, _amount);\n        emit Burn(msg.sender, _amount);\n    }\n}\ncontract ServiceRegistry is ManagerProxyTarget {\n    // Store service metadata\n    struct Record {\n        string serviceURI; // Service URI endpoint that can be used to send off-chain requests\n    }\n\n    // Track records for addresses\n    mapping(address => Record) private records;\n\n    // Event fired when a caller updates its service URI endpoint\n    event ServiceURIUpdate(address indexed addr, string serviceURI);\n\n    /**\n     * @notice ServiceRegistry constructor. Only invokes constructor of base Manager contract with provided Controller address\n     * @param _controller Address of a Controller that this contract will be registered with\n     */\n    constructor(address _controller) public Manager(_controller) {}\n\n    /**\n     * @notice Stores service URI endpoint for the caller that can be used to send requests to the caller off-chain\n     * @param _serviceURI Service URI endpoint for the caller\n     */\n    function setServiceURI(string calldata _serviceURI) external {\n        records[msg.sender].serviceURI = _serviceURI;\n\n        emit ServiceURIUpdate(msg.sender, _serviceURI);\n    }\n\n    /**\n     * @notice Returns service URI endpoint stored for a given address\n     * @param _addr Address for which a service URI endpoint is desired\n     */\n    function getServiceURI(address _addr) public view returns (string memory) {\n        return records[_addr].serviceURI;\n    }\n}\ncontract ILivepeerToken is ERC20, Ownable {\n    function mint(address _to, uint256 _amount) public returns (bool);\n\n    function burn(uint256 _amount) public;\n}\ncontract IRoundsManager {\n    // Events\n    event NewRound(uint256 indexed round, bytes32 blockHash);\n\n    // Deprecated events\n    // These event signatures can be used to construct the appropriate topic hashes to filter for past logs corresponding\n    // to these deprecated events.\n    // event NewRound(uint256 round)\n\n    // External functions\n    function initializeRound() external;\n\n    function lipUpgradeRound(uint256 _lip) external view returns (uint256);\n\n    // Public functions\n    function blockNum() public view returns (uint256);\n\n    function blockHash(uint256 _block) public view returns (bytes32);\n\n    function blockHashForRound(uint256 _round) public view returns (bytes32);\n\n    function currentRound() public view returns (uint256);\n\n    function currentRoundStartBlock() public view returns (uint256);\n\n    function currentRoundInitialized() public view returns (bool);\n\n    function currentRoundLocked() public view returns (bool);\n}\ncontract MTicketProcessor {\n    /**\n     * @dev Process sent funds.\n     * @param _amount Amount of funds sent\n     */\n    function processFunding(uint256 _amount) internal;\n\n    /**\n     * @dev Transfer withdrawal funds for a ticket sender\n     * @param _amount Amount of withdrawal funds\n     */\n    function withdrawTransfer(address payable _sender, uint256 _amount) internal;\n\n    /**\n     * @dev Transfer funds for a recipient's winning ticket\n     * @param _recipient Address of recipient\n     * @param _amount Amount of funds for the winning ticket\n     * @param _auxData Auxilary data for the winning ticket\n     */\n    function winningTicketTransfer(\n        address _recipient,\n        uint256 _amount,\n        bytes memory _auxData\n    ) internal;\n\n    /**\n     * @dev Validates a ticket's auxilary data (succeeds or reverts)\n     * @param _auxData Auxilary data inclueded in a ticket\n     */\n    function requireValidTicketAuxData(bytes memory _auxData) internal view;\n}\ncontract IMinter {\n    // Events\n    event SetCurrentRewardTokens(uint256 currentMintableTokens, uint256 currentInflation);\n\n    // External functions\n    function createReward(uint256 _fracNum, uint256 _fracDenom) external returns (uint256);\n\n    function trustedTransferTokens(address _to, uint256 _amount) external;\n\n    function trustedBurnTokens(uint256 _amount) external;\n\n    function trustedWithdrawETH(address payable _to, uint256 _amount) external;\n\n    function depositETH() external payable returns (bool);\n\n    function setCurrentRewardTokens() external;\n\n    function currentMintableTokens() external view returns (uint256);\n\n    function currentMintedTokens() external view returns (uint256);\n\n    // Public functions\n    function getController() public view returns (IController);\n}\ncontract ManagerProxyTarget is Manager {\n    // Used to look up target contract address in controller's registry\n    bytes32 public targetContractId;\n}\ncontract MixinReserve is MContractRegistry, MReserve {\n    using SafeMath for uint256;\n\n    struct Reserve {\n        uint256 funds; // Amount of funds in the reserve\n        mapping(uint256 => uint256) claimedForRound; // Mapping of round => total amount claimed\n        mapping(uint256 => mapping(address => uint256)) claimedByAddress; // Mapping of round => claimant address => amount claimed\n    }\n\n    // Mapping of address => reserve\n    mapping(address => Reserve) internal reserves;\n\n    /**\n     * @dev Returns info about a reserve\n     * @param _reserveHolder Address of reserve holder\n     * @return Info about the reserve for `_reserveHolder`\n     */\n    function getReserveInfo(address _reserveHolder) public view returns (ReserveInfo memory info) {\n        info.fundsRemaining = remainingReserve(_reserveHolder);\n        info.claimedInCurrentRound = reserves[_reserveHolder].claimedForRound[roundsManager().currentRound()];\n    }\n\n    /**\n     * @dev Returns the amount of funds claimable by a claimant from a reserve in the current round\n     * @param _reserveHolder Address of reserve holder\n     * @param _claimant Address of claimant\n     * @return Amount of funds claimable by `_claimant` from the reserve for `_reserveHolder` in the current round\n     */\n    function claimableReserve(address _reserveHolder, address _claimant) public view returns (uint256) {\n        Reserve storage reserve = reserves[_reserveHolder];\n\n        uint256 currentRound = roundsManager().currentRound();\n\n        if (!bondingManager().isActiveTranscoder(_claimant)) {\n            return 0;\n        }\n\n        uint256 poolSize = bondingManager().getTranscoderPoolSize();\n        if (poolSize == 0) {\n            return 0;\n        }\n\n        // Total claimable funds = remaining funds + amount claimed for the round\n        uint256 totalClaimable = reserve.funds.add(reserve.claimedForRound[currentRound]);\n        return totalClaimable.div(poolSize).sub(reserve.claimedByAddress[currentRound][_claimant]);\n    }\n\n    /**\n     * @dev Returns the amount of funds claimed by a claimant from a reserve in the current round\n     * @param _reserveHolder Address of reserve holder\n     * @param _claimant Address of claimant\n     * @return Amount of funds claimed by `_claimant` from the reserve for `_reserveHolder` in the current round\n     */\n    function claimedReserve(address _reserveHolder, address _claimant) public view returns (uint256) {\n        Reserve storage reserve = reserves[_reserveHolder];\n        uint256 currentRound = roundsManager().currentRound();\n        return reserve.claimedByAddress[currentRound][_claimant];\n    }\n\n    /**\n     * @dev Adds funds to a reserve\n     * @param _reserveHolder Address of reserve holder\n     * @param _amount Amount of funds to add to reserve\n     */\n    function addReserve(address _reserveHolder, uint256 _amount) internal {\n        reserves[_reserveHolder].funds = reserves[_reserveHolder].funds.add(_amount);\n\n        emit ReserveFunded(_reserveHolder, _amount);\n    }\n\n    /**\n     * @dev Clears contract storage used for a reserve\n     * @param _reserveHolder Address of reserve holder\n     */\n    function clearReserve(address _reserveHolder) internal {\n        // This delete operation will only clear reserve.funds and will not clear the storage for reserve.claimedForRound\n        // reserve.claimedByAddress because these fields are mappings and the Solidity `delete` keyword will not modify mappings.\n        // This *could* be a problem in the following scenario:\n        //\n        // 1) In round N, for address A, reserve.claimedForRound[N] > 0 and reserve.claimedByAddress[N][r_i] > 0 where r_i is\n        // a member of the active set in round N\n        // 2) This function is called by MixinTicketBrokerCore.withdraw() in round N\n        // 3) Address A funds its reserve again\n        //\n        // After step 3, A has reserve.funds > 0, reserve.claimedForRound[N] > 0 and reserve.claimedByAddress[N][r_i] > 0\n        // despite having funded a fresh reserve after previously withdrawing all of its funds in the same round.\n        // We prevent this scenario by disallowing reserve claims starting at an address' withdraw round in\n        // MixinTicketBrokerCore.redeemWinningTicket()\n        delete reserves[_reserveHolder];\n    }\n\n    /**\n     * @dev Claims funds from a reserve\n     * @param _reserveHolder Address of reserve holder\n     * @param _claimant Address of claimant\n     * @param _amount Amount of funds to claim from the reserve\n     * @return Amount of funds (<= `_amount`) claimed by `_claimant` from the reserve for `_reserveHolder`\n     */\n    function claimFromReserve(\n        address _reserveHolder,\n        address _claimant,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 claimableFunds = claimableReserve(_reserveHolder, _claimant);\n        // If the given amount > claimableFunds then claim claimableFunds\n        // If the given amount <= claimableFunds then claim the given amount\n        uint256 claimAmount = _amount > claimableFunds ? claimableFunds : _amount;\n\n        if (claimAmount > 0) {\n            uint256 currentRound = roundsManager().currentRound();\n            Reserve storage reserve = reserves[_reserveHolder];\n            // Increase total amount claimed for the round\n            reserve.claimedForRound[currentRound] = reserve.claimedForRound[currentRound].add(claimAmount);\n            // Increase amount claimed by claimant for the round\n            reserve.claimedByAddress[currentRound][_claimant] = reserve.claimedByAddress[currentRound][_claimant].add(\n                claimAmount\n            );\n            // Decrease remaining reserve\n            reserve.funds = reserve.funds.sub(claimAmount);\n\n            emit ReserveClaimed(_reserveHolder, _claimant, claimAmount);\n        }\n\n        return claimAmount;\n    }\n\n    /**\n     * @dev Returns the amount of funds remaining in a reserve\n     * @param _reserveHolder Address of reserve holder\n     * @return Amount of funds remaining in the reserve for `_reserveHolder`\n     */\n    function remainingReserve(address _reserveHolder) internal view returns (uint256) {\n        return reserves[_reserveHolder].funds;\n    }\n}\ncontract MixinTicketProcessor is MContractRegistry, MTicketProcessor {\n    using SafeMath for uint256;\n\n    // Number of rounds that a ticket is valid for starting from\n    // its creationRound\n    uint256 public ticketValidityPeriod;\n\n    /**\n     * @dev Process sent funds.\n     * @param _amount Amount of funds sent\n     */\n    function processFunding(uint256 _amount) internal {\n        // Send funds to Minter\n        minter().depositETH.value(_amount)();\n    }\n\n    /**\n     * @dev Transfer withdrawal funds for a ticket sender\n     * @param _amount Amount of withdrawal funds\n     */\n    function withdrawTransfer(address payable _sender, uint256 _amount) internal {\n        // Ask Minter to send withdrawal funds to the ticket sender\n        minter().trustedWithdrawETH(_sender, _amount);\n    }\n\n    /**\n     * @dev Transfer funds for a recipient's winning ticket\n     * @param _recipient Address of recipient\n     * @param _amount Amount of funds for the winning ticket\n     * @param _auxData Auxilary data for the winning ticket\n     */\n    function winningTicketTransfer(\n        address _recipient,\n        uint256 _amount,\n        bytes memory _auxData\n    ) internal {\n        (uint256 creationRound, ) = getCreationRoundAndBlockHash(_auxData);\n\n        // Ask BondingManager to update fee pool for recipient with\n        // winning ticket funds\n        bondingManager().updateTranscoderWithFees(_recipient, _amount, creationRound);\n    }\n\n    /**\n     * @dev Validates a ticket's auxilary data (succeeds or reverts)\n     * @param _auxData Auxilary data inclueded in a ticket\n     */\n    function requireValidTicketAuxData(bytes memory _auxData) internal view {\n        (uint256 creationRound, bytes32 creationRoundBlockHash) = getCreationRoundAndBlockHash(_auxData);\n        bytes32 blockHash = roundsManager().blockHashForRound(creationRound);\n\n        require(blockHash != bytes32(0), \"ticket creationRound does not have a block hash\");\n        require(creationRoundBlockHash == blockHash, \"ticket creationRoundBlockHash invalid for creationRound\");\n\n        uint256 currRound = roundsManager().currentRound();\n\n        require(creationRound.add(ticketValidityPeriod) > currRound, \"ticket is expired\");\n    }\n\n    /**\n     * @dev Returns a ticket's creationRound and creationRoundBlockHash parsed from ticket auxilary data\n     * @param _auxData Auxilary data for a ticket\n     * @return creationRound and creationRoundBlockHash parsed from `_auxData`\n     */\n    function getCreationRoundAndBlockHash(bytes memory _auxData)\n        internal\n        pure\n        returns (uint256 creationRound, bytes32 creationRoundBlockHash)\n    {\n        require(_auxData.length == 64, \"invalid length for ticket auxData: must be 64 bytes\");\n\n        // _auxData format:\n        // Bytes [0:31] = creationRound\n        // Bytes [32:63] = creationRoundBlockHash\n        assembly {\n            creationRound := mload(add(_auxData, 32))\n            creationRoundBlockHash := mload(add(_auxData, 64))\n        }\n    }\n}\ncontract MixinTicketBrokerCore is MContractRegistry, MReserve, MTicketProcessor, MTicketBrokerCore {\n    using SafeMath for uint256;\n\n    struct Sender {\n        uint256 deposit; // Amount of funds deposited\n        uint256 withdrawRound; // Round that sender can withdraw deposit & reserve\n    }\n\n    // Mapping of address => Sender\n    mapping(address => Sender) internal senders;\n\n    // Number of rounds before a sender can withdraw after requesting an unlock\n    uint256 public unlockPeriod;\n\n    // Mapping of ticket hashes => boolean indicating if ticket was redeemed\n    mapping(bytes32 => bool) public usedTickets;\n\n    // Checks if msg.value is equal to the given deposit and reserve amounts\n    modifier checkDepositReserveETHValueSplit(uint256 _depositAmount, uint256 _reserveAmount) {\n        require(\n            msg.value == _depositAmount.add(_reserveAmount),\n            \"msg.value does not equal sum of deposit amount and reserve amount\"\n        );\n\n        _;\n    }\n\n    // Process deposit funding\n    modifier processDeposit(address _sender, uint256 _amount) {\n        Sender storage sender = senders[_sender];\n        sender.deposit = sender.deposit.add(_amount);\n        if (_isUnlockInProgress(sender)) {\n            _cancelUnlock(sender, _sender);\n        }\n\n        _;\n\n        emit DepositFunded(_sender, _amount);\n    }\n\n    // Process reserve funding\n    modifier processReserve(address _sender, uint256 _amount) {\n        Sender storage sender = senders[_sender];\n        addReserve(_sender, _amount);\n        if (_isUnlockInProgress(sender)) {\n            _cancelUnlock(sender, _sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Adds ETH to the caller's deposit\n     */\n    function fundDeposit() external payable whenSystemNotPaused processDeposit(msg.sender, msg.value) {\n        processFunding(msg.value);\n    }\n\n    /**\n     * @notice Adds ETH to the caller's reserve\n     */\n    function fundReserve() external payable whenSystemNotPaused processReserve(msg.sender, msg.value) {\n        processFunding(msg.value);\n    }\n\n    /**\n     * @notice Adds ETH to the caller's deposit and reserve\n     * @param _depositAmount Amount of ETH to add to the caller's deposit\n     * @param _reserveAmount Amount of ETH to add to the caller's reserve\n     */\n    function fundDepositAndReserve(uint256 _depositAmount, uint256 _reserveAmount)\n        external\n        payable\n        whenSystemNotPaused\n        checkDepositReserveETHValueSplit(_depositAmount, _reserveAmount)\n        processDeposit(msg.sender, _depositAmount)\n        processReserve(msg.sender, _reserveAmount)\n    {\n        processFunding(msg.value);\n    }\n\n    /**\n     * @notice Redeems a winning ticket that has been signed by a sender and reveals the\n     recipient recipientRand that corresponds to the recipientRandHash included in the ticket\n     * @param _ticket Winning ticket to be redeemed in order to claim payment\n     * @param _sig Sender's signature over the hash of `_ticket`\n     * @param _recipientRand The preimage for the recipientRandHash included in `_ticket`\n     */\n    function redeemWinningTicket(\n        Ticket memory _ticket,\n        bytes memory _sig,\n        uint256 _recipientRand\n    ) public whenSystemNotPaused currentRoundInitialized {\n        bytes32 ticketHash = getTicketHash(_ticket);\n\n        // Require a valid winning ticket for redemption\n        requireValidWinningTicket(_ticket, ticketHash, _sig, _recipientRand);\n\n        Sender storage sender = senders[_ticket.sender];\n\n        // Require sender to be locked\n        require(isLocked(sender), \"sender is unlocked\");\n        // Require either a non-zero deposit or non-zero reserve for the sender\n        require(sender.deposit > 0 || remainingReserve(_ticket.sender) > 0, \"sender deposit and reserve are zero\");\n\n        // Mark ticket as used to prevent replay attacks involving redeeming\n        // the same winning ticket multiple times\n        usedTickets[ticketHash] = true;\n\n        uint256 amountToTransfer = 0;\n\n        if (_ticket.faceValue > sender.deposit) {\n            // If ticket face value > sender's deposit then claim from\n            // the sender's reserve\n\n            amountToTransfer = sender.deposit.add(\n                claimFromReserve(_ticket.sender, _ticket.recipient, _ticket.faceValue.sub(sender.deposit))\n            );\n\n            sender.deposit = 0;\n        } else {\n            // If ticket face value <= sender's deposit then only deduct\n            // from sender's deposit\n\n            amountToTransfer = _ticket.faceValue;\n            sender.deposit = sender.deposit.sub(_ticket.faceValue);\n        }\n\n        if (amountToTransfer > 0) {\n            winningTicketTransfer(_ticket.recipient, amountToTransfer, _ticket.auxData);\n\n            emit WinningTicketTransfer(_ticket.sender, _ticket.recipient, amountToTransfer);\n        }\n\n        emit WinningTicketRedeemed(\n            _ticket.sender,\n            _ticket.recipient,\n            _ticket.faceValue,\n            _ticket.winProb,\n            _ticket.senderNonce,\n            _recipientRand,\n            _ticket.auxData\n        );\n    }\n\n    /**\n     * @notice Initiates the unlock period for the caller\n     */\n    function unlock() public whenSystemNotPaused {\n        Sender storage sender = senders[msg.sender];\n\n        require(sender.deposit > 0 || remainingReserve(msg.sender) > 0, \"sender deposit and reserve are zero\");\n        require(!_isUnlockInProgress(sender), \"unlock already initiated\");\n\n        uint256 currentRound = roundsManager().currentRound();\n        sender.withdrawRound = currentRound.add(unlockPeriod);\n\n        emit Unlock(msg.sender, currentRound, sender.withdrawRound);\n    }\n\n    /**\n     * @notice Cancels the unlock period for the caller\n     */\n    function cancelUnlock() public whenSystemNotPaused {\n        Sender storage sender = senders[msg.sender];\n\n        _cancelUnlock(sender, msg.sender);\n    }\n\n    /**\n     * @notice Withdraws all ETH from the caller's deposit and reserve\n     */\n    function withdraw() public whenSystemNotPaused {\n        Sender storage sender = senders[msg.sender];\n\n        uint256 deposit = sender.deposit;\n        uint256 reserve = remainingReserve(msg.sender);\n\n        require(deposit > 0 || reserve > 0, \"sender deposit and reserve are zero\");\n        require(_isUnlockInProgress(sender), \"no unlock request in progress\");\n        require(!isLocked(sender), \"account is locked\");\n\n        sender.deposit = 0;\n        clearReserve(msg.sender);\n\n        withdrawTransfer(msg.sender, deposit.add(reserve));\n\n        emit Withdrawal(msg.sender, deposit, reserve);\n    }\n\n    /**\n     * @notice Returns whether a sender is currently in the unlock period\n     * @param _sender Address of sender\n     * @return Boolean indicating whether `_sender` has an unlock in progress\n     */\n    function isUnlockInProgress(address _sender) public view returns (bool) {\n        Sender memory sender = senders[_sender];\n        return _isUnlockInProgress(sender);\n    }\n\n    /**\n     * @notice Returns info about a sender\n     * @param _sender Address of sender\n     * @return Info about the sender for `_sender`\n     */\n    function getSenderInfo(address _sender) public view returns (Sender memory sender, ReserveInfo memory reserve) {\n        sender = senders[_sender];\n        reserve = getReserveInfo(_sender);\n    }\n\n    /**\n     * @dev Returns the hash of a ticket\n     * @param _ticket Ticket to be hashed\n     * @return keccak256 hash of `_ticket`\n     */\n    function getTicketHash(Ticket memory _ticket) public pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    _ticket.recipient,\n                    _ticket.sender,\n                    _ticket.faceValue,\n                    _ticket.winProb,\n                    _ticket.senderNonce,\n                    _ticket.recipientRandHash,\n                    _ticket.auxData\n                )\n            );\n    }\n\n    /**\n     * @dev Helper to cancel an unlock\n     * @param _sender Sender that is cancelling an unlock\n     * @param _senderAddress Address of sender\n     */\n    function _cancelUnlock(Sender storage _sender, address _senderAddress) internal {\n        require(_isUnlockInProgress(_sender), \"no unlock request in progress\");\n\n        _sender.withdrawRound = 0;\n\n        emit UnlockCancelled(_senderAddress);\n    }\n\n    /**\n     * @dev Validates a winning ticket, succeeds or reverts\n     * @param _ticket Winning ticket to be validated\n     * @param _ticketHash Hash of `_ticket`\n     * @param _sig Sender's signature over `_ticketHash`\n     * @param _recipientRand The preimage for the recipientRandHash included in `_ticket`\n     */\n    function requireValidWinningTicket(\n        Ticket memory _ticket,\n        bytes32 _ticketHash,\n        bytes memory _sig,\n        uint256 _recipientRand\n    ) internal view {\n        require(_ticket.recipient != address(0), \"ticket recipient is null address\");\n        require(_ticket.sender != address(0), \"ticket sender is null address\");\n\n        requireValidTicketAuxData(_ticket.auxData);\n\n        require(\n            keccak256(abi.encodePacked(_recipientRand)) == _ticket.recipientRandHash,\n            \"recipientRand does not match recipientRandHash\"\n        );\n\n        require(!usedTickets[_ticketHash], \"ticket is used\");\n\n        require(isValidTicketSig(_ticket.sender, _sig, _ticketHash), \"invalid signature over ticket hash\");\n\n        require(isWinningTicket(_sig, _recipientRand, _ticket.winProb), \"ticket did not win\");\n    }\n\n    /**\n     * @dev Returns whether a sender is locked\n     * @param _sender Sender to check for locked status\n     * @return Boolean indicating whether sender is currently locked\n     */\n    function isLocked(Sender memory _sender) internal view returns (bool) {\n        return _sender.withdrawRound == 0 || roundsManager().currentRound() < _sender.withdrawRound;\n    }\n\n    /**\n     * @dev Returns whether a signature over a ticket hash is valid for a sender\n     * @param _sender Address of sender\n     * @param _sig Signature over `_ticketHash`\n     * @param _ticketHash Hash of the ticket\n     * @return Boolean indicating whether `_sig` is valid signature over `_ticketHash` for `_sender`\n     */\n    function isValidTicketSig(\n        address _sender,\n        bytes memory _sig,\n        bytes32 _ticketHash\n    ) internal pure returns (bool) {\n        address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(_ticketHash), _sig);\n        return signer != address(0) && _sender == signer;\n    }\n\n    /**\n     * @dev Returns whether a ticket won\n     * @param _sig Sender's signature over the ticket\n     * @param _recipientRand The preimage for the recipientRandHash included in the ticket\n     * @param _winProb The winning probability of the ticket\n     * @return Boolean indicating whether the ticket won\n     */\n    function isWinningTicket(\n        bytes memory _sig,\n        uint256 _recipientRand,\n        uint256 _winProb\n    ) internal pure returns (bool) {\n        return uint256(keccak256(abi.encodePacked(_sig, _recipientRand))) < _winProb;\n    }\n\n    /**\n     * @dev Helper to check if a sender is currently in the unlock period\n     * @param _sender Sender to check for an unlock\n     * @return Boolean indicating whether the sender is currently in the unlock period\n     */\n    function _isUnlockInProgress(Sender memory _sender) internal pure returns (bool) {\n        return _sender.withdrawRound > 0;\n    }\n}\ncontract IMerkleSnapshot {\n    function verify(\n        bytes32 _id,\n        bytes32[] calldata _proof,\n        bytes32 _leaf\n    ) external view returns (bool);\n}\ncontract Minter is Manager, IMinter {\n    using SafeMath for uint256;\n\n    // Per round inflation rate\n    uint256 public inflation;\n    // Change in inflation rate per round until the target bonding rate is achieved\n    uint256 public inflationChange;\n    // Target bonding rate\n    uint256 public targetBondingRate;\n\n    // Current number of mintable tokens. Reset every round\n    uint256 public currentMintableTokens;\n    // Current number of minted tokens. Reset every round\n    uint256 public currentMintedTokens;\n\n    // Checks if caller is BondingManager\n    modifier onlyBondingManager() {\n        require(msg.sender == controller.getContract(keccak256(\"BondingManager\")), \"msg.sender not BondingManager\");\n        _;\n    }\n\n    // Checks if caller is RoundsManager\n    modifier onlyRoundsManager() {\n        require(msg.sender == controller.getContract(keccak256(\"RoundsManager\")), \"msg.sender not RoundsManager\");\n        _;\n    }\n\n    // Checks if caller is either BondingManager or JobsManager\n    modifier onlyBondingManagerOrJobsManager() {\n        require(\n            msg.sender == controller.getContract(keccak256(\"BondingManager\")) ||\n                msg.sender == controller.getContract(keccak256(\"JobsManager\")),\n            \"msg.sender not BondingManager or JobsManager\"\n        );\n        _;\n    }\n\n    // Checks if caller is either the currently registered Minter or JobsManager\n    modifier onlyMinterOrJobsManager() {\n        require(\n            msg.sender == controller.getContract(keccak256(\"Minter\")) ||\n                msg.sender == controller.getContract(keccak256(\"JobsManager\")),\n            \"msg.sender not Minter or JobsManager\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Minter constructor\n     * @param _inflation Base inflation rate as a percentage of current total token supply\n     * @param _inflationChange Change in inflation rate each round (increase or decrease) if target bonding rate is not achieved\n     * @param _targetBondingRate Target bonding rate as a percentage of total bonded tokens / total token supply\n     */\n    constructor(\n        address _controller,\n        uint256 _inflation,\n        uint256 _inflationChange,\n        uint256 _targetBondingRate\n    ) public Manager(_controller) {\n        // Inflation must be valid percentage\n        require(MathUtils.validPerc(_inflation), \"_inflation is invalid percentage\");\n        // Inflation change must be valid percentage\n        require(MathUtils.validPerc(_inflationChange), \"_inflationChange is invalid percentage\");\n        // Target bonding rate must be valid percentage\n        require(MathUtils.validPerc(_targetBondingRate), \"_targetBondingRate is invalid percentage\");\n\n        inflation = _inflation;\n        inflationChange = _inflationChange;\n        targetBondingRate = _targetBondingRate;\n    }\n\n    /**\n     * @notice Set targetBondingRate. Only callable by Controller owner\n     * @param _targetBondingRate Target bonding rate as a percentage of total bonded tokens / total token supply\n     */\n    function setTargetBondingRate(uint256 _targetBondingRate) external onlyControllerOwner {\n        // Must be valid percentage\n        require(MathUtils.validPerc(_targetBondingRate), \"_targetBondingRate is invalid percentage\");\n\n        targetBondingRate = _targetBondingRate;\n\n        emit ParameterUpdate(\"targetBondingRate\");\n    }\n\n    /**\n     * @notice Set inflationChange. Only callable by Controller owner\n     * @param _inflationChange Inflation change as a percentage of total token supply\n     */\n    function setInflationChange(uint256 _inflationChange) external onlyControllerOwner {\n        // Must be valid percentage\n        require(MathUtils.validPerc(_inflationChange), \"_inflationChange is invalid percentage\");\n\n        inflationChange = _inflationChange;\n\n        emit ParameterUpdate(\"inflationChange\");\n    }\n\n    /**\n     * @notice Migrate to a new Minter by transferring ownership of the token as well\n     * as the current Minter's token balance to the new Minter. Only callable by Controller when system is paused\n     * @param _newMinter Address of new Minter\n     */\n    function migrateToNewMinter(IMinter _newMinter) external onlyControllerOwner whenSystemPaused {\n        // New Minter cannot be the current Minter\n        require(_newMinter != this, \"new Minter cannot be current Minter\");\n        // Check for null address\n        require(address(_newMinter) != address(0), \"new Minter cannot be null address\");\n\n        IController newMinterController = _newMinter.getController();\n        // New Minter must have same Controller as current Minter\n        require(newMinterController == controller, \"new Minter Controller must be current Controller\");\n        // New Minter's Controller must have the current Minter registered\n        require(newMinterController.getContract(keccak256(\"Minter\")) == address(this), \"new Minter must be registered\");\n\n        // Transfer ownership of token to new Minter\n        livepeerToken().transferOwnership(address(_newMinter));\n        // Transfer current Minter's token balance to new Minter\n        livepeerToken().transfer(address(_newMinter), livepeerToken().balanceOf(address(this)));\n        // Transfer current Minter's ETH balance to new Minter\n        _newMinter.depositETH.value(address(this).balance)();\n    }\n\n    /**\n     * @notice Create reward based on a fractional portion of the mintable tokens for the current round\n     * @param _fracNum Numerator of fraction (active transcoder's stake)\n     * @param _fracDenom Denominator of fraction (total active stake)\n     */\n    function createReward(uint256 _fracNum, uint256 _fracDenom)\n        external\n        onlyBondingManager\n        whenSystemNotPaused\n        returns (uint256)\n    {\n        // Compute and mint fraction of mintable tokens to include in reward\n        uint256 mintAmount = MathUtils.percOf(currentMintableTokens, _fracNum, _fracDenom);\n        // Update amount of minted tokens for round\n        currentMintedTokens = currentMintedTokens.add(mintAmount);\n        // Minted tokens must not exceed mintable tokens\n        require(currentMintedTokens <= currentMintableTokens, \"minted tokens cannot exceed mintable tokens\");\n        // Mint new tokens\n        livepeerToken().mint(address(this), mintAmount);\n\n        // Reward = minted tokens\n        return mintAmount;\n    }\n\n    /**\n     * @notice Transfer tokens to a receipient. Only callable by BondingManager - always trusts BondingManager\n     * @param _to Recipient address\n     * @param _amount Amount of tokens\n     */\n    function trustedTransferTokens(address _to, uint256 _amount) external onlyBondingManager whenSystemNotPaused {\n        livepeerToken().transfer(_to, _amount);\n    }\n\n    /**\n     * @notice Burn tokens. Only callable by BondingManager - always trusts BondingManager\n     * @param _amount Amount of tokens to burn\n     */\n    function trustedBurnTokens(uint256 _amount) external onlyBondingManager whenSystemNotPaused {\n        livepeerToken().burn(_amount);\n    }\n\n    /**\n     * @notice Withdraw ETH to a recipient. Only callable by BondingManager or TicketBroker - always trusts these two contracts\n     * @param _to Recipient address\n     * @param _amount Amount of ETH\n     */\n    function trustedWithdrawETH(address payable _to, uint256 _amount)\n        external\n        onlyBondingManagerOrJobsManager\n        whenSystemNotPaused\n    {\n        _to.transfer(_amount);\n    }\n\n    /**\n     * @notice Deposit ETH to this contract. Only callable by the currently registered Minter or JobsManager\n     */\n    function depositETH() external payable onlyMinterOrJobsManager returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Set inflation and mintable tokens for the round. Only callable by the RoundsManager\n     */\n    function setCurrentRewardTokens() external onlyRoundsManager whenSystemNotPaused {\n        setInflation();\n\n        // Set mintable tokens based upon current inflation and current total token supply\n        currentMintableTokens = MathUtils.percOf(livepeerToken().totalSupply(), inflation);\n        currentMintedTokens = 0;\n\n        emit SetCurrentRewardTokens(currentMintableTokens, inflation);\n    }\n\n    /**\n     * @dev Returns Controller interface\n     */\n    function getController() public view returns (IController) {\n        return controller;\n    }\n\n    /**\n     * @dev Set inflation based upon the current bonding rate and target bonding rate\n     */\n    function setInflation() internal {\n        uint256 currentBondingRate = 0;\n        uint256 totalSupply = livepeerToken().totalSupply();\n\n        if (totalSupply > 0) {\n            uint256 totalBonded = bondingManager().getTotalBonded();\n            currentBondingRate = MathUtils.percPoints(totalBonded, totalSupply);\n        }\n\n        if (currentBondingRate < targetBondingRate) {\n            // Bonding rate is below the target - increase inflation\n            inflation = inflation.add(inflationChange);\n        } else if (currentBondingRate > targetBondingRate) {\n            // Bonding rate is above the target - decrease inflation\n            if (inflationChange > inflation) {\n                inflation = 0;\n            } else {\n                inflation = inflation.sub(inflationChange);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns LivepeerToken interface\n     */\n    function livepeerToken() internal view returns (ILivepeerToken) {\n        return ILivepeerToken(controller.getContract(keccak256(\"LivepeerToken\")));\n    }\n\n    /**\n     * @dev Returns BondingManager interface\n     */\n    function bondingManager() internal view returns (IBondingManager) {\n        return IBondingManager(controller.getContract(keccak256(\"BondingManager\")));\n    }\n}\ncontract Manager is IManager {\n    // Controller that contract is registered with\n    IController public controller;\n\n    // Check if sender is controller\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    // Check if sender is controller owner\n    modifier onlyControllerOwner() {\n        _onlyControllerOwner();\n        _;\n    }\n\n    // Check if controller is not paused\n    modifier whenSystemNotPaused() {\n        _whenSystemNotPaused();\n        _;\n    }\n\n    // Check if controller is paused\n    modifier whenSystemPaused() {\n        _whenSystemPaused();\n        _;\n    }\n\n    constructor(address _controller) public {\n        controller = IController(_controller);\n    }\n\n    /**\n     * @notice Set controller. Only callable by current controller\n     * @param _controller Controller contract address\n     */\n    function setController(address _controller) external onlyController {\n        controller = IController(_controller);\n\n        emit SetController(_controller);\n    }\n\n    function _onlyController() internal view {\n        require(msg.sender == address(controller), \"caller must be Controller\");\n    }\n\n    function _onlyControllerOwner() internal view {\n        require(msg.sender == controller.owner(), \"caller must be Controller owner\");\n    }\n\n    function _whenSystemNotPaused() internal view {\n        require(!controller.paused(), \"system is paused\");\n    }\n\n    function _whenSystemPaused() internal view {\n        require(controller.paused(), \"system is not paused\");\n    }\n}\ncontract MintableToken is ERC20, Ownable {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\n        _mint(_to, _amount);\n        emit Mint(_to, _amount);\n        return true;\n    }\n\n    /**\n     * @dev Function to stop minting new tokens.\n     * @return True if the operation was successful.\n     */\n    function finishMinting() public onlyOwner canMint returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}\ncontract ArbitrumLivepeerToken is LivepeerToken {\n    address public routerAdmin;\n    address public router;\n\n    bool private shouldRegisterGateway;\n\n    modifier onlyRouterAdmin() {\n        require(msg.sender == routerAdmin, \"NOT_ROUTER_ADMIN\");\n        _;\n    }\n\n    constructor(address _router) public {\n        router = _router;\n        routerAdmin = msg.sender;\n    }\n\n    function setRouterAdmin(address _routerAdmin) external onlyRouterAdmin {\n        routerAdmin = _routerAdmin;\n    }\n\n    function registerGatewayWithRouter(\n        address _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) external payable onlyRouterAdmin {\n        // we temporarily set `shouldRegisterGateway` to true for the callback in setGateway() to succeed\n        bool prev = shouldRegisterGateway;\n        shouldRegisterGateway = true;\n\n        IL1GatewayRouter(router).setGateway.value(msg.value)(\n            _gateway,\n            _maxGas,\n            _gasPriceBid,\n            _maxSubmissionCost,\n            _creditBackAddress\n        );\n\n        shouldRegisterGateway = prev;\n    }\n\n    function isArbitrumEnabled() external view returns (uint8) {\n        require(shouldRegisterGateway, \"NOT_EXPECTED_CALL\");\n        return uint8(0xa4b1);\n    }\n}\ncontract BondingManager is ManagerProxyTarget, IBondingManager {\n    using SafeMath for uint256;\n    using SortedDoublyLL for SortedDoublyLL.Data;\n    using EarningsPool for EarningsPool.Data;\n    using EarningsPoolLIP36 for EarningsPool.Data;\n\n    // Constants\n    // Occurances are replaced at compile time\n    // and computed to a single value if possible by the optimizer\n    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;\n    uint256 constant MAX_LOOKBACK_ROUNDS = 100;\n    // PreciseMathUtils.percPoints(1, 1) / MathUtils.percPoints(1, 1) => (10 ** 27) / 1000000\n    uint256 constant RESCALE_FACTOR = 10**21;\n    // Address for LIP-77 execution\n    address constant LIP_77_ADDRESS = 0xB47D8F87c0113827d44Ad0Bc32D53823C477a89d;\n    // Maximum CFF used to check whether to down scale CFF values prior to the LIP-78 round\n    uint256 constant LIP_78_MAX_CFF = 10**32;\n\n    // Time between unbonding and possible withdrawl in rounds\n    uint64 public unbondingPeriod;\n    // DEPRECATED - DO NOT USE\n    uint256 public numActiveTranscodersDEPRECATED;\n    // Max number of rounds that a caller can claim earnings for at once\n    uint256 public maxEarningsClaimsRounds;\n\n    // Represents a transcoder's current state\n    struct Transcoder {\n        uint256 lastRewardRound; // Last round that the transcoder called reward\n        uint256 rewardCut; // % of reward paid to transcoder by a delegator\n        uint256 feeShare; // % of fees paid to delegators by transcoder\n        uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE\n        mapping(uint256 => EarningsPool.Data) earningsPoolPerRound; // Mapping of round => earnings pool for the round\n        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active\n        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive\n        uint256 deactivationRound; // Round in which the transcoder will become inactive\n        uint256 activeCumulativeRewards; // The transcoder's cumulative rewards that are active in the current round\n        uint256 cumulativeRewards; // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).\n        uint256 cumulativeFees; // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)\n        uint256 lastFeeRound; // Latest round in which the transcoder received fees\n    }\n\n    // The various states a transcoder can be in\n    enum TranscoderStatus {\n        NotRegistered,\n        Registered\n    }\n\n    // Represents a delegator's current state\n    struct Delegator {\n        uint256 bondedAmount; // The amount of bonded tokens\n        uint256 fees; // The amount of fees collected\n        address delegateAddress; // The address delegated to\n        uint256 delegatedAmount; // The amount of tokens delegated to the delegator\n        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone\n        uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings\n        uint256 nextUnbondingLockId; // ID for the next unbonding lock created\n        mapping(uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock\n    }\n\n    // The various states a delegator can be in\n    enum DelegatorStatus {\n        Pending,\n        Bonded,\n        Unbonded\n    }\n\n    // Represents an amount of tokens that are being unbonded\n    struct UnbondingLock {\n        uint256 amount; // Amount of tokens being unbonded\n        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn\n    }\n\n    // Keep track of the known transcoders and delegators\n    mapping(address => Delegator) private delegators;\n    mapping(address => Transcoder) private transcoders;\n\n    // DEPRECATED - DO NOT USE\n    // The function getTotalBonded() no longer uses this variable\n    // and instead calculates the total bonded value separately\n    uint256 private totalBondedDEPRECATED;\n\n    // DEPRECATED - DO NOT USE\n    SortedDoublyLL.Data private transcoderPoolDEPRECATED;\n\n    // DEPRECATED - DO NOT USE\n    struct ActiveTranscoderSetDEPRECATED {\n        address[] transcoders;\n        mapping(address => bool) isActive;\n        uint256 totalStake;\n    }\n\n    // DEPRECATED - DO NOT USE\n    mapping(uint256 => ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;\n\n    // The total active stake (sum of the stake of active set members) for the current round\n    uint256 public currentRoundTotalActiveStake;\n    // The total active stake (sum of the stake of active set members) for the next round\n    uint256 public nextRoundTotalActiveStake;\n\n    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.\n    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders\n    // in the pool are locked into the active set for round N + 1\n    SortedDoublyLL.Data private transcoderPoolV2;\n\n    // Flag for whether LIP-77 has been executed\n    bool private lip77Executed;\n\n    // Check if sender is TicketBroker\n    modifier onlyTicketBroker() {\n        _onlyTicketBroker();\n        _;\n    }\n\n    // Check if sender is RoundsManager\n    modifier onlyRoundsManager() {\n        _onlyRoundsManager();\n        _;\n    }\n\n    // Check if sender is Verifier\n    modifier onlyVerifier() {\n        _onlyVerifier();\n        _;\n    }\n\n    // Check if current round is initialized\n    modifier currentRoundInitialized() {\n        _currentRoundInitialized();\n        _;\n    }\n\n    // Automatically claim earnings from lastClaimRound through the current round\n    modifier autoClaimEarnings() {\n        _autoClaimEarnings();\n        _;\n    }\n\n    /**\n     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\n     * should be used to initialize state variables post-deployment:\n     * - setUnbondingPeriod()\n     * - setNumActiveTranscoders()\n     * - setMaxEarningsClaimsRounds()\n     * @param _controller Address of Controller that this contract will be registered with\n     */\n    constructor(address _controller) public Manager(_controller) {}\n\n    /**\n     * @notice Set unbonding period. Only callable by Controller owner\n     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal\n     */\n    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\n        unbondingPeriod = _unbondingPeriod;\n\n        emit ParameterUpdate(\"unbondingPeriod\");\n    }\n\n    /**\n     * @notice Set maximum number of active transcoders. Only callable by Controller owner\n     * @param _numActiveTranscoders Number of active transcoders\n     */\n    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\n        transcoderPoolV2.setMaxSize(_numActiveTranscoders);\n\n        emit ParameterUpdate(\"numActiveTranscoders\");\n    }\n\n    /**\n     * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner\n     * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once\n     */\n    function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {\n        maxEarningsClaimsRounds = _maxEarningsClaimsRounds;\n\n        emit ParameterUpdate(\"maxEarningsClaimsRounds\");\n    }\n\n    /**\n     * @notice Execute LIP-77. Can only be called once by Controller owner\n     * @param _bondedAmount The bonded amount for the LIP-77 address\n     */\n    function executeLIP77(uint256 _bondedAmount) external onlyControllerOwner {\n        require(!lip77Executed, \"LIP-77 already executed\");\n\n        lip77Executed = true;\n\n        delegators[LIP_77_ADDRESS].bondedAmount = _bondedAmount;\n\n        address delegate = delegators[LIP_77_ADDRESS].delegateAddress;\n\n        emit Bond(delegate, delegate, LIP_77_ADDRESS, 0, _bondedAmount);\n    }\n\n    /**\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     */\n    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {\n        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));\n    }\n\n    /**\n     * @notice Delegate stake towards a specific address\n     * @param _amount The amount of tokens to stake\n     * @param _to The address of the transcoder to stake towards\n     */\n    function bond(uint256 _amount, address _to) external {\n        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));\n    }\n\n    /**\n     * @notice Unbond an amount of the delegator's bonded stake\n     * @param _amount Amount of tokens to unbond\n     */\n    function unbond(uint256 _amount) external {\n        unbondWithHint(_amount, address(0), address(0));\n    }\n\n    /**\n     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     */\n    function rebond(uint256 _unbondingLockId) external {\n        rebondWithHint(_unbondingLockId, address(0), address(0));\n    }\n\n    /**\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status\n     * @param _to Address of delegate\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     */\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {\n        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));\n    }\n\n    /**\n     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period\n     * @param _unbondingLockId ID of unbonding lock to withdraw with\n     */\n    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {\n        Delegator storage del = delegators[msg.sender];\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n        require(isValidUnbondingLock(msg.sender, _unbondingLockId), \"invalid unbonding lock ID\");\n        require(\n            lock.withdrawRound <= roundsManager().currentRound(),\n            \"withdraw round must be before or equal to the current round\"\n        );\n\n        uint256 amount = lock.amount;\n        uint256 withdrawRound = lock.withdrawRound;\n        // Delete unbonding lock\n        delete del.unbondingLocks[_unbondingLockId];\n\n        // Tell Minter to transfer stake (LPT) to the delegator\n        minter().trustedTransferTokens(msg.sender, amount);\n\n        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);\n    }\n\n    /**\n     * @notice Withdraws fees to the caller\n     */\n    function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        uint256 fees = delegators[msg.sender].fees;\n        require(fees > 0, \"no fees to withdraw\");\n        delegators[msg.sender].fees = 0;\n\n        // Tell Minter to transfer fees (ETH) to the delegator\n        minter().trustedWithdrawETH(msg.sender, fees);\n\n        emit WithdrawFees(msg.sender);\n    }\n\n    /**\n     * @notice Mint token rewards for an active transcoder and its delegators\n     */\n    function reward() external {\n        rewardWithHint(address(0), address(0));\n    }\n\n    /**\n     * @notice Update transcoder's fee pool. Only callable by the TicketBroker\n     * @param _transcoder Transcoder address\n     * @param _fees Fees to be added to the fee pool\n     */\n    function updateTranscoderWithFees(\n        address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external whenSystemNotPaused onlyTicketBroker {\n        // Silence unused param compiler warning\n        _round;\n\n        require(isRegisteredTranscoder(_transcoder), \"transcoder must be registered\");\n\n        uint256 currentRound = roundsManager().currentRound();\n\n        Transcoder storage t = transcoders[_transcoder];\n\n        uint256 lastRewardRound = t.lastRewardRound;\n        uint256 activeCumulativeRewards = t.activeCumulativeRewards;\n\n        // LIP-36: Add fees for the current round instead of '_round'\n        // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n        EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));\n\n        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'\n        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected\n        // for cumulative fee calculation this would result in division by zero.\n        if (currentRound > lastRewardRound) {\n            earningsPool.setCommission(t.rewardCut, t.feeShare);\n\n            uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\n            if (lastUpdateRound < currentRound) {\n                earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\n            }\n\n            // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not\n            // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its\n            // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become\n            // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round\n            activeCumulativeRewards = t.cumulativeRewards;\n        }\n\n        uint256 totalStake = earningsPool.totalStake;\n        if (prevEarningsPool.cumulativeRewardFactor == 0 && lastRewardRound == currentRound) {\n            // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)\n            // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)\n            // based on rewards for currentRound\n            IMinter mtr = minter();\n            uint256 rewards = PreciseMathUtils.percOf(\n                mtr.currentMintableTokens().add(mtr.currentMintedTokens()),\n                totalStake,\n                currentRoundTotalActiveStake\n            );\n            uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);\n            uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);\n\n            prevEarningsPool.cumulativeRewardFactor = PreciseMathUtils.percOf(\n                earningsPool.cumulativeRewardFactor,\n                totalStake,\n                delegatorsRewards.add(totalStake)\n            );\n        }\n\n        // If the previous cumulativeRewardFactor is 0 and the current round is before the LIP-71 round, set the default value to\n        // MathUtils.percPoints(1, 1) because we only set the default value to PreciseMathUtils.percPoints(1, 1) when storing for\n        // the LIP-71 round and onwards (see updateCumulativeFeeFactor() in EarningsPoolLIP36.sol)\n        if (prevEarningsPool.cumulativeRewardFactor == 0 && currentRound < roundsManager().lipUpgradeRound(71)) {\n            prevEarningsPool.cumulativeRewardFactor = MathUtils.percPoints(1, 1);\n        }\n\n        uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);\n        uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);\n        // Calculate the fees earned by the transcoder's earned rewards\n        uint256 transcoderRewardStakeFees = PreciseMathUtils.percOf(\n            delegatorsFees,\n            activeCumulativeRewards,\n            totalStake\n        );\n        // Track fees earned by the transcoder based on its earned rewards and feeShare\n        t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);\n        // Update cumulative fee factor with new fees\n        // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)\n        // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using\n        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeFees field\n        earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);\n\n        t.lastFeeRound = currentRound;\n    }\n\n    /**\n     * @notice Slash a transcoder. Only callable by the Verifier\n     * @param _transcoder Transcoder address\n     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder\n     * @param _slashAmount Percentage of transcoder bond to be slashed\n     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder\n     */\n    function slashTranscoder(\n        address _transcoder,\n        address _finder,\n        uint256 _slashAmount,\n        uint256 _finderFee\n    ) external whenSystemNotPaused onlyVerifier {\n        Delegator storage del = delegators[_transcoder];\n\n        if (del.bondedAmount > 0) {\n            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\n\n            // If active transcoder, resign it\n            if (transcoderPoolV2.contains(_transcoder)) {\n                resignTranscoder(_transcoder);\n            }\n\n            // Decrease bonded stake\n            del.bondedAmount = del.bondedAmount.sub(penalty);\n\n            // If still bonded decrease delegate's delegated amount\n            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\n                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(\n                    penalty\n                );\n            }\n\n            // Account for penalty\n            uint256 burnAmount = penalty;\n\n            // Award finder fee if there is a finder address\n            if (_finder != address(0)) {\n                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);\n                minter().trustedTransferTokens(_finder, finderAmount);\n\n                // Minter burns the slashed funds - finder reward\n                minter().trustedBurnTokens(burnAmount.sub(finderAmount));\n\n                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);\n            } else {\n                // Minter burns the slashed funds\n                minter().trustedBurnTokens(burnAmount);\n\n                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);\n            }\n        } else {\n            emit TranscoderSlashed(_transcoder, _finder, 0, 0);\n        }\n    }\n\n    /**\n     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round\n     * @param _endRound The last round for which to claim token pools shares for a delegator\n     */\n    function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {\n        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;\n        require(lastClaimRound < _endRound, \"end round must be after last claim round\");\n        // _endRound should be equal to the current round because after LIP-36 using a past _endRound can result\n        // in incorrect cumulative factor values used/stored for the _endRound in updateDelegatorWithEarnings().\n        // The exception is when claiming through an _endRound before the LIP-36 upgrade round because cumulative factor\n        // values will not be used/stored in updateDelegatorWithEarnings() before the LIP-36 upgrade round.\n        require(\n            _endRound == roundsManager().currentRound() || _endRound < roundsManager().lipUpgradeRound(36),\n            \"end round must be equal to the current round or before the LIP-36 upgrade round\"\n        );\n\n        updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound);\n    }\n\n    /**\n     * @notice Claim earnings for a delegator based on the snapshot taken in LIP-52\n     * @dev https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-52.md\n     * @param _pendingStake the amount of pending stake for the delegator (current stake + pending rewards)\n     * @param _pendingFees the amount of pending fees for the delegator (current fees + pending fees)\n     * @param _earningsProof array of keccak256 sibling hashes on the branch of the leaf for the delegator up to the root\n     * @param _data (optional) raw transaction data to be executed on behalf of msg.sender after claiming snapshot earnings\n     */\n    function claimSnapshotEarnings(\n        uint256 _pendingStake,\n        uint256 _pendingFees,\n        bytes32[] calldata _earningsProof,\n        bytes calldata _data\n    ) external whenSystemNotPaused currentRoundInitialized {\n        Delegator storage del = delegators[msg.sender];\n\n        uint256 lip52Round = roundsManager().lipUpgradeRound(52);\n\n        uint256 lastClaimRound = del.lastClaimRound;\n\n        require(lastClaimRound < lip52Round, \"Already claimed for LIP-52\");\n\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _pendingStake, _pendingFees));\n\n        require(\n            IMerkleSnapshot(controller.getContract(keccak256(\"MerkleSnapshot\"))).verify(\n                keccak256(\"LIP-52\"),\n                _earningsProof,\n                leaf\n            ),\n            \"Merkle proof is invalid\"\n        );\n\n        emit EarningsClaimed(\n            del.delegateAddress,\n            msg.sender,\n            _pendingStake.sub(del.bondedAmount),\n            _pendingFees.sub(del.fees),\n            lastClaimRound.add(1),\n            lip52Round\n        );\n\n        del.lastClaimRound = lip52Round;\n        del.bondedAmount = _pendingStake;\n        del.fees = _pendingFees;\n\n        // allow for execution of subsequent claiming or staking operations\n        if (_data.length > 0) {\n            (bool success, bytes memory returnData) = address(this).delegatecall(_data);\n            require(success, string(returnData));\n        }\n    }\n\n    /**\n     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager\n     */\n    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {\n        currentRoundTotalActiveStake = nextRoundTotalActiveStake;\n    }\n\n    /**\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the\n     * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will\n     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.\n     * See SortedDoublyLL.sol for details on list hints\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool\n     */\n    function transcoderWithHint(\n        uint256 _rewardCut,\n        uint256 _feeShare,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized {\n        require(!roundsManager().currentRoundLocked(), \"can't update transcoder params, current round is locked\");\n        require(MathUtils.validPerc(_rewardCut), \"invalid rewardCut percentage\");\n        require(MathUtils.validPerc(_feeShare), \"invalid feeShare percentage\");\n        require(isRegisteredTranscoder(msg.sender), \"transcoder must be registered\");\n\n        Transcoder storage t = transcoders[msg.sender];\n        uint256 currentRound = roundsManager().currentRound();\n\n        require(\n            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,\n            \"caller can't be active or must have already called reward for the current round\"\n        );\n\n        t.rewardCut = _rewardCut;\n        t.feeShare = _feeShare;\n\n        if (!transcoderPoolV2.contains(msg.sender)) {\n            tryToJoinActiveSet(\n                msg.sender,\n                delegators[msg.sender].delegatedAmount,\n                currentRound.add(1),\n                _newPosPrev,\n                _newPosNext\n            );\n        }\n\n        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);\n    }\n\n    /**\n     * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed\n     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\n     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\n     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _amount The amount of tokens to stake.\n     * @param _to The address of the transcoder to stake towards\n     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\n     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\n     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\n     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\n     */\n    function bondWithHint(\n        uint256 _amount,\n        address _to,\n        address _oldDelegateNewPosPrev,\n        address _oldDelegateNewPosNext,\n        address _currDelegateNewPosPrev,\n        address _currDelegateNewPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        Delegator storage del = delegators[msg.sender];\n\n        uint256 currentRound = roundsManager().currentRound();\n        // Amount to delegate\n        uint256 delegationAmount = _amount;\n        // Current delegate\n        address currentDelegate = del.delegateAddress;\n\n        if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {\n            // New delegate\n            // Set start round\n            // Don't set start round if delegator is in pending state because the start round would not change\n            del.startRound = currentRound.add(1);\n            // Unbonded state = no existing delegate and no bonded stake\n            // Thus, delegation amount = provided amount\n        } else if (currentDelegate != address(0) && currentDelegate != _to) {\n            // A registered transcoder cannot delegate its bonded stake toward another address\n            // because it can only be delegated toward itself\n            // In the future, if delegation towards another registered transcoder as an already\n            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction\n            // could be removed\n            require(\n                !isRegisteredTranscoder(msg.sender),\n                \"registered transcoders can't delegate towards other addresses\"\n            );\n            // Changing delegate\n            // Set start round\n            del.startRound = currentRound.add(1);\n            // Update amount to delegate with previous delegation amount\n            delegationAmount = delegationAmount.add(del.bondedAmount);\n\n            decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);\n        }\n\n        Transcoder storage newDelegate = transcoders[_to];\n        EarningsPool.Data storage currPool = newDelegate.earningsPoolPerRound[currentRound];\n        if (currPool.cumulativeRewardFactor == 0) {\n            currPool.cumulativeRewardFactor = cumulativeFactorsPool(newDelegate, newDelegate.lastRewardRound)\n                .cumulativeRewardFactor;\n        }\n        if (currPool.cumulativeFeeFactor == 0) {\n            currPool.cumulativeFeeFactor = cumulativeFactorsPool(newDelegate, newDelegate.lastFeeRound)\n                .cumulativeFeeFactor;\n        }\n\n        // cannot delegate to someone without having bonded stake\n        require(delegationAmount > 0, \"delegation amount must be greater than 0\");\n        // Update delegate\n        del.delegateAddress = _to;\n        // Update bonded amount\n        del.bondedAmount = del.bondedAmount.add(_amount);\n\n        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);\n\n        if (_amount > 0) {\n            // Transfer the LPT to the Minter\n            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);\n        }\n\n        emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount);\n    }\n\n    /**\n     * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed\n     * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\n     * @param _amount Amount of tokens to unbond\n     * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool\n     */\n    function unbondWithHint(\n        uint256 _amount,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, \"caller must be bonded\");\n\n        Delegator storage del = delegators[msg.sender];\n\n        require(_amount > 0, \"unbond amount must be greater than 0\");\n        require(_amount <= del.bondedAmount, \"amount is greater than bonded amount\");\n\n        address currentDelegate = del.delegateAddress;\n        uint256 currentRound = roundsManager().currentRound();\n        uint256 withdrawRound = currentRound.add(unbondingPeriod);\n        uint256 unbondingLockId = del.nextUnbondingLockId;\n\n        // Create new unbonding lock\n        del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });\n        // Increment ID for next unbonding lock\n        del.nextUnbondingLockId = unbondingLockId.add(1);\n        // Decrease delegator's bonded amount\n        del.bondedAmount = del.bondedAmount.sub(_amount);\n\n        if (del.bondedAmount == 0) {\n            // Delegator no longer delegated to anyone if it does not have a bonded amount\n            del.delegateAddress = address(0);\n            // Delegator does not have a start round if it is no longer delegated to anyone\n            del.startRound = 0;\n\n            if (transcoderPoolV2.contains(msg.sender)) {\n                resignTranscoder(msg.sender);\n            }\n        }\n\n        // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount\n        decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);\n\n        emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound);\n    }\n\n    /**\n     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates\n     * the transcoder pool using an optional list hint if needed\n     * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool\n     * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool\n     */\n    function rebondWithHint(\n        uint256 _unbondingLockId,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, \"caller must be bonded\");\n\n        // Process rebond using unbonding lock\n        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\n    }\n\n    /**\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using\n     * an optional list hint if needed\n     * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _to Address of delegate\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool\n     */\n    function rebondFromUnbondedWithHint(\n        address _to,\n        uint256 _unbondingLockId,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, \"caller must be unbonded\");\n\n        // Set delegator's start round and transition into Pending state\n        delegators[msg.sender].startRound = roundsManager().currentRound().add(1);\n        // Set delegator's delegate\n        delegators[msg.sender].delegateAddress = _to;\n        // Process rebond using unbonding lock\n        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\n    }\n\n    /**\n     * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed\n     * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller is in the pool\n     */\n    function rewardWithHint(address _newPosPrev, address _newPosNext)\n        public\n        whenSystemNotPaused\n        currentRoundInitialized\n    {\n        uint256 currentRound = roundsManager().currentRound();\n\n        require(isActiveTranscoder(msg.sender), \"caller must be an active transcoder\");\n        require(\n            transcoders[msg.sender].lastRewardRound != currentRound,\n            \"caller has already called reward for the current round\"\n        );\n\n        Transcoder storage t = transcoders[msg.sender];\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n\n        // Set last round that transcoder called reward\n        earningsPool.setCommission(t.rewardCut, t.feeShare);\n\n        // If transcoder didn't receive stake updates during the previous round and hasn't called reward for > 1 round\n        // the 'totalStake' on its 'EarningsPool' for the current round wouldn't be initialized\n        // Thus we sync the the transcoder's stake to when it was last updated\n        // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently\n        uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\n        if (lastUpdateRound < currentRound) {\n            earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\n        }\n\n        // Create reward based on active transcoder's stake relative to the total active stake\n        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake\n        uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);\n\n        updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);\n\n        // Set last round that transcoder called reward\n        t.lastRewardRound = currentRound;\n\n        emit Reward(msg.sender, rewardTokens);\n    }\n\n    /**\n     * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round\n     * @param _delegator Address of delegator\n     * @param _endRound The last round to compute pending stake from\n     * @return Pending bonded stake for '_delegator' since last claiming rewards\n     */\n    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {\n        // _endRound should be equal to the current round because after LIP-36 using a past _endRound can result\n        // in incorrect cumulative factor values used for the _endRound in pendingStakeAndFees().\n        // The exception is when calculating stake through an _endRound before the LIP-36 upgrade round because cumulative factor\n        // values will not be used in pendingStakeAndFees() before the LIP-36 upgrade round.\n        uint256 endRound = _endRound;\n        if (endRound >= roundsManager().lipUpgradeRound(36)) {\n            endRound = roundsManager().currentRound();\n        }\n\n        (uint256 stake, ) = pendingStakeAndFees(_delegator, endRound);\n        return stake;\n    }\n\n    /**\n     * @notice Returns pending fees for a delegator from its lastClaimRound through an end round\n     * @param _delegator Address of delegator\n     * @param _endRound The last round to compute pending fees from\n     * @return Pending fees for '_delegator' since last claiming fees\n     */\n    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {\n        // _endRound should be equal to the current round because after LIP-36 using a past _endRound can result\n        // in incorrect cumulative factor values used for the _endRound in pendingStakeAndFees().\n        // The exception is when calculating fees through an _endRound before the LIP-36 upgrade round because cumulative factor\n        // values will not be used in pendingStakeAndFees() before the LIP-36 upgrade round.\n        uint256 endRound = _endRound;\n        if (endRound >= roundsManager().lipUpgradeRound(36)) {\n            endRound = roundsManager().currentRound();\n        }\n\n        (, uint256 fees) = pendingStakeAndFees(_delegator, endRound);\n        return fees;\n    }\n\n    /**\n     * @notice Returns total bonded stake for a transcoder\n     * @param _transcoder Address of transcoder\n     * @return total bonded stake for a delegator\n     */\n    function transcoderTotalStake(address _transcoder) public view returns (uint256) {\n        return delegators[_transcoder].delegatedAmount;\n    }\n\n    /**\n     * @notice Computes transcoder status\n     * @param _transcoder Address of transcoder\n     * @return registered or not registered transcoder status\n     */\n    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {\n        if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;\n        return TranscoderStatus.NotRegistered;\n    }\n\n    /**\n     * @notice Computes delegator status\n     * @param _delegator Address of delegator\n     * @return bonded, unbonded or pending delegator status\n     */\n    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {\n        Delegator storage del = delegators[_delegator];\n\n        if (del.bondedAmount == 0) {\n            // Delegator unbonded all its tokens\n            return DelegatorStatus.Unbonded;\n        } else if (del.startRound > roundsManager().currentRound()) {\n            // Delegator round start is in the future\n            return DelegatorStatus.Pending;\n        } else {\n            // Delegator round start is now or in the past\n            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which\n            // would trigger the first if clause\n            return DelegatorStatus.Bonded;\n        }\n    }\n\n    /**\n     * @notice Return transcoder information\n     * @param _transcoder Address of transcoder\n     * @return lastRewardRound Trancoder's last reward round\n     * @return rewardCut Transcoder's reward cut\n     * @return feeShare Transcoder's fee share\n     * @return lastActiveStakeUpdateRound Round in which transcoder's stake was last updated while active\n     * @return activationRound Round in which transcoder became active\n     * @return deactivationRound Round in which transcoder will no longer be active\n     * @return activeCumulativeRewards Transcoder's cumulative rewards that are currently active\n     * @return cumulativeRewards Transcoder's cumulative rewards (earned via its active staked rewards and its reward cut)\n     * @return cumulativeFees Transcoder's cumulative fees (earned via its active staked rewards and its fee share)\n     * @return lastFeeRound Latest round that the transcoder received fees\n     */\n    function getTranscoder(address _transcoder)\n        public\n        view\n        returns (\n            uint256 lastRewardRound,\n            uint256 rewardCut,\n            uint256 feeShare,\n            uint256 lastActiveStakeUpdateRound,\n            uint256 activationRound,\n            uint256 deactivationRound,\n            uint256 activeCumulativeRewards,\n            uint256 cumulativeRewards,\n            uint256 cumulativeFees,\n            uint256 lastFeeRound\n        )\n    {\n        Transcoder storage t = transcoders[_transcoder];\n\n        lastRewardRound = t.lastRewardRound;\n        rewardCut = t.rewardCut;\n        feeShare = t.feeShare;\n        lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;\n        activationRound = t.activationRound;\n        deactivationRound = t.deactivationRound;\n        activeCumulativeRewards = t.activeCumulativeRewards;\n        cumulativeRewards = t.cumulativeRewards;\n        cumulativeFees = t.cumulativeFees;\n        lastFeeRound = t.lastFeeRound;\n    }\n\n    /**\n     * @notice Return transcoder's earnings pool for a given round\n     * @param _transcoder Address of transcoder\n     * @param _round Round number\n     * @return rewardPool Reward pool for delegators (only used before LIP-36)\n     * @return feePool Fee pool for delegators (only used before LIP-36)\n     * @return totalStake Transcoder's total stake in '_round'\n     * @return claimableStake Remaining stake that can be used to claim from the pool (only used before LIP-36)\n     * @return transcoderRewardCut Transcoder's reward cut for '_round'\n     * @return transcoderFeeShare Transcoder's fee share for '_round'\n     * @return transcoderRewardPool Transcoder's rewards for '_round' (only used before LIP-36)\n     * @return transcoderFeePool Transcoder's fees for '_round' (only used before LIP-36)\n     * @return hasTranscoderRewardFeePool True if there is a split reward/fee pool for the transcoder (only used before LIP-36)\n     * @return cumulativeRewardFactor The cumulative reward factor for delegator rewards calculation (only used after LIP-36)\n     * @return cumulativeFeeFactor The cumulative fee factor for delegator fees calculation (only used after LIP-36)\n     */\n    function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)\n        public\n        view\n        returns (\n            uint256 rewardPool,\n            uint256 feePool,\n            uint256 totalStake,\n            uint256 claimableStake,\n            uint256 transcoderRewardCut,\n            uint256 transcoderFeeShare,\n            uint256 transcoderRewardPool,\n            uint256 transcoderFeePool,\n            bool hasTranscoderRewardFeePool,\n            uint256 cumulativeRewardFactor,\n            uint256 cumulativeFeeFactor\n        )\n    {\n        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];\n\n        rewardPool = earningsPool.rewardPool;\n        feePool = earningsPool.feePool;\n        totalStake = earningsPool.totalStake;\n        claimableStake = earningsPool.claimableStake;\n        transcoderRewardCut = earningsPool.transcoderRewardCut;\n        transcoderFeeShare = earningsPool.transcoderFeeShare;\n        transcoderRewardPool = earningsPool.transcoderRewardPool;\n        transcoderFeePool = earningsPool.transcoderFeePool;\n        hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;\n        cumulativeRewardFactor = earningsPool.cumulativeRewardFactor;\n        cumulativeFeeFactor = earningsPool.cumulativeFeeFactor;\n    }\n\n    /**\n     * @notice Return delegator info\n     * @param _delegator Address of delegator\n     * @return total amount bonded by '_delegator'\n     * @return amount of fees collected by '_delegator'\n     * @return address '_delegator' has bonded to\n     * @return total amount delegated to '_delegator'\n     * @return round in which bond for '_delegator' became effective\n     * @return round for which '_delegator' has last claimed earnings\n     * @return ID for the next unbonding lock created for '_delegator'\n     */\n    function getDelegator(address _delegator)\n        public\n        view\n        returns (\n            uint256 bondedAmount,\n            uint256 fees,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            uint256 startRound,\n            uint256 lastClaimRound,\n            uint256 nextUnbondingLockId\n        )\n    {\n        Delegator storage del = delegators[_delegator];\n\n        bondedAmount = del.bondedAmount;\n        fees = del.fees;\n        delegateAddress = del.delegateAddress;\n        delegatedAmount = del.delegatedAmount;\n        startRound = del.startRound;\n        lastClaimRound = del.lastClaimRound;\n        nextUnbondingLockId = del.nextUnbondingLockId;\n    }\n\n    /**\n     * @notice Return delegator's unbonding lock info\n     * @param _delegator Address of delegator\n     * @param _unbondingLockId ID of unbonding lock\n     * @return amount of stake locked up by unbonding lock\n     * @return round in which 'amount' becomes available for withdrawal\n     */\n    function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)\n        public\n        view\n        returns (uint256 amount, uint256 withdrawRound)\n    {\n        UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];\n\n        return (lock.amount, lock.withdrawRound);\n    }\n\n    /**\n     * @notice Returns max size of transcoder pool\n     * @return transcoder pool max size\n     */\n    function getTranscoderPoolMaxSize() public view returns (uint256) {\n        return transcoderPoolV2.getMaxSize();\n    }\n\n    /**\n     * @notice Returns size of transcoder pool\n     * @return transcoder pool current size\n     */\n    function getTranscoderPoolSize() public view returns (uint256) {\n        return transcoderPoolV2.getSize();\n    }\n\n    /**\n     * @notice Returns transcoder with most stake in pool\n     * @return address for transcoder with highest stake in transcoder pool\n     */\n    function getFirstTranscoderInPool() public view returns (address) {\n        return transcoderPoolV2.getFirst();\n    }\n\n    /**\n     * @notice Returns next transcoder in pool for a given transcoder\n     * @param _transcoder Address of a transcoder in the pool\n     * @return address for the transcoder after '_transcoder' in transcoder pool\n     */\n    function getNextTranscoderInPool(address _transcoder) public view returns (address) {\n        return transcoderPoolV2.getNext(_transcoder);\n    }\n\n    /**\n     * @notice Return total bonded tokens\n     * @return total active stake for the current round\n     */\n    function getTotalBonded() public view returns (uint256) {\n        return currentRoundTotalActiveStake;\n    }\n\n    /**\n     * @notice Return whether a transcoder is active for the current round\n     * @param _transcoder Transcoder address\n     * @return true if transcoder is active\n     */\n    function isActiveTranscoder(address _transcoder) public view returns (bool) {\n        Transcoder storage t = transcoders[_transcoder];\n        uint256 currentRound = roundsManager().currentRound();\n        return t.activationRound <= currentRound && currentRound < t.deactivationRound;\n    }\n\n    /**\n     * @notice Return whether a transcoder is registered\n     * @param _transcoder Transcoder address\n     * @return true if transcoder is self-bonded\n     */\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\n        Delegator storage d = delegators[_transcoder];\n        return d.delegateAddress == _transcoder && d.bondedAmount > 0;\n    }\n\n    /**\n     * @notice Return whether an unbonding lock for a delegator is valid\n     * @param _delegator Address of delegator\n     * @param _unbondingLockId ID of unbonding lock\n     * @return true if unbondingLock for ID has a non-zero withdraw round\n     */\n    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {\n        // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)\n        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;\n    }\n\n    /**\n     * @notice Return an EarningsPool.Data struct with cumulative factors for a given round that are rescaled if needed\n     * @param _transcoder Storage pointer to a transcoder struct\n     * @param _round The round to fetch the cumulative factors for\n     */\n    function cumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round)\n        internal\n        view\n        returns (EarningsPool.Data memory pool)\n    {\n        pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_round].cumulativeRewardFactor;\n        pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_round].cumulativeFeeFactor;\n\n        uint256 lip71Round = roundsManager().lipUpgradeRound(71);\n        // If we are at or after the LIP-71 round then all cumulative factor values should be scaled using PreciseMathUtils.percPoints(1, 1)\n        // If a cumulative factor was stored before the LIP-71 round it will still be scaled using MathUtils.percPoints(1, 1)\n        // So, once we are at or after the LIP-71 round, if we read a cumulative factor for a round before the LIP-71 round, we rescale\n        // the value by RESCALE_FACTOR so that the end value is scaled by PreciseMathUtils.percPoints(1, 1)\n        if (roundsManager().currentRound() >= lip71Round) {\n            if (_round < lip71Round) {\n                pool.cumulativeRewardFactor = pool.cumulativeRewardFactor.mul(RESCALE_FACTOR);\n                pool.cumulativeFeeFactor = pool.cumulativeFeeFactor.mul(RESCALE_FACTOR);\n            } else {\n                // There was a bug in bondWithHint() that allowed cumulative factors to be stored after LIP-71 round to still be scaled using MathUtils.percPoints(1, 1)\n                // If we read a cumulativeRewardFactor for a round after the LIP-71 round and it is less than PreciseMathUtils.percPoints(1, 1), it was\n                // affected by this bug so we rescale it by RESCALE_FACTOR\n                if (pool.cumulativeRewardFactor < PreciseMathUtils.percPoints(1, 1)) {\n                    pool.cumulativeRewardFactor = pool.cumulativeRewardFactor.mul(RESCALE_FACTOR);\n                }\n\n                if (_round <= roundsManager().lipUpgradeRound(78)) {\n                    if (\n                        // As of the LIP-78 round, the only post LIP-71 round CFF values that are below MathUtils.percPoints(1, 1)\n                        // are CFF values that were copied from pre LIP-71 round without multiplying by RESCALE_FACTOR due to a bug.\n                        pool.cumulativeFeeFactor < MathUtils.percPoints(1, 1)\n                    ) {\n                        // At this point, we know that the CFF was copied from pre LIP-71 round without multiplying by RESCALE_FACTOR due to a bug.\n                        // Correct this by multiplying by RESCALE_FACTOR.\n                        pool.cumulativeFeeFactor = pool.cumulativeFeeFactor.mul(RESCALE_FACTOR);\n                    } else if (\n                        // As of the LIP-78 round, the only CFF values > 10 ** 32 are ones that were corrupted due to a bug\n                        // that caused CFF values to be multiplied by RESCALE_FACTOR unnecessarily.\n                        pool.cumulativeFeeFactor > LIP_78_MAX_CFF\n                    ) {\n                        // At this point, we know that the CFF was multiplied by RESCALE_FACTOR unnecessarily.\n                        // Correct this by dividing by RESCALE_FACTOR.\n                        pool.cumulativeFeeFactor = pool.cumulativeFeeFactor.div(RESCALE_FACTOR);\n                    }\n                }\n            }\n        }\n\n        return pool;\n    }\n\n    /**\n     * @notice Return an EarningsPool.Data struct with the latest cumulative factors for a given round\n     * @param _transcoder Storage pointer to a transcoder struct\n     * @param _round The round to fetch the latest cumulative factors for\n     * @return pool An EarningsPool.Data populated with the latest cumulative factors for _round\n     */\n    function latestCumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round)\n        internal\n        view\n        returns (EarningsPool.Data memory pool)\n    {\n        pool = cumulativeFactorsPool(_transcoder, _round);\n\n        uint256 lastRewardRound = _transcoder.lastRewardRound;\n        // Only use the cumulativeRewardFactor for lastRewardRound if lastRewardRound is before _round\n        if (pool.cumulativeRewardFactor == 0 && lastRewardRound < _round) {\n            pool.cumulativeRewardFactor = cumulativeFactorsPool(_transcoder, lastRewardRound).cumulativeRewardFactor;\n        }\n\n        uint256 lastFeeRound = _transcoder.lastFeeRound;\n        // Only use the cumulativeFeeFactor for lastFeeRound if lastFeeRound is before _round\n        if (pool.cumulativeFeeFactor == 0 && lastFeeRound < _round) {\n            pool.cumulativeFeeFactor = cumulativeFactorsPool(_transcoder, lastFeeRound).cumulativeFeeFactor;\n        }\n\n        return pool;\n    }\n\n    /**\n     * @notice Return a delegator's cumulative stake and fees using the LIP-36 earnings claiming algorithm\n     * @param _transcoder Storage pointer to a transcoder struct for a delegator's delegate\n     * @param _startRound The round for the start cumulative factors\n     * @param _endRound The round for the end cumulative factors\n     * @param _stake The delegator's initial stake before including earned rewards\n     * @param _fees The delegator's initial fees before including earned fees\n     * @return (cStake, cFees) where cStake is the delegator's cumulative stake including earned rewards and cFees is the delegator's cumulative fees including earned fees\n     */\n    function delegatorCumulativeStakeAndFees(\n        Transcoder storage _transcoder,\n        uint256 _startRound,\n        uint256 _endRound,\n        uint256 _stake,\n        uint256 _fees\n    ) internal view returns (uint256 cStake, uint256 cFees) {\n        // Fetch start cumulative factors\n        EarningsPool.Data memory startPool = cumulativeFactorsPool(_transcoder, _startRound);\n\n        // We can lookback for a cumulativeRewardFactor if the start cumulativeRewardFactor is 0\n        // Do not lookback if the latest cumulativeRewardFactor is 0 because that indicates that the factor was never > 0 for the transcoder in the past\n        bool lookbackCumulativeRewardFactor = _transcoder\n            .earningsPoolPerRound[_transcoder.lastRewardRound]\n            .cumulativeRewardFactor >\n            0 &&\n            startPool.cumulativeRewardFactor == 0;\n        // We can lookback for a cumulativeFeeFactor if the start cumulativeFeeFactor is 0\n        // Do not lookback if the latest cumulativeFeeFactor is 0 because that indicates that the factor was never > 0 for the transcoder in the past\n        bool lookbackCumulativeFeeFactor = _transcoder\n            .earningsPoolPerRound[_transcoder.lastFeeRound]\n            .cumulativeFeeFactor >\n            0 &&\n            startPool.cumulativeFeeFactor == 0;\n        // The lookback loop will only be needed for a few accounts delegated to transcoders before the update that ensures start factors are always initialized\n        // If we need a cumulativeRewardFactor OR cumulativeFeeFactor lookback up to min(MAX_LOOKBACK_ROUNDS, _startRound) # of rounds\n        uint256 lip36Round = roundsManager().lipUpgradeRound(36);\n        for (\n            uint256 lookback = 1;\n            lookback <= MAX_LOOKBACK_ROUNDS &&\n                lookback <= _startRound &&\n                (lookbackCumulativeRewardFactor || lookbackCumulativeFeeFactor);\n            lookback++\n        ) {\n            uint256 lookbackRound = _startRound.sub(lookback);\n            // Cannot lookback past the LIP-36 upgrade round\n            if (lookbackRound < lip36Round) {\n                break;\n            }\n\n            EarningsPool.Data storage pool = _transcoder.earningsPoolPerRound[lookbackRound];\n            // Short-circuit in the following conditionals by running the boolean check before the storage check\n            if (lookbackCumulativeRewardFactor && pool.cumulativeRewardFactor > 0) {\n                startPool.cumulativeRewardFactor = cumulativeFactorsPool(_transcoder, lookbackRound)\n                    .cumulativeRewardFactor;\n                lookbackCumulativeRewardFactor = false;\n            }\n            if (lookbackCumulativeFeeFactor && pool.cumulativeFeeFactor > 0) {\n                startPool.cumulativeFeeFactor = cumulativeFactorsPool(_transcoder, lookbackRound).cumulativeFeeFactor;\n                lookbackCumulativeFeeFactor = false;\n            }\n        }\n\n        // If the start cumulativeRewardFactor is 0 and we are before the LIP-71 round, set the default value to\n        // MathUtils.percPoints(1, 1) because we only set the default value to PreciseMathUtils.percPoints(1, 1) from LIP-71 round\n        // and onward\n        if (startPool.cumulativeRewardFactor == 0) {\n            startPool.cumulativeRewardFactor = roundsManager().currentRound() < roundsManager().lipUpgradeRound(71)\n                ? MathUtils.percPoints(1, 1)\n                : PreciseMathUtils.percPoints(1, 1);\n        }\n\n        // Fetch end cumulative factors\n        EarningsPool.Data memory endPool = latestCumulativeFactorsPool(_transcoder, _endRound);\n\n        // If the end cumulativeRewardFactor is 0 and we are before the LIP-71 round, set the default value to\n        // MathUtils.percPoints(1, 1) because we only set the default value to PreciseMathUtils.percPoints(1, 1) from LIP-71 round\n        // and onward\n        if (endPool.cumulativeRewardFactor == 0) {\n            endPool.cumulativeRewardFactor = roundsManager().currentRound() < roundsManager().lipUpgradeRound(71)\n                ? MathUtils.percPoints(1, 1)\n                : PreciseMathUtils.percPoints(1, 1);\n        }\n\n        cFees = _fees.add(\n            PreciseMathUtils.percOf(\n                _stake,\n                endPool.cumulativeFeeFactor.sub(startPool.cumulativeFeeFactor),\n                startPool.cumulativeRewardFactor\n            )\n        );\n\n        cStake = PreciseMathUtils.percOf(_stake, endPool.cumulativeRewardFactor, startPool.cumulativeRewardFactor);\n\n        return (cStake, cFees);\n    }\n\n    /**\n     * @notice Return the pending stake and fees for a delegator\n     * @param _delegator Address of a delegator\n     * @param _endRound The last round to claim earnings for when calculating the pending stake and fees\n     * @return (stake, fees) where stake is the delegator's pending stake and fees is the delegator's pending fees\n     */\n    function pendingStakeAndFees(address _delegator, uint256 _endRound)\n        internal\n        view\n        returns (uint256 stake, uint256 fees)\n    {\n        Delegator storage del = delegators[_delegator];\n        Transcoder storage t = transcoders[del.delegateAddress];\n\n        fees = del.fees;\n        stake = del.bondedAmount;\n\n        uint256 startRound = del.lastClaimRound.add(1);\n        address delegateAddr = del.delegateAddress;\n        bool isTranscoder = _delegator == delegateAddr;\n\n        uint256 lip36Round = roundsManager().lipUpgradeRound(36);\n        while (startRound <= _endRound && startRound <= lip36Round) {\n            EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[startRound];\n\n            // If earningsPool.hasTranscoderRewardFeePool is not set during lip36Round then the transcoder did not call\n            // reward during lip36Round before the upgrade. In this case, if the transcoder calls reward in lip36Round\n            // the delegator can use the LIP-36 earnings claiming algorithm to claim for lip36Round\n            if (startRound == lip36Round && !earningsPool.hasTranscoderRewardFeePool) {\n                break;\n            }\n\n            if (earningsPool.hasClaimableShares()) {\n                // Calculate and add fee pool share from this round\n                fees = fees.add(earningsPool.feePoolShare(stake, isTranscoder));\n                // Calculate new bonded amount with rewards from this round. Updated bonded amount used\n                // to calculate fee pool share in next round\n                stake = stake.add(earningsPool.rewardPoolShare(stake, isTranscoder));\n            }\n\n            startRound = startRound.add(1);\n        }\n\n        // If the transcoder called reward during lip36Round the upgrade, then startRound = lip36Round\n        // Otherwise, startRound = lip36Round + 1\n\n        // If the start round is greater than the end round, we've already claimed for the end round so we do not\n        // need to execute the LIP-36 earnings claiming algorithm. This could be the case if:\n        // - _endRound < lip36Round i.e. we are not claiming through the lip36Round\n        // - _endRound == lip36Round AND startRound = lip36Round + 1 i.e we already claimed through the lip36Round\n\n        // The LIP-36 earnings claiming algorithm uses the cumulative factors from the delegator's lastClaimRound i.e. startRound - 1\n        // and from the specified _endRound\n        // We only need to execute this algorithm if the end round >= lip36Round\n        if (_endRound >= lip36Round) {\n            // Make sure there is a round to claim i.e. end round - (start round - 1) > 0\n            if (startRound <= _endRound) {\n                (stake, fees) = delegatorCumulativeStakeAndFees(t, startRound.sub(1), _endRound, stake, fees);\n            }\n            // cumulativeRewards and cumulativeFees will track *all* rewards/fees earned by the transcoder\n            // so it is important that this is only executed with the end round as the current round or else\n            // the returned stake and fees will reflect rewards/fees earned in the future relative to the end round\n            if (isTranscoder) {\n                stake = stake.add(t.cumulativeRewards);\n                fees = fees.add(t.cumulativeFees);\n            }\n        }\n\n        return (stake, fees);\n    }\n\n    /**\n     * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'\n     * @param _delegate The delegate to increase the stake for\n     * @param _amount The amount to increase the stake for '_delegate' by\n     */\n    function increaseTotalStake(\n        address _delegate,\n        uint256 _amount,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        if (isRegisteredTranscoder(_delegate)) {\n            uint256 currStake = transcoderTotalStake(_delegate);\n            uint256 newStake = currStake.add(_amount);\n            uint256 currRound = roundsManager().currentRound();\n            uint256 nextRound = currRound.add(1);\n\n            // If the transcoder is already in the active set update its stake and return\n            if (transcoderPoolV2.contains(_delegate)) {\n                transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\n                nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);\n                Transcoder storage t = transcoders[_delegate];\n\n                // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound\n                // because it is updated every time lastActiveStakeUpdateRound is updated\n                // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()\n                // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound\n                if (t.lastActiveStakeUpdateRound < currRound) {\n                    t.earningsPoolPerRound[currRound].setStake(currStake);\n                }\n\n                t.earningsPoolPerRound[nextRound].setStake(newStake);\n                t.lastActiveStakeUpdateRound = nextRound;\n            } else {\n                // Check if the transcoder is eligible to join the active set in the update round\n                tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);\n            }\n        }\n\n        // Increase delegate's delegated amount\n        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount);\n    }\n\n    /**\n     * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'\n     * @param _delegate The transcoder to decrease the stake for\n     * @param _amount The amount to decrease the stake for '_delegate' by\n     */\n    function decreaseTotalStake(\n        address _delegate,\n        uint256 _amount,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        if (transcoderPoolV2.contains(_delegate)) {\n            uint256 currStake = transcoderTotalStake(_delegate);\n            uint256 newStake = currStake.sub(_amount);\n            uint256 currRound = roundsManager().currentRound();\n            uint256 nextRound = currRound.add(1);\n\n            transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\n            nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);\n            Transcoder storage t = transcoders[_delegate];\n\n            // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound\n            // because it is updated every time lastActiveStakeUpdateRound is updated\n            // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()\n            // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound\n            if (t.lastActiveStakeUpdateRound < currRound) {\n                t.earningsPoolPerRound[currRound].setStake(currStake);\n            }\n\n            t.lastActiveStakeUpdateRound = nextRound;\n            t.earningsPoolPerRound[nextRound].setStake(newStake);\n        }\n\n        // Decrease old delegate's delegated amount\n        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount);\n    }\n\n    /**\n     * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full\n     * @param _transcoder The transcoder to insert into the transcoder pool\n     * @param _totalStake The total stake for '_transcoder'\n     * @param _activationRound The round in which the transcoder should become active\n     */\n    function tryToJoinActiveSet(\n        address _transcoder,\n        uint256 _totalStake,\n        uint256 _activationRound,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;\n\n        if (transcoderPoolV2.isFull()) {\n            address lastTranscoder = transcoderPoolV2.getLast();\n            uint256 lastStake = transcoderTotalStake(lastTranscoder);\n\n            // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool\n            // then the transcoder is unable to join the active set for the next round\n            if (_totalStake <= lastStake) {\n                return;\n            }\n\n            // Evict the least stake transcoder from the active set for the next round\n            // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\n            // There should be no side-effects as long as the value is properly updated on stake updates\n            // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as\n            // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.\n            transcoderPoolV2.remove(lastTranscoder);\n            transcoders[lastTranscoder].deactivationRound = _activationRound;\n            pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);\n\n            emit TranscoderDeactivated(lastTranscoder, _activationRound);\n        }\n\n        transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);\n        pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);\n        Transcoder storage t = transcoders[_transcoder];\n        t.lastActiveStakeUpdateRound = _activationRound;\n        t.activationRound = _activationRound;\n        t.deactivationRound = MAX_FUTURE_ROUND;\n        t.earningsPoolPerRound[_activationRound].setStake(_totalStake);\n        nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;\n        emit TranscoderActivated(_transcoder, _activationRound);\n    }\n\n    /**\n     * @dev Remove a transcoder from the pool and deactivate it\n     */\n    function resignTranscoder(address _transcoder) internal {\n        // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\n        // There should be no side-effects as long as the value is properly updated on stake updates\n        // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as\n        // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.\n        transcoderPoolV2.remove(_transcoder);\n        nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));\n        uint256 deactivationRound = roundsManager().currentRound().add(1);\n        transcoders[_transcoder].deactivationRound = deactivationRound;\n        emit TranscoderDeactivated(_transcoder, deactivationRound);\n    }\n\n    /**\n     * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.\n     * See SortedDoublyLL.sol for details on list hints\n     * @param _transcoder Address of transcoder\n     * @param _rewards Amount of rewards\n     * @param _round Round that transcoder is updated\n     * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool\n     * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool\n     */\n    function updateTranscoderWithRewards(\n        address _transcoder,\n        uint256 _rewards,\n        uint256 _round,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        Transcoder storage t = transcoders[_transcoder];\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];\n        EarningsPool.Data memory prevEarningsPool = cumulativeFactorsPool(t, t.lastRewardRound);\n\n        // If the previous cumulativeRewardFactor is 0 and we are before the LIP-71 round, set the default value to\n        // MathUtils.percPoints(1, 1) because we only set the default value to PreciseMathUtils.percPoints(1, 1) when storing for\n        // the LIP-71 round and onwards (see updateCumulativeRewardFactor() in EarningsPoolLIP36.sol)\n        if (prevEarningsPool.cumulativeRewardFactor == 0 && _round < roundsManager().lipUpgradeRound(71)) {\n            prevEarningsPool.cumulativeRewardFactor = MathUtils.percPoints(1, 1);\n        }\n\n        t.activeCumulativeRewards = t.cumulativeRewards;\n\n        uint256 transcoderCommissionRewards = MathUtils.percOf(_rewards, earningsPool.transcoderRewardCut);\n        uint256 delegatorsRewards = _rewards.sub(transcoderCommissionRewards);\n        // Calculate the rewards earned by the transcoder's earned rewards\n        uint256 transcoderRewardStakeRewards = PreciseMathUtils.percOf(\n            delegatorsRewards,\n            t.activeCumulativeRewards,\n            earningsPool.totalStake\n        );\n        // Track rewards earned by the transcoder based on its earned rewards and rewardCut\n        t.cumulativeRewards = t.cumulativeRewards.add(transcoderRewardStakeRewards).add(transcoderCommissionRewards);\n        // Update cumulative reward factor with new rewards\n        // The cumulativeRewardFactor is used to calculate rewards for all delegators including the transcoder (self-delegated)\n        // Note that delegatorsRewards includes transcoderRewardStakeRewards, but no delegator will claim that amount using\n        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeRewards field\n        earningsPool.updateCumulativeRewardFactor(prevEarningsPool, delegatorsRewards);\n        // Update transcoder's total stake with rewards\n        increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext);\n    }\n\n    /**\n     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round\n     * @param _delegator Delegator address\n     * @param _endRound The last round for which to update a delegator's stake with earnings pool shares\n     * @param _lastClaimRound The round for which a delegator has last claimed earnings\n     */\n    function updateDelegatorWithEarnings(\n        address _delegator,\n        uint256 _endRound,\n        uint256 _lastClaimRound\n    ) internal {\n        Delegator storage del = delegators[_delegator];\n        uint256 startRound = _lastClaimRound.add(1);\n        uint256 currentBondedAmount = del.bondedAmount;\n        uint256 currentFees = del.fees;\n\n        uint256 lip36Round = roundsManager().lipUpgradeRound(36);\n\n        // Only will have earnings to claim if you have a delegate\n        // If not delegated, skip the earnings claim process\n        if (del.delegateAddress != address(0)) {\n            if (startRound <= lip36Round) {\n                // Cannot claim earnings for more than maxEarningsClaimsRounds before LIP-36\n                // This is a number to cause transactions to fail early if\n                // we know they will require too much gas to loop through all the necessary rounds to claim earnings\n                // The user should instead manually invoke `claimEarnings` to split up the claiming process\n                // across multiple transactions\n                uint256 endLoopRound = _endRound <= lip36Round ? _endRound : lip36Round;\n                require(\n                    endLoopRound.sub(_lastClaimRound) <= maxEarningsClaimsRounds,\n                    \"too many rounds to claim through\"\n                );\n            }\n\n            (currentBondedAmount, currentFees) = pendingStakeAndFees(_delegator, _endRound);\n\n            // Only execute cumulative factor logic after LIP-36 upgrade round\n            // After LIP-36 upgrade round the following code block should only be executed if _endRound is the current round\n            // See claimEarnings() and autoClaimEarnings()\n            if (_endRound >= lip36Round) {\n                // Check whether the endEarningsPool is initialised\n                // If it is not initialised set it's cumulative factors so that they can be used when a delegator\n                // next claims earnings as the start cumulative factors (see delegatorCumulativeStakeAndFees())\n                Transcoder storage t = transcoders[del.delegateAddress];\n                EarningsPool.Data storage endEarningsPool = t.earningsPoolPerRound[_endRound];\n                if (endEarningsPool.cumulativeRewardFactor == 0) {\n                    uint256 lastRewardRound = t.lastRewardRound;\n                    if (lastRewardRound < _endRound) {\n                        endEarningsPool.cumulativeRewardFactor = cumulativeFactorsPool(t, lastRewardRound)\n                            .cumulativeRewardFactor;\n                    }\n                }\n                if (endEarningsPool.cumulativeFeeFactor == 0) {\n                    uint256 lastFeeRound = t.lastFeeRound;\n                    if (lastFeeRound < _endRound) {\n                        endEarningsPool.cumulativeFeeFactor = cumulativeFactorsPool(t, lastFeeRound)\n                            .cumulativeFeeFactor;\n                    }\n                }\n\n                if (del.delegateAddress == _delegator) {\n                    t.cumulativeFees = 0;\n                    t.cumulativeRewards = 0;\n                    // activeCumulativeRewards is not cleared here because the next reward() call will set it to cumulativeRewards\n                }\n            }\n        }\n\n        emit EarningsClaimed(\n            del.delegateAddress,\n            _delegator,\n            currentBondedAmount.sub(del.bondedAmount),\n            currentFees.sub(del.fees),\n            startRound,\n            _endRound\n        );\n\n        del.lastClaimRound = _endRound;\n        // Rewards are bonded by default\n        del.bondedAmount = currentBondedAmount;\n        del.fees = currentFees;\n    }\n\n    /**\n     * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional\n     * list hint if needed. See SortedDoublyLL.sol for details on list hints\n     * @param _delegator Address of delegator\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool\n     */\n    function processRebond(\n        address _delegator,\n        uint256 _unbondingLockId,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        Delegator storage del = delegators[_delegator];\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n        require(isValidUnbondingLock(_delegator, _unbondingLockId), \"invalid unbonding lock ID\");\n\n        uint256 amount = lock.amount;\n        // Increase delegator's bonded amount\n        del.bondedAmount = del.bondedAmount.add(amount);\n\n        // Delete lock\n        delete del.unbondingLocks[_unbondingLockId];\n\n        increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);\n\n        emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount);\n    }\n\n    /**\n     * @dev Return LivepeerToken interface\n     * @return Livepeer token contract registered with Controller\n     */\n    function livepeerToken() internal view returns (ILivepeerToken) {\n        return ILivepeerToken(controller.getContract(keccak256(\"LivepeerToken\")));\n    }\n\n    /**\n     * @dev Return Minter interface\n     * @return Minter contract registered with Controller\n     */\n    function minter() internal view returns (IMinter) {\n        return IMinter(controller.getContract(keccak256(\"Minter\")));\n    }\n\n    /**\n     * @dev Return RoundsManager interface\n     * @return RoundsManager contract registered with Controller\n     */\n    function roundsManager() internal view returns (IRoundsManager) {\n        return IRoundsManager(controller.getContract(keccak256(\"RoundsManager\")));\n    }\n\n    function _onlyTicketBroker() internal view {\n        require(msg.sender == controller.getContract(keccak256(\"TicketBroker\")), \"caller must be TicketBroker\");\n    }\n\n    function _onlyRoundsManager() internal view {\n        require(msg.sender == controller.getContract(keccak256(\"RoundsManager\")), \"caller must be RoundsManager\");\n    }\n\n    function _onlyVerifier() internal view {\n        require(msg.sender == controller.getContract(keccak256(\"Verifier\")), \"caller must be Verifier\");\n    }\n\n    function _currentRoundInitialized() internal view {\n        require(roundsManager().currentRoundInitialized(), \"current round is not initialized\");\n    }\n\n    function _autoClaimEarnings() internal {\n        uint256 currentRound = roundsManager().currentRound();\n        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;\n        if (lastClaimRound < currentRound) {\n            updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);\n        }\n    }\n}\ncontract MReserve {\n    struct ReserveInfo {\n        uint256 fundsRemaining; // Funds remaining in reserve\n        uint256 claimedInCurrentRound; // Funds claimed from reserve in current round\n    }\n\n    // Emitted when funds are added to a reserve\n    event ReserveFunded(address indexed reserveHolder, uint256 amount);\n    // Emitted when funds are claimed from a reserve\n    event ReserveClaimed(address indexed reserveHolder, address claimant, uint256 amount);\n\n    /**\n     * @notice Returns info about a reserve\n     * @param _reserveHolder Address of reserve holder\n     * @return Info about the reserve for `_reserveHolder`\n     */\n    function getReserveInfo(address _reserveHolder) public view returns (ReserveInfo memory info);\n\n    /**\n     * @notice Returns the amount of funds claimed by a claimant from a reserve\n     * @param _reserveHolder Address of reserve holder\n     * @param _claimant Address of claimant\n     * @return Amount of funds claimed by `_claimant` from the reserve for `_reserveHolder`\n     */\n    function claimedReserve(address _reserveHolder, address _claimant) public view returns (uint256);\n\n    /**\n     * @dev Adds funds to a reserve\n     * @param _reserveHolder Address of reserve holder\n     * @param _amount Amount of funds to add to reserve\n     */\n    function addReserve(address _reserveHolder, uint256 _amount) internal;\n\n    /**\n     * @dev Clears contract storage used for a reserve\n     * @param _reserveHolder Address of reserve holder\n     */\n    function clearReserve(address _reserveHolder) internal;\n\n    /**\n     * @dev Claims funds from a reserve\n     * @param _reserveHolder Address of reserve holder\n     * @param _claimant Address of claimant\n     * @param _amount Amount of funds to claim from the reserve\n     * @return Amount of funds (<= `_amount`) claimed by `_claimant` from the reserve for `_reserveHolder`\n     */\n    function claimFromReserve(\n        address _reserveHolder,\n        address _claimant,\n        uint256 _amount\n    ) internal returns (uint256);\n\n    /**\n     * @dev Returns the amount of funds remaining in a reserve\n     * @param _reserveHolder Address of reserve holder\n     * @return Amount of funds remaining in the reserve for `_reserveHolder`\n     */\n    function remainingReserve(address _reserveHolder) internal view returns (uint256);\n}\ncontract IController is Pausable {\n    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);\n\n    function setContractInfo(\n        bytes32 _id,\n        address _contractAddress,\n        bytes20 _gitCommitHash\n    ) external;\n\n    function updateController(bytes32 _id, address _controller) external;\n\n    function getContract(bytes32 _id) public view returns (address);\n}\ncontract MixinContractRegistry is MContractRegistry, ManagerProxyTarget {\n    /**\n     * @dev Checks if the current round has been initialized\n     */\n    modifier currentRoundInitialized() {\n        require(roundsManager().currentRoundInitialized(), \"current round is not initialized\");\n        _;\n    }\n\n    constructor(address _controller) internal Manager(_controller) {}\n\n    /**\n     * @dev Returns an instance of the IBondingManager interface\n     */\n    function bondingManager() internal view returns (IBondingManager) {\n        return IBondingManager(controller.getContract(keccak256(\"BondingManager\")));\n    }\n\n    /**\n     * @dev Returns an instance of the IMinter interface\n     */\n    function minter() internal view returns (IMinter) {\n        return IMinter(controller.getContract(keccak256(\"Minter\")));\n    }\n\n    /**\n     * @dev Returns an instance of the IRoundsManager interface\n     */\n    function roundsManager() internal view returns (IRoundsManager) {\n        return IRoundsManager(controller.getContract(keccak256(\"RoundsManager\")));\n    }\n}\ncontract TicketBroker is\n    MixinContractRegistry,\n    MixinReserve,\n    MixinTicketBrokerCore,\n    MixinTicketProcessor,\n    MixinWrappers\n{\n    /**\n     * @notice TicketBroker constructor. Only invokes constructor of base Manager contract with provided Controller address\n     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\n     * should be used to initialize state variables post-deployment:\n     * - setUnlockPeriod()\n     * - setTicketValidityPeriod()\n     * @param _controller Address of Controller that this contract will be registered with\n     */\n    constructor(address _controller)\n        public\n        MixinContractRegistry(_controller)\n        MixinReserve()\n        MixinTicketBrokerCore()\n        MixinTicketProcessor()\n    {}\n\n    /**\n     * @notice Sets unlockPeriod value. Only callable by the Controller owner\n     * @param _unlockPeriod Value for unlockPeriod\n     */\n    function setUnlockPeriod(uint256 _unlockPeriod) external onlyControllerOwner {\n        unlockPeriod = _unlockPeriod;\n    }\n\n    /**\n     * @notice Sets ticketValidityPeriod value. Only callable by the Controller owner\n     * @param _ticketValidityPeriod Value for ticketValidityPeriod\n     */\n    function setTicketValidityPeriod(uint256 _ticketValidityPeriod) external onlyControllerOwner {\n        require(_ticketValidityPeriod > 0, \"ticketValidityPeriod must be greater than 0\");\n\n        ticketValidityPeriod = _ticketValidityPeriod;\n    }\n}\ncontract IBondingManager {\n    event TranscoderUpdate(address indexed transcoder, uint256 rewardCut, uint256 feeShare);\n    event TranscoderActivated(address indexed transcoder, uint256 activationRound);\n    event TranscoderDeactivated(address indexed transcoder, uint256 deactivationRound);\n    event TranscoderSlashed(address indexed transcoder, address finder, uint256 penalty, uint256 finderReward);\n    event Reward(address indexed transcoder, uint256 amount);\n    event Bond(\n        address indexed newDelegate,\n        address indexed oldDelegate,\n        address indexed delegator,\n        uint256 additionalAmount,\n        uint256 bondedAmount\n    );\n    event Unbond(\n        address indexed delegate,\n        address indexed delegator,\n        uint256 unbondingLockId,\n        uint256 amount,\n        uint256 withdrawRound\n    );\n    event Rebond(address indexed delegate, address indexed delegator, uint256 unbondingLockId, uint256 amount);\n    event WithdrawStake(address indexed delegator, uint256 unbondingLockId, uint256 amount, uint256 withdrawRound);\n    event WithdrawFees(address indexed delegator);\n    event EarningsClaimed(\n        address indexed delegate,\n        address indexed delegator,\n        uint256 rewards,\n        uint256 fees,\n        uint256 startRound,\n        uint256 endRound\n    );\n\n    // Deprecated events\n    // These event signatures can be used to construct the appropriate topic hashes to filter for past logs corresponding\n    // to these deprecated events.\n    // event Bond(address indexed delegate, address indexed delegator);\n    // event Unbond(address indexed delegate, address indexed delegator);\n    // event WithdrawStake(address indexed delegator);\n    // event TranscoderUpdate(address indexed transcoder, uint256 pendingRewardCut, uint256 pendingFeeShare, uint256 pendingPricePerSegment, bool registered);\n    // event TranscoderEvicted(address indexed transcoder);\n    // event TranscoderResigned(address indexed transcoder);\n\n    // External functions\n    function updateTranscoderWithFees(\n        address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external;\n\n    function slashTranscoder(\n        address _transcoder,\n        address _finder,\n        uint256 _slashAmount,\n        uint256 _finderFee\n    ) external;\n\n    function setCurrentRoundTotalActiveStake() external;\n\n    // Public functions\n    function getTranscoderPoolSize() public view returns (uint256);\n\n    function transcoderTotalStake(address _transcoder) public view returns (uint256);\n\n    function isActiveTranscoder(address _transcoder) public view returns (bool);\n\n    function getTotalBonded() public view returns (uint256);\n}\ncontract MixinWrappers is MContractRegistry, MTicketBrokerCore {\n    /**\n     * @notice Redeems multiple winning tickets. The function will redeem all of the provided tickets and handle any failures gracefully without reverting the entire function\n     * @param _tickets Array of winning tickets to be redeemed in order to claim payment\n     * @param _sigs Array of sender signatures over the hash of tickets (`_sigs[i]` corresponds to `_tickets[i]`)\n     * @param _recipientRands Array of preimages for the recipientRandHash included in each ticket (`_recipientRands[i]` corresponds to `_tickets[i]`)\n     */\n    function batchRedeemWinningTickets(\n        Ticket[] memory _tickets,\n        bytes[] memory _sigs,\n        uint256[] memory _recipientRands\n    ) public whenSystemNotPaused currentRoundInitialized {\n        for (uint256 i = 0; i < _tickets.length; i++) {\n            redeemWinningTicketNoRevert(_tickets[i], _sigs[i], _recipientRands[i]);\n        }\n    }\n\n    /**\n     * @dev Redeems a winning ticket that has been signed by a sender and reveals the\n     recipient recipientRand that corresponds to the recipientRandHash included in the ticket\n     This function wraps `redeemWinningTicket()` and returns false if the underlying call reverts\n     * @param _ticket Winning ticket to be redeemed in order to claim payment\n     * @param _sig Sender's signature over the hash of `_ticket`\n     * @param _recipientRand The preimage for the recipientRandHash included in `_ticket`\n     * @return Boolean indicating whether the underlying `redeemWinningTicket()` call succeeded\n     */\n    function redeemWinningTicketNoRevert(\n        Ticket memory _ticket,\n        bytes memory _sig,\n        uint256 _recipientRand\n    ) internal returns (bool success) {\n        // ABI encode calldata for `redeemWinningTicket()`\n        // A tuple type is used to represent the Ticket struct in the function signature\n        bytes memory redeemWinningTicketCalldata = abi.encodeWithSignature(\n            \"redeemWinningTicket((address,address,uint256,uint256,uint256,bytes32,bytes),bytes,uint256)\",\n            _ticket,\n            _sig,\n            _recipientRand\n        );\n\n        // Call `redeemWinningTicket()`\n        // solium-disable-next-line\n        (success, ) = address(this).call(redeemWinningTicketCalldata);\n    }\n}\ncontract MTicketBrokerCore {\n    struct Ticket {\n        address recipient; // Address of ticket recipient\n        address sender; // Address of ticket sender\n        uint256 faceValue; // Face value of ticket paid to recipient if ticket wins\n        uint256 winProb; // Probability ticket will win represented as winProb / (2^256 - 1)\n        uint256 senderNonce; // Sender's monotonically increasing counter for each ticket\n        bytes32 recipientRandHash; // keccak256 hash commitment to recipient's random value\n        bytes auxData; // Auxilary data included in ticket used for additional validation\n    }\n\n    // Emitted when funds are added to a sender's deposit\n    event DepositFunded(address indexed sender, uint256 amount);\n    // Emitted when a winning ticket is redeemed\n    event WinningTicketRedeemed(\n        address indexed sender,\n        address indexed recipient,\n        uint256 faceValue,\n        uint256 winProb,\n        uint256 senderNonce,\n        uint256 recipientRand,\n        bytes auxData\n    );\n    // Emitted when a funds transfer for a winning ticket redemption is executed\n    event WinningTicketTransfer(address indexed sender, address indexed recipient, uint256 amount);\n    // Emitted when a sender requests an unlock\n    event Unlock(address indexed sender, uint256 startRound, uint256 endRound);\n    // Emitted when a sender cancels an unlock\n    event UnlockCancelled(address indexed sender);\n    // Emitted when a sender withdraws its deposit & reserve\n    event Withdrawal(address indexed sender, uint256 deposit, uint256 reserve);\n}\ncontract LivepeerToken is ILivepeerToken, VariableSupplyToken {\n    string public name = \"Livepeer Token\";\n    uint8 public decimals = 18;\n    string public symbol = \"LPT\";\n    string public version = \"0.1\";\n}\ncontract MerkleSnapshot is Manager {\n    mapping(bytes32 => bytes32) public snapshot;\n\n    constructor(address _controller) public Manager(_controller) {}\n\n    function setSnapshot(bytes32 _id, bytes32 _root) external onlyControllerOwner {\n        snapshot[_id] = _root;\n    }\n\n    function verify(\n        bytes32 _id,\n        bytes32[] calldata _proof,\n        bytes32 _leaf\n    ) external view returns (bool) {\n        return MerkleProof.verify(_proof, snapshot[_id], _leaf);\n    }\n}\n",
    "bin": []
}