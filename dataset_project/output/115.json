{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/115/core",
    "external_functions": [
        [
            "DexAddressProvider"
        ],
        [
            "IDexAddressProvider"
        ],
        [
            "AdminInceptionVault",
            "IAddressProvider",
            "IVaultsCore",
            "IVaultsDataProvider",
            "IGenericMiner",
            "IDebtNotifier"
        ],
        [
            "InceptionVaultFactory",
            "IAdminInceptionVault",
            "IAddressProvider",
            "IInceptionVaultsDataProvider",
            "IInceptionVaultPriceFeed",
            "IInceptionVaultsCore",
            "IPriceFeed"
        ],
        [
            "InceptionVaultsCore",
            "IInceptionVaultsDataProvider",
            "IAddressProvider",
            "IRatesManager",
            "IERC20",
            "IInceptionVaultPriceFeed",
            "IAdminInceptionVault",
            "ILiquidationManager",
            "ISTABLEX"
        ],
        [
            "InceptionVaultsDataProvider",
            "IRatesManager",
            "IInceptionVaultsCore",
            "IAddressProvider"
        ],
        [
            "IInceptionVaultFactory"
        ],
        [
            "ChainlinkInceptionPriceFeed",
            "IAddressProvider",
            "ERC20",
            "AggregatorV3Interface"
        ],
        [],
        [
            "DemandMinerV2",
            "IGovernanceAddressProvider",
            "IAddressProvider",
            "IERC20",
            "IMIMO",
            "IVotingEscrow"
        ],
        [
            "GenericMinerV2",
            "IAddressProvider",
            "IGovernanceAddressProvider",
            "IERC20",
            "IMIMO",
            "IVotingEscrow"
        ],
        [
            "PARMinerV2",
            "IAddressProvider",
            "IERC20",
            "IGovernanceAddressProvider",
            "IVaultsDataProvider",
            "IDexAddressProvider",
            "IVaultsCore",
            "IMIMO",
            "IVotingEscrow"
        ],
        [
            "SupplyMinerV2",
            "IAddressProvider",
            "IGovernanceAddressProvider",
            "IERC20",
            "IMIMO",
            "IVotingEscrow",
            "IVaultsDataProvider"
        ],
        [
            "VotingMinerV2",
            "IAddressProvider",
            "IGovernanceAddressProvider",
            "IERC20",
            "IMIMO",
            "IVotingEscrow"
        ],
        [
            "IDemandMinerV2"
        ],
        [
            "IGenericMinerV2"
        ],
        [
            "ISupplyMinerV2"
        ],
        [
            "IVotingMinerV2"
        ],
        [
            "BalancerV2LPOracle",
            "IBalancerVault",
            "IBalancerPool",
            "AggregatorV3Interface",
            "ERC20"
        ],
        [
            "GUniLPOracle",
            "IGUniPool",
            "ERC20",
            "AggregatorV3Interface"
        ]
    ],
    "new_contract": "contract VotingMinerV2 is IVotingMinerV2, GenericMinerV2 {\n  using SafeMath for uint256;\n\n  constructor(IGovernanceAddressProvider _addresses, BoostConfig memory _boostConfig)\n    public\n    GenericMinerV2(_addresses, _boostConfig)\n  {}\n\n  /**\n    Releases the outstanding MIMO balance to the user\n    @param _user the address of the user for which the MIMO tokens will be released\n  */\n  function releaseMIMO(address _user) external {\n    UserInfo memory _userInfo = _users[_user];\n    _refresh();\n\n    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n    uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n\n    if (_userInfo.stakeWithBoost > 0) {\n      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);\n      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    }\n\n    _syncStake(_user, _userInfo);\n\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    _updateBoost(_user, _userInfo);\n\n    if (pendingMIMO > 0) {\n      require(_a.mimo().transfer(_user, pendingMIMO), \"LM100\");\n    }\n    if (pendingPAR > 0) {\n      require(_par.transfer(_user, pendingPAR), \"LM100\");\n    }\n  }\n\n  /**\n    Updates user stake based on current user baseDebt\n    @dev this method is for upgradability purposes from an older VotingMiner to a newer one so the user doesn't have to call releaseMIMO() to set their stake in this VotingMiner\n    @param _user address of the user\n  */\n  function syncStake(address _user) public override {\n    UserInfo memory _userInfo = _users[_user];\n    _syncStake(_user, _userInfo);\n    _updateBoost(_user, _userInfo);\n  }\n\n  /**\n    Updates user stake based on current user baseDebt\n    @dev internal function to perform stake sync with VotingEscrow for both upgradability and relaseMIMO logic\n    @param _user address of the user\n  */\n  function _syncStake(address _user, UserInfo memory _userInfo) internal {\n    uint256 votingPower = _a.votingEscrow().balanceOf(_user);\n    _totalStake = _totalStake.add(votingPower).sub(_userInfo.stake);\n    _userInfo.stake = votingPower;\n  }\n}\ncontract GUniLPOracle is AggregatorV3Interface {\n  using SafeMath for uint256;\n\n  string public override description;\n  uint256 public override version = 3;\n  uint8 public override decimals;\n\n  IGUniPool public immutable pool;\n  AggregatorV3Interface public immutable oracleA;\n  AggregatorV3Interface public immutable oracleB;\n\n  uint256 private immutable _tokenDecimalsUnitA;\n  uint256 private immutable _tokenDecimalsOffsetA;\n  uint256 private immutable _tokenDecimalsUnitB;\n  uint256 private immutable _tokenDecimalsOffsetB;\n\n  constructor(\n    uint8 _decimals,\n    string memory _description,\n    IGUniPool _pool,\n    AggregatorV3Interface _oracleA,\n    AggregatorV3Interface _oracleB\n  ) public {\n    require(address(_pool) != address(0), \"C000\");\n    require(address(_oracleA) != address(0), \"C000\");\n    require(address(_oracleB) != address(0), \"C000\");\n\n    decimals = _decimals;\n    description = _description;\n    pool = _pool;\n    oracleA = _oracleA;\n    oracleB = _oracleB;\n\n    uint256 decimalsA = ERC20(_pool.token0()).decimals();\n    _tokenDecimalsUnitA = 10**decimalsA;\n    _tokenDecimalsOffsetA = 10**(18 - decimalsA);\n\n    uint256 decimalsB = ERC20(_pool.token1()).decimals();\n    _tokenDecimalsUnitB = 10**decimalsB;\n    _tokenDecimalsOffsetB = 10**(18 - decimalsB);\n  }\n\n  function getRoundData(uint80 _roundId)\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    // Skip the implementation since it is not used by price feed\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @return roundId is the round ID from the aggregator for which the data was\n   * retrieved combined with an phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function latestRoundData()\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();\n    (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();\n    uint256 priceA = uint256(answerA);\n    uint256 priceB = uint256(answerB);\n    uint160 sqrtPriceX96 = uint160(\n      MathPow.sqrt((priceA.mul(_tokenDecimalsUnitB).mul(1 << 96)) / (priceB.mul(_tokenDecimalsUnitA))) << 48\n    );\n\n    (uint256 rA, uint256 rB) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);\n    require(rA > 0 || rB > 0, \"C100\");\n    uint256 totalSupply = pool.totalSupply();\n    require(totalSupply >= 1e9, \"C101\");\n\n    answer = int256(\n      priceA.mul(rA.mul(_tokenDecimalsOffsetA)).add(priceB.mul(rB.mul(_tokenDecimalsOffsetB))).div(totalSupply)\n    );\n    updatedAt = assetUpdatedAtA;\n\n    // use ealier time for updateAt\n    if (assetUpdatedAtA > assetUpdatedAtB) {\n      updatedAt = assetUpdatedAtB;\n    }\n  }\n}\ncontract AdminInceptionVault is IAdminInceptionVault, BoringOwnable, Initializable {\n  using SafeERC20 for IERC20;\n\n  IAddressProvider private _a;\n  IDebtNotifier private _debtNotifier;\n  IWETH private _weth;\n  IERC20 private _mimo;\n  IInceptionVaultsCore private _inceptionCore;\n\n  uint8 private _collateralCount;\n  mapping(uint8 => address) private _collaterals;\n  mapping(address => uint8) private _collateralId;\n\n  modifier onlyInceptionVaultsCore() {\n    require(address(_inceptionCore) == msg.sender, \"IV011\");\n    _;\n  }\n\n  function initialize(\n    address _owner,\n    IAddressProvider addressProvider,\n    IDebtNotifier debtNotifier,\n    IWETH weth,\n    IERC20 mimo,\n    IInceptionVaultsCore inceptionVaultsCore\n  ) external override initializer {\n    _a = addressProvider;\n    _debtNotifier = debtNotifier;\n    _weth = weth;\n    _mimo = mimo;\n    _inceptionCore = inceptionVaultsCore;\n    owner = _owner;\n  }\n\n  /**\n    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral\n    @dev A new vault is created if no WETH vault exists\n  **/\n  function depositETH() external payable override onlyOwner {\n    _a.core().depositETH{ value: msg.value }();\n  }\n\n  /**\n    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI\n    @dev see depositETH() and borrow()\n    @param _borrowAmount the amount of borrowed StableX tokens in WEI.\n  **/\n  function depositETHAndBorrow(uint256 _borrowAmount) external payable override onlyOwner {\n    _a.core().depositETHAndBorrow{ value: msg.value }(_borrowAmount);\n  }\n\n  /**\n    Deposit an ERC20 token into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI\n    @dev see deposit() and borrow()\n    @param _collateralType the address of the collateral type to be deposited\n    @param _depositAmount the amount of tokens to be deposited in WEI.\n    @param _borrowAmount the amount of borrowed StableX tokens in WEI.\n  **/\n  function depositAndBorrow(\n    address _collateralType,\n    uint256 _depositAmount,\n    uint256 _borrowAmount\n  ) external override onlyOwner {\n    IERC20 asset = IERC20(_collateralType);\n    asset.safeTransferFrom(msg.sender, address(this), _depositAmount);\n    asset.safeIncreaseAllowance(address(_a.core()), _depositAmount);\n    _a.core().depositAndBorrow(_collateralType, _depositAmount, _borrowAmount);\n    if (_collateralId[_collateralType] == 0) {\n      uint8 newId = ++_collateralCount;\n      _collateralId[_collateralType] = newId;\n      _collaterals[newId] = _collateralType;\n    }\n  }\n\n  /**\n    Withdraws ERC20 tokens from a vault.\n    @dev Only the owner of a vault can withdraw collateral from it.\n    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\n    @param _amount the amount of ERC20 tokens to be withdrawn in WEI.\n  **/\n  function withdraw(uint256 _vaultId, uint256 _amount) external override onlyOwner {\n    _a.core().withdraw(_vaultId, _amount);\n    IERC20 asset = IERC20(_a.vaultsData().vaultCollateralType(_vaultId));\n    asset.safeTransfer(msg.sender, _amount);\n  }\n\n  /**\n    Releases the outstanding MIMO balance.\n  */\n  function claimMimo() external override {\n    for (uint8 i = 1; i < _collateralCount + 1; i++) {\n      IGenericMiner supplyMiner = IGenericMiner(address(_debtNotifier.collateralSupplyMinerMapping(_collaterals[i])));\n      if (supplyMiner.pendingMIMO(address(this)) != 0) {\n        supplyMiner.releaseMIMO(address(this));\n      }\n    }\n  }\n\n  /**\n    Lends PAR to inceptionVault user. \n    @dev This function cn only be called by the InceptionVaultsCore.\n    @param _amount the amount of PAR to be lended.\n    @param _to the address of the inceptionVault user.\n  */\n  function lendPAR(uint256 _amount, address _to) external override onlyInceptionVaultsCore() {\n    IERC20 stablex = IERC20(_a.stablex());\n    stablex.safeTransfer(_to, _amount);\n  }\n\n  /**\n    @dev See {IERC20-transfer}.\n  */\n  function transferMimo(uint256 _amount, address _to) external override onlyOwner {\n    _mimo.safeTransfer(_to, _amount);\n  }\n\n  /**\n    @dev See {IERC20-transfer}.\n  */\n  function transferPar(uint256 _amount, address _to) external override onlyOwner {\n    IERC20 par = IERC20(address(_a.stablex()));\n    par.safeTransfer(_to, _amount);\n  }\n\n  /**\n    Deposit an ERC20 token into the vault of the msg.sender as collateral\n    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.\n    this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param _collateralType the address of the collateral type to be deposited\n    @param _amount the amount of tokens to be deposited in WEI.\n  **/\n  function deposit(address _collateralType, uint256 _amount) public override onlyOwner {\n    IERC20 asset = IERC20(_collateralType);\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\n    asset.safeIncreaseAllowance(address(_a.core()), _amount);\n    _a.core().deposit(_collateralType, _amount);\n  }\n\n  /**\n    Borrow new PAR tokens from a vault.\n    @dev Only the owner of a vault can borrow from it.\n    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.\n     `borrow()` will fail if it would bring the vault below the minimum collateralization treshold.\n    @param _vaultId the ID of the vault from which to borrow.\n    @param _amount the amount of borrowed PAR tokens in WEI.\n  **/\n  function borrow(uint256 _vaultId, uint256 _amount) public override onlyOwner {\n    _a.core().borrow(_vaultId, _amount);\n    IVaultsDataProvider vaultsData = IVaultsDataProvider(_a.vaultsData());\n    address vaultCollateral = vaultsData.vaultCollateralType(_vaultId);\n    if (_collateralId[vaultCollateral] == 0) {\n      uint8 newId = ++_collateralCount;\n      _collateralId[vaultCollateral] = newId;\n      _collaterals[newId] = vaultCollateral;\n    }\n  }\n\n  function a() public view override returns (IAddressProvider) {\n    return _a;\n  }\n\n  function debtNotifier() public view override returns (IDebtNotifier) {\n    return _debtNotifier;\n  }\n\n  function weth() public view override returns (IWETH) {\n    return _weth;\n  }\n\n  function mimo() public view override returns (IERC20) {\n    return _mimo;\n  }\n\n  function inceptionCore() public view override returns (IInceptionVaultsCore) {\n    return _inceptionCore;\n  }\n\n  function collateralCount() public view override returns (uint8) {\n    return _collateralCount;\n  }\n\n  function collaterals(uint8 _id) public view override returns (address) {\n    return _collaterals[_id];\n  }\n\n  function collateralId(address _collateral) public view override returns (uint8) {\n    return _collateralId[_collateral];\n  }\n}\ncontract DexAddressProvider is IDexAddressProvider {\n  IAddressProvider private _a;\n  mapping(uint256 => Dex) private _dexMapping;\n\n  constructor(IAddressProvider a, Dex[] memory dexes) public {\n    require(address(a) != address(0), \"LM000\");\n    _a = a;\n    for (uint256 i; i < dexes.length; i++) {\n      _dexMapping[i] = Dex({ proxy: dexes[i].proxy, router: dexes[i].router });\n    }\n  }\n\n  modifier onlyManager() {\n    require(_a.controller().hasRole(_a.controller().MANAGER_ROLE(), msg.sender), \"LM010\");\n    _;\n  }\n\n  /**\n    Set the dex address for dexMapping\n    @dev only manager or address(this) can call this method.\n    @param _index the index for the dex.\n    @param _proxy the address for the proxy.\n    @param _router the address for the router.\n  */\n  function setDexMapping(\n    uint256 _index,\n    address _proxy,\n    address _router\n  ) external override onlyManager {\n    require(_proxy != address(0), \"LM000\");\n    require(_router != address(0), \"LM000\");\n    _dexMapping[_index] = Dex({ proxy: _proxy, router: _router });\n  }\n\n  function parallel() public view override returns (IAddressProvider) {\n    return _a;\n  }\n\n  /** \n    Returns proxy and router address for a specific dex index\n    @param index the index for the dex\n    @return (proxy address, router address)\n  */\n  function dexMapping(uint256 index) public view override returns (address, address) {\n    return (_dexMapping[index].proxy, _dexMapping[index].router);\n  }\n}\ncontract SupplyMinerV2 is ISupplyMinerV2, GenericMinerV2 {\n  IERC20 private immutable _collateral;\n\n  constructor(\n    IGovernanceAddressProvider _addresses,\n    BoostConfig memory _boostConfig,\n    IERC20 collateral\n  ) public GenericMinerV2(_addresses, _boostConfig) {\n    require(address(collateral) != address(0), \"LM000\");\n    _collateral = collateral;\n  }\n\n  modifier onlyNotifier() {\n    require(msg.sender == address(_a.debtNotifier()), \"LM020\");\n    _;\n  }\n\n  /**\n    Updates user stake based on current user baseDebt\n    @dev this method is for upgradability purposes from an older SupplyMiner to a newer one so the user doesn't have to repay/borrow to set their stake in this SupplyMiner\n    @param user address of the user\n  */\n  function syncStake(address user) external override {\n    uint256 vaultId = _a.parallel().vaultsData().vaultId(address(_collateral), user);\n    IVaultsDataProvider.Vault memory v = _a.parallel().vaultsData().vaults(vaultId);\n    _updateStake(user, v.baseDebt);\n  }\n\n  /**\n    Gets called by the `DebtNotifier` and will update the stake of the user\n    to match his current outstanding debt by using his baseDebt\n    @param user address of the user\n    @param newBaseDebt the new baseDebt and therefore stake for the user\n  */\n  function baseDebtChanged(address user, uint256 newBaseDebt) public override onlyNotifier {\n    _updateStake(user, newBaseDebt);\n  }\n\n  function collateral() public view override returns (IERC20) {\n    return _collateral;\n  }\n}\ncontract InceptionVaultsDataProvider is IInceptionVaultsDataProvider, Initializable {\n  using SafeMath for uint256;\n\n  IAddressProvider private _a;\n  IInceptionVaultsCore private _inceptionVaultsCore;\n\n  uint256 private _inceptionVaultCount;\n\n  uint256 private _baseDebt;\n\n  mapping(uint256 => InceptionVault) private _vaults;\n  mapping(address => uint256) private _vaultOwners;\n\n  modifier onlyInceptionCore() {\n    require(msg.sender == address(_inceptionVaultsCore), \"IV011\");\n    _;\n  }\n\n  function initialize(IInceptionVaultsCore inceptionVaultsCore, IAddressProvider addressProvider)\n    external\n    override\n    initializer\n  {\n    _inceptionVaultsCore = inceptionVaultsCore;\n    _a = addressProvider;\n  }\n\n  /**\n    Opens a new vault.\n    @dev only the vaultsCore module can call this function\n    @param _owner the owner of the new vault.\n  */\n  function createVault(address _owner) external override onlyInceptionCore returns (uint256) {\n    uint256 newId = ++_inceptionVaultCount;\n    InceptionVault memory v = InceptionVault({\n      owner: _owner,\n      collateralBalance: 0,\n      baseDebt: 0,\n      createdAt: block.timestamp\n    });\n    _vaults[newId] = v;\n    _vaultOwners[_owner] = newId;\n    return newId;\n  }\n\n  /**\n    Set the collateral balance of a vault.\n    @dev only the vaultsCore module can call this function\n    @param _vaultId Vault ID of which the collateral balance will be updated\n    @param _balance the new balance of the vault.\n  */\n  function setCollateralBalance(uint256 _vaultId, uint256 _balance) external override onlyInceptionCore {\n    require(vaultExists(_vaultId), \"IV105\");\n    InceptionVault storage v = _vaults[_vaultId];\n    v.collateralBalance = _balance;\n  }\n\n  /**\n   Set the base debt of a vault.\n    @dev only the vaultsCore module can call this function\n    @param _id Vault ID of which the base debt will be updated\n    @param _newBaseDebt the new base debt of the vault.\n  */\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external override onlyInceptionCore {\n    InceptionVault storage _vault = _vaults[_id];\n    if (_newBaseDebt > _vault.baseDebt) {\n      uint256 increase = _newBaseDebt.sub(_vault.baseDebt);\n      _baseDebt = _baseDebt.add(increase);\n    } else {\n      uint256 decrease = _vault.baseDebt.sub(_newBaseDebt);\n      _baseDebt = _baseDebt.sub(decrease);\n    }\n    _vault.baseDebt = _newBaseDebt;\n  }\n\n  /**\n    Get a vault by vault ID.\n    @param _id The vault's ID to be retrieved\n    @return struct InceptionVault {\n      address owner;\n      uint256 collateralBalance;\n      uint256 baseDebt;\n      uint256 createdAt;\n    }\n  */\n  function vaults(uint256 _id) external view override returns (InceptionVault memory) {\n    InceptionVault memory v = _vaults[_id];\n    return v;\n  }\n\n  /**\n    Get the owner of a vault.\n    @param _id the ID of the vault\n    @return owner of the vault\n  */\n  function vaultOwner(uint256 _id) external view override returns (address) {\n    return _vaults[_id].owner;\n  }\n\n  /**\n   Get the collateral balance of a vault.\n@param _id the ID of the vault\n    @return collateral balance of the vault\n  */\n  function vaultCollateralBalance(uint256 _id) external view override returns (uint256) {\n    return _vaults[_id].collateralBalance;\n  }\n\n  /**\n   Get the base debt of a vault.\n@param _id the ID of the vault\n    @return base debt of the vault\n  */\n  function vaultBaseDebt(uint256 _id) external view override returns (uint256) {\n    return _vaults[_id].baseDebt;\n  }\n\n  /**\n    Retrieve the vault id for a specified owner and collateral type.\n    @dev returns 0 for non-existing vaults\n    @param _owner address of the owner of the vault\n    @return vault id of the vault or 0\n  */\n  function vaultId(address _owner) external view override returns (uint256) {\n    return _vaultOwners[_owner];\n  }\n\n  /**\n    Calculated the total outstanding debt for a specific vault.\n    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`\n    to make sure it's up to date.\n    @param _vaultId the ID of the vault\n    @return total debt of one vault\n  */\n  function vaultDebt(uint256 _vaultId) external view override returns (uint256) {\n    InceptionVault memory v = _vaults[_vaultId];\n    return _a.ratesManager().calculateDebt(v.baseDebt, _inceptionVaultsCore.cumulativeRate());\n  }\n\n  /**\n    Checks if a specified vault exists.\n    @param _id the ID of the vault\n    @return boolean if the vault exists\n  */\n  function vaultExists(uint256 _id) public view override returns (bool) {\n    InceptionVault memory v = _vaults[_id];\n    return v.owner != address(0);\n  }\n\n  function a() public view override returns (IAddressProvider) {\n    return _a;\n  }\n\n  function inceptionVaultsCore() public view override returns (IInceptionVaultsCore) {\n    return _inceptionVaultsCore;\n  }\n\n  function inceptionVaultCount() public view override returns (uint256) {\n    return _inceptionVaultCount;\n  }\n\n  function baseDebt() public view override returns (uint256) {\n    return _baseDebt;\n  }\n}\ncontract BalancerV2LPOracle is AggregatorV3Interface, BNum {\n  using SafeMath for uint256;\n\n  string public override description;\n  uint256 public override version = 3;\n  uint8 public override decimals;\n\n  bytes32 public poolId;\n  IBalancerVault public vault;\n  IBalancerPool public pool;\n  AggregatorV3Interface public oracleA;\n  AggregatorV3Interface public oracleB;\n\n  constructor(\n    uint8 _decimals,\n    string memory _description,\n    IBalancerVault _vault,\n    bytes32 _poolId,\n    AggregatorV3Interface _oracleA,\n    AggregatorV3Interface _oracleB\n  ) public {\n    require(address(_vault) != address(0), \"C000\");\n    require(address(_oracleA) != address(0), \"C000\");\n    require(address(_oracleB) != address(0), \"C000\");\n\n    vault = _vault;\n    poolId = _poolId;\n    (address _pool, IBalancerVault.PoolSpecialization tokensNum) = vault.getPool(poolId);\n    require(tokensNum == IBalancerVault.PoolSpecialization.TWO_TOKEN, \"C001\");\n\n    decimals = _decimals;\n    description = _description;\n    pool = IBalancerPool(_pool);\n    oracleA = _oracleA;\n    oracleB = _oracleB;\n  }\n\n  function getRoundData(uint80 _roundId)\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    // Skip the implementation since it is not used by price feed\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @return roundId is the round ID from the aggregator for which the data was\n   * retrieved combined with an phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function latestRoundData()\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    (address[] memory tokens, uint256[] memory balances, ) = vault.getPoolTokens(poolId);\n    (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();\n    (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();\n\n    uint256[] memory normalizedWeights = pool.getNormalizedWeights();\n\n    uint256 pxA = uint256(answerA);\n    uint256 pxB = uint256(answerB);\n    (uint256 fairResA, uint256 fairResB) = _computeFairReserves(\n      _getNormalizedBalance(tokens[0], balances[0]),\n      _getNormalizedBalance(tokens[1], balances[1]),\n      normalizedWeights[0],\n      normalizedWeights[1],\n      pxA,\n      pxB\n    );\n\n    answer = int256(fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply()));\n    updatedAt = assetUpdatedAtA;\n\n    // use oldest timestamp for updatedAt\n    if (assetUpdatedAtA > assetUpdatedAtB) {\n      updatedAt = assetUpdatedAtB;\n    }\n  }\n\n  function _getNormalizedBalance(address token, uint256 balance) internal view returns (uint256) {\n    uint8 decimals = ERC20(token).decimals();\n    return balance.mul(MathPow.pow(10, 18 - decimals));\n  }\n\n  /// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.\n  /// @param resA Reserve of the first asset\n  /// @param resB Reserve of the second asset\n  /// @param wA Weight of the first asset\n  /// @param wB Weight of the second asset\n  /// @param pxA Fair price of the first asset\n  /// @param pxB Fair price of the second asset\n  function _computeFairReserves(\n    uint256 resA,\n    uint256 resB,\n    uint256 wA,\n    uint256 wB,\n    uint256 pxA,\n    uint256 pxB\n  ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n    // NOTE: wA + wB = 1 (normalize weights)\n    // constant product = resA^wA * resB^wB\n    // constraints:\n    // - fairResA^wA * fairResB^wB = constant product\n    // - fairResA * pxA / wA = fairResB * pxB / wB\n    // Solving equations:\n    // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n    // --> fairResA / r1^wB = constant product\n    // --> fairResA = resA^wA * resB^wB * r1^wB\n    // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n    uint256 r0 = bdiv(resA, resB);\n    uint256 r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\n    // fairResA = resA * (r1 / r0) ^ wB\n    // fairResB = resB * (r0 / r1) ^ wA\n    if (r0 > r1) {\n      uint256 ratio = bdiv(r1, r0);\n      fairResA = bmul(resA, bpow(ratio, wB));\n      fairResB = bdiv(resB, bpow(ratio, wA));\n    } else {\n      uint256 ratio = bdiv(r0, r1);\n      fairResA = bdiv(resA, bpow(ratio, wB));\n      fairResB = bmul(resB, bpow(ratio, wA));\n    }\n  }\n}\ncontract GenericMinerV2 is IGenericMinerV2 {\n  using ABDKMath64x64 for int128;\n  using ABDKMath64x64 for uint256;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  IERC20 internal immutable _par;\n  IGovernanceAddressProvider internal immutable _a;\n\n  BoostConfig internal _boostConfig;\n\n  mapping(address => UserInfo) internal _users;\n\n  uint256 internal _totalStake;\n  uint256 internal _totalStakeWithBoost;\n\n  uint256 internal _mimoBalanceTracker;\n  uint256 internal _accMimoAmountPerShare;\n\n  uint256 internal _parBalanceTracker;\n  uint256 internal _accParAmountPerShare;\n\n  modifier onlyManager {\n    require(_a.parallel().controller().hasRole(_a.parallel().controller().MANAGER_ROLE(), msg.sender), \"LM010\");\n    _;\n  }\n\n  constructor(IGovernanceAddressProvider _addresses, BoostConfig memory boostConfig) public {\n    require(address(_addresses) != address(0), \"LM000\");\n    _a = _addresses;\n    _par = IERC20(_addresses.parallel().stablex());\n    require(boostConfig.a >= 1 && boostConfig.d > 0 && boostConfig.maxBoost >= 1, \"LM004\");\n    _boostConfig = boostConfig;\n\n    emit BoostConfigSet(_boostConfig);\n  }\n\n  /**\n    Sets new boost config\n    @dev can only be called by protocol manager\n    @param newBoostConfig contains all boost multiplier parameters, see {IGenericMinerV2 - BoostConfig}\n   */\n  function setBoostConfig(BoostConfig memory newBoostConfig) external onlyManager {\n    require(newBoostConfig.a >= 1 && newBoostConfig.d > 0 && newBoostConfig.maxBoost >= 1, \"LM004\");\n    _boostConfig = newBoostConfig;\n\n    emit BoostConfigSet(_boostConfig);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function releaseRewards(address _user) public virtual override {\n    UserInfo memory _userInfo = _users[_user];\n    _releaseRewards(_user, _userInfo);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n  }\n\n  /**\n    Reapplies the boost of the user, useful if a whale's vMIMO has decreased but their boost is still the original value\n  */\n  function updateBoost(address _user) public {\n    UserInfo memory userInfo = _users[_user];\n    _updateBoost(_user, userInfo);\n  }\n\n  /**\n    Returns the number of tokens a user has staked\n    @param _user the address of the user\n    @return number of staked tokens\n  */\n  function stake(address _user) public view override returns (uint256) {\n    return _users[_user].stake;\n  }\n\n  /**\n    Returns the number of tokens a user has staked with the boost\n    @param _user the address of the user\n    @return number of staked tokens with boost\n  */\n  function stakeWithBoost(address _user) public view override returns (uint256) {\n    return _users[_user].stakeWithBoost;\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @param _user the address of the user\n    @return number of MIMO tokens that the user can claim\n  */\n  function pendingMIMO(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    return _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @param _user the address of the user\n    @return number of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function pendingPAR(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    return _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n  }\n\n  function par() public view override returns (IERC20) {\n    return _par;\n  }\n\n  function a() public view override returns (IGovernanceAddressProvider) {\n    return _a;\n  }\n\n  function boostConfig() public view override returns (BoostConfig memory) {\n    return _boostConfig;\n  }\n\n  function totalStake() public view override returns (uint256) {\n    return _totalStake;\n  }\n\n  function totalStakeWithBoost() public view override returns (uint256) {\n    return _totalStakeWithBoost;\n  }\n\n  /**\n    Returns the userInfo stored of a user\n    @param _user the address of the user\n    @return `struct UserInfo {\n      uint256 stake;\n      uint256 stakeWithBoost;\n      uint256 accAmountPerShare;\n      uint256 accParAmountPerShare;\n    }`\n  **/\n  function userInfo(address _user) public view override returns (UserInfo memory) {\n    return _users[_user];\n  }\n\n  /**\n    Refreshes the global state and subsequently increases a user's stake\n    This is an internal call and meant to be called within derivative contracts\n    @param user the address of the user\n    @param value the amount by which the stake will be increased\n  */\n  function _increaseStake(address user, uint256 value) internal {\n    require(value > 0, \"LM101\");\n    UserInfo memory _userInfo = _users[user];\n\n    _releaseRewards(user, _userInfo);\n    _totalStake = _totalStake.add(value);\n    _userInfo.stake = _userInfo.stake.add(value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(user, _userInfo);\n\n    emit StakeIncreased(user, value);\n  }\n\n  /**\n    Refreshes the global state and subsequently decreases the stake a user has\n    This is an internal call and meant to be called within derivative contracts\n    @param user the address of the user\n    @param value the amount by which the stake will be reduced\n  */\n  function _decreaseStake(address user, uint256 value) internal {\n    require(value > 0, \"LM101\");\n    UserInfo memory _userInfo = _users[user];\n    require(_userInfo.stake >= value, \"LM102\");\n\n    _releaseRewards(user, _userInfo);\n    _totalStake = _totalStake.sub(value);\n    _userInfo.stake = _userInfo.stake.sub(value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(user, _userInfo);\n\n    emit StakeDecreased(user, value);\n  }\n\n  function _releaseRewards(address _user, UserInfo memory _userInfo) internal {\n    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n    uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    _refresh();\n\n    if (_userInfo.stakeWithBoost > 0) {\n      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);\n      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    }\n\n    if (pendingMIMO > 0) {\n      require(_a.mimo().transfer(_user, pendingMIMO), \"LM100\");\n    }\n    if (pendingPAR > 0) {\n      require(_par.transfer(_user, pendingPAR), \"LM100\");\n    }\n  }\n\n  /**\n    Updates the internal state variables based on user's veMIMO hodlings\n    @param _user the address of the user\n   */\n  function _updateBoost(address _user, UserInfo memory _userInfo) internal {\n    // if user had a boost already, first remove it from the totalStakeWithBoost\n    if (_userInfo.stakeWithBoost > 0) {\n      _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);\n    }\n    uint256 multiplier = _getBoostMultiplier(_user);\n    _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);\n    _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);\n    _users[_user] = _userInfo;\n  }\n\n  /**\n    Refreshes the global state and subsequently updates a user's stake\n    This is an internal call and meant to be called within derivative contracts\n    @param user the address of the user\n    @param stake the new amount of stake for the user\n  */\n  function _updateStake(address user, uint256 stake) internal returns (bool) {\n    uint256 oldStake = _users[user].stake;\n    if (stake > oldStake) {\n      _increaseStake(user, stake.sub(oldStake));\n    }\n    if (stake < oldStake) {\n      _decreaseStake(user, oldStake.sub(stake));\n    }\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received MIMO and PAR reward tokens\n  */\n  function _refresh() internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));\n    uint256 currentParBalance = _par.balanceOf(address(this));\n    uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);\n    uint256 parReward = currentParBalance.sub(_parBalanceTracker);\n\n    _mimoBalanceTracker = currentMimoBalance;\n    _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));\n    _parBalanceTracker = currentParBalance;\n    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @return number of MIMO tokens that the user can claim\n  */\n  function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    uint256 currentBalance = _a.mimo().balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_mimoBalanceTracker);\n    uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n    return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @return number of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    uint256 currentBalance = _par.balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_parBalanceTracker);\n    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n\n    return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));\n  }\n\n  /**\n    Returns the boost multiplier the user is eligible for\n    @param _user the address of the user\n    @return the boost multiplier based on the user's veMIMO per the boost formula : a + b / (c + e^-((veMIMO / d) - e))\n   */\n  function _getBoostMultiplier(address _user) internal view returns (uint256) {\n    uint256 veMIMO = _a.votingEscrow().balanceOf(_user);\n\n    if (veMIMO == 0) return 1e18;\n\n    // Convert boostConfig variables to signed 64.64-bit fixed point numbers\n    int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);\n    int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);\n    int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);\n    int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);\n    int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);\n\n    int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000\n    int128 e2 = e1.sub(e); // x/25000 - 6\n    int128 e3 = e2.neg(); // -(x/25000 - 6)\n    int128 e4 = e3.exp(); // e^-(x/25000 - 6)\n    int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)\n    int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))\n    uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64\n    uint256 multiplier = uint256(e7); // convert to uint256\n\n    require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, \"LM103\");\n\n    return multiplier;\n  }\n}\ncontract InceptionVaultFactory is IInceptionVaultFactory, BoringOwnable {\n  using Clones for address;\n\n  IAddressProvider private immutable _a;\n  IDebtNotifier private immutable _debtNotifier;\n  IWETH private immutable _weth;\n  IERC20 private immutable _mimo;\n  address private immutable _adminInceptionVaultBase;\n  address private immutable _inceptionVaultsCoreBase;\n  address private immutable _inceptionVaultsDataProviderBase;\n\n  uint8 private _priceFeedCount;\n  uint256 private _inceptionVaultCount;\n\n  mapping(uint256 => InceptionVault) private _inceptionVaults;\n  mapping(uint8 => address) private _priceFeeds;\n  mapping(address => uint8) private _priceFeedIds;\n\n  constructor(\n    address adminInceptionVaultBase,\n    address inceptionVaultsCoreBase,\n    address inceptionVaultsDataProviderBase,\n    IAddressProvider addressProvider,\n    IDebtNotifier debtNotifier,\n    IWETH weth,\n    IERC20 mimo\n  ) public {\n    require(adminInceptionVaultBase != address(0), \"IV000\");\n    require(inceptionVaultsCoreBase != address(0), \"IV000\");\n    require(inceptionVaultsDataProviderBase != address(0), \"IV000\");\n    require(address(addressProvider) != address(0), \"IV000\");\n    require(address(debtNotifier) != address(0), \"IV000\");\n    require(address(weth) != address(0), \"IV000\");\n    require(address(mimo) != address(0), \"IV000\");\n    _adminInceptionVaultBase = adminInceptionVaultBase;\n    _inceptionVaultsCoreBase = inceptionVaultsCoreBase;\n    _inceptionVaultsDataProviderBase = inceptionVaultsDataProviderBase;\n    _a = addressProvider;\n    _debtNotifier = debtNotifier;\n    _weth = weth;\n    _mimo = mimo;\n  }\n\n  /**\n    Clones and initializes all 3 Inception Vault contracts : AdminInceptionVault, InceptionVaultsCore, InceptionVaultsDataProvider.\n    @param _vaultConfig the inception vault configuration paramaters, see {IInceptionVaultFactory - VaultConfig}.\n    @param _inceptionCollateral the address of the ERC20 token that will be set as inceptionCollateral\n  */\n  function cloneInceptionVault(\n    IInceptionVaultsCore.VaultConfig calldata _vaultConfig,\n    IERC20 _inceptionCollateral,\n    address _inceptionVaultPriceFeed,\n    address _assetOracle\n  ) external override {\n    require(address(_inceptionCollateral) != address(0), \"IV000\");\n    require(_inceptionVaultPriceFeed != address(0), \"IV000\");\n    IAdminInceptionVault adminInceptionVault = IAdminInceptionVault(_adminInceptionVaultBase.clone());\n    IInceptionVaultsCore inceptionVaultsCore = IInceptionVaultsCore(_inceptionVaultsCoreBase.clone());\n    IInceptionVaultsDataProvider inceptionVaultsDataProvider = IInceptionVaultsDataProvider(\n      _inceptionVaultsDataProviderBase.clone()\n    );\n    IInceptionVaultPriceFeed inceptionVaultPriceFeed;\n    bool isCustomPriceFeed;\n\n    if (_priceFeedIds[_inceptionVaultPriceFeed] != 0) {\n      require(address(_assetOracle) != address(0), \"IV000\");\n      inceptionVaultPriceFeed = IInceptionVaultPriceFeed(_inceptionVaultPriceFeed.clone());\n      inceptionVaultPriceFeed.initialize(_a, address(_inceptionCollateral), _assetOracle, _a.priceFeed().eurOracle());\n    } else {\n      require(address(_assetOracle) == address(0), \"IV001\");\n      inceptionVaultPriceFeed = IInceptionVaultPriceFeed(_inceptionVaultPriceFeed);\n      isCustomPriceFeed = true;\n    }\n\n    adminInceptionVault.initialize(msg.sender, _a, _debtNotifier, _weth, _mimo, inceptionVaultsCore);\n\n    inceptionVaultsCore.initialize(\n      msg.sender,\n      _vaultConfig,\n      _inceptionCollateral,\n      _a,\n      adminInceptionVault,\n      inceptionVaultsDataProvider,\n      inceptionVaultPriceFeed\n    );\n\n    inceptionVaultsDataProvider.initialize(inceptionVaultsCore, _a);\n\n    uint256 newId = ++_inceptionVaultCount;\n    InceptionVault memory v = InceptionVault({\n      owner: msg.sender,\n      adminInceptionVault: adminInceptionVault,\n      inceptionVaultsCore: inceptionVaultsCore,\n      inceptionVaultsDataProvider: inceptionVaultsDataProvider,\n      inceptionVaultPriceFeed: inceptionVaultPriceFeed,\n      isCustomPriceFeed: isCustomPriceFeed\n    });\n\n    _inceptionVaults[newId] = v;\n\n    emit InceptionVaultDeployed(\n      msg.sender,\n      adminInceptionVault,\n      inceptionVaultsCore,\n      inceptionVaultsDataProvider,\n      inceptionVaultPriceFeed\n    );\n  }\n\n  function addPriceFeed(address _address) external override onlyOwner {\n    require(_address != address(0), \"IV000\");\n    require(_priceFeedIds[_address] == 0, \"IV002\");\n    uint8 newId = ++_priceFeedCount;\n    _priceFeeds[newId] = _address;\n    _priceFeedIds[_address] = newId;\n    emit PriceFeedAdded(newId, _address);\n  }\n\n  function a() public view override returns (IAddressProvider) {\n    return _a;\n  }\n\n  function debtNotifier() public view override returns (IDebtNotifier) {\n    return _debtNotifier;\n  }\n\n  function weth() public view override returns (IWETH) {\n    return _weth;\n  }\n\n  function mimo() public view override returns (IERC20) {\n    return _mimo;\n  }\n\n  function adminInceptionVaultBase() public view override returns (address) {\n    return _adminInceptionVaultBase;\n  }\n\n  function inceptionVaultsCoreBase() public view override returns (address) {\n    return _inceptionVaultsCoreBase;\n  }\n\n  function inceptionVaultsDataProviderBase() public view override returns (address) {\n    return _inceptionVaultsDataProviderBase;\n  }\n\n  function inceptionVaultCount() public view override returns (uint256) {\n    return _inceptionVaultCount;\n  }\n\n  function priceFeedCount() public view override returns (uint8) {\n    return _priceFeedCount;\n  }\n\n  function inceptionVaults(uint256 _id) public view override returns (InceptionVault memory) {\n    return _inceptionVaults[_id];\n  }\n\n  function priceFeeds(uint8 _id) public view override returns (address) {\n    return _priceFeeds[_id];\n  }\n\n  function priceFeedIds(address _priceFeed) public view override returns (uint16) {\n    return _priceFeedIds[_priceFeed];\n  }\n}\ncontract BConst {\n  uint256 public constant BONE = 10**18;\n\n  uint256 public constant MIN_BOUND_TOKENS = 2;\n  uint256 public constant MAX_BOUND_TOKENS = 8;\n\n  uint256 public constant MIN_FEE = BONE / 10**6;\n  uint256 public constant MAX_FEE = BONE / 10;\n  uint256 public constant EXIT_FEE = 0;\n\n  uint256 public constant MIN_WEIGHT = BONE;\n  uint256 public constant MAX_WEIGHT = BONE * 50;\n  uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n  uint256 public constant MIN_BALANCE = BONE / 10**12;\n\n  uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n\n  uint256 public constant MIN_BPOW_BASE = 1 wei;\n  uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n  uint256 public constant BPOW_PRECISION = BONE / 10**10;\n\n  uint256 public constant MAX_IN_RATIO = BONE / 2;\n  uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\ncontract BoringOwnableData {\n  address public owner;\n  address public pendingOwner;\n}\ncontract InceptionVaultsCore is IInceptionVaultsCore, BoringOwnable, ReentrancyGuard, Initializable {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  uint256 internal constant _MAX_INT = 2**256 - 1;\n\n  uint256 private _cumulativeRate;\n  uint256 private _lastRefresh;\n  VaultConfig private _vaultConfig;\n\n  IAddressProvider private _a;\n  IERC20 private _inceptionCollateral;\n  IAdminInceptionVault private _adminInceptionVault;\n  IInceptionVaultsDataProvider private _inceptionVaultsData;\n  IInceptionVaultPriceFeed private _inceptionPriceFeed;\n\n  modifier onlyVaultOwner(uint256 _vaultId) {\n    require(_inceptionVaultsData.vaultOwner(_vaultId) == msg.sender, \"IV010\");\n    _;\n  }\n\n  function initialize(\n    address _owner,\n    VaultConfig memory vaultConfig,\n    IERC20 inceptionCollateral,\n    IAddressProvider addressProvider,\n    IAdminInceptionVault adminInceptionVault,\n    IInceptionVaultsDataProvider inceptionVaultsDataProvider,\n    IInceptionVaultPriceFeed inceptionPriceFeed\n  ) external override initializer {\n    _vaultConfig = vaultConfig;\n    _inceptionCollateral = inceptionCollateral;\n    _lastRefresh = block.timestamp;\n    _cumulativeRate = WadRayMath.ray();\n    _a = addressProvider;\n    _adminInceptionVault = adminInceptionVault;\n    _inceptionVaultsData = inceptionVaultsDataProvider;\n    owner = _owner;\n    _inceptionPriceFeed = inceptionPriceFeed;\n  }\n\n  /**\n    Deposit inceptionCollateral ERC20 token into the specified vault as collateral\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param _vaultId the ID of the vault in which to deposit the inceptioCollateral.\n    @param _amount the amount of tokens to be deposited in WEI.\n  **/\n  function depositByVaultId(uint256 _vaultId, uint256 _amount) external override {\n    _inceptionCollateral.safeTransferFrom(msg.sender, address(this), _amount);\n\n    _addCollateralToVaultById(_vaultId, _amount);\n  }\n\n  /**\n    Deposit inceptionCollateral ERC20 token into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI\n    @dev see deposit() and borrow()\n    @param _depositAmount the amount of inceptionCollateral to be deposited in WEI.\n    @param _borrowAmount the amount of borrowed StableX tokens in WEI.\n  **/\n  function depositAndBorrow(uint256 _depositAmount, uint256 _borrowAmount) external override {\n    deposit(_depositAmount);\n    uint256 vaultId = _inceptionVaultsData.vaultId(msg.sender);\n    borrow(vaultId, _borrowAmount);\n  }\n\n  /**\n    Withdraws inceptionCollateral ERC20 token from a vault.\n    @dev Only the owner of a vault can withdraw collateral from it.\n    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.\n    @param _vaultId the ID of the vault from which to withdraw the inceptionCollateral.\n    @param _amount the amount of inceptionCollateral ERC20 tokens to be withdrawn in WEI.\n  **/\n  function withdraw(uint256 _vaultId, uint256 _amount) external override onlyVaultOwner(_vaultId) nonReentrant {\n    _removeCollateralFromVault(_vaultId, _amount);\n    _inceptionCollateral.safeTransfer(msg.sender, _amount);\n  }\n\n  /**\n    Convenience function to repay all debt of a vault\n    @dev `repayAll()` will update the outstanding vault debt to the current time.\n    @param _vaultId the ID of the vault for which to repay the debt.\n  **/\n  function repayAll(uint256 _vaultId) external override {\n    repay(_vaultId, _MAX_INT);\n  }\n\n  /**\n    Liquidate a vault that is below the liquidation treshold by repaying its outstanding debt.\n    @dev `liquidate()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`\n    to the liquidator. `liquidate()` can be called by anyone.\n    @param _vaultId the ID of the vault to be liquidated.\n  **/\n  function liquidate(uint256 _vaultId) external override {\n    liquidatePartial(_vaultId, _MAX_INT);\n  }\n\n  /**\n    Deposit inceptionCollateral ERC20 token into the vault of the msg.sender as collateral\n    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.\n    this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param _amount the amount of tokens to be deposited in WEI.\n  **/\n  function deposit(uint256 _amount) public override {\n    require(_amount > 0, \"IV100\");\n    _inceptionCollateral.safeTransferFrom(msg.sender, address(this), _amount);\n\n    _addCollateralToVault(_amount);\n  }\n\n  /**\n    Borrow new PAR tokens from a vault.\n    @dev Only the owner of a vault can borrow from it.\n    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.\n     `borrow()` will fail if it would bring the vault below the minimum collateralization treshold.\n    @param _vaultId the ID of the vault from which to borrow.\n    @param _amount the amount of borrowed inceptionCollateral tokens in WEI.\n  **/\n  function borrow(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\n    IERC20 stablex = IERC20(_a.stablex());\n    require(_amount <= stablex.balanceOf(address(_adminInceptionVault)), \"IV104\");\n    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);\n\n    // Make sure current rate is up to date\n    _refreshCumulativeRate();\n\n    uint256 newDebt = _amount;\n    if (_vaultConfig.originationFee > 0) {\n      newDebt = newDebt.add(_amount.wadMul(_vaultConfig.originationFee));\n    }\n\n    // Increment vault borrow balance\n\n    uint256 newBaseDebt = _a.ratesManager().calculateBaseDebt(newDebt, _cumulativeRate);\n\n    _inceptionVaultsData.setBaseDebt(_vaultId, v.baseDebt.add(newBaseDebt));\n\n    uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);\n    uint256 newVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);\n\n    bool isHealthy = _a.liquidationManager().isHealthy(collateralValue, newVaultDebt, _vaultConfig.minCollateralRatio);\n\n    require(isHealthy, \"IV102\");\n\n    _adminInceptionVault.lendPAR(_amount, msg.sender);\n\n    emit Borrowed(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Repay an outstanding PAR balance to a vault.\n    @dev `repay()` will update the outstanding vault debt to the current time.\n    @param _vaultId the ID of the vault for which to repay the outstanding debt balance.\n    @param _amount the amount of PAR tokens in WEI to be repaid.\n  **/\n  function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {\n    // Make sure current rate is up to date\n    _refreshCumulativeRate();\n\n    uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);\n    // Decrement vault borrow balance\n    if (_amount >= currentVaultDebt) {\n      // Full repayment\n      _amount = currentVaultDebt; //only pay back what's outstanding\n    }\n    _reduceVaultDebt(_vaultId, _amount);\n    // This will require a user allowance first\n    IERC20 stablex = IERC20(_a.stablex());\n    stablex.safeTransferFrom(msg.sender, address(_adminInceptionVault), _amount);\n    emit Repaid(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Liquidate a vault partially that is below the liquidation treshold by repaying part of its outstanding debt.\n    @dev `liquidatePartial()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`\n    to the liquidator. A LiquidationFee will be applied to the borrower during the liquidation.\n    This means that the change in outstanding debt can be smaller than the repaid amount.\n    `liquidatePartial()` can be called by anyone.\n    @param _vaultId the ID of the vault to be liquidated.\n    @param _amount the amount of debt+liquidationFee to repay.\n  **/\n  function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {\n    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);\n    _refreshCumulativeRate();\n    uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);\n    uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);\n    require(\n      !_a.liquidationManager().isHealthy(collateralValue, currentVaultDebt, _vaultConfig.liquidationRatio),\n      \"IV103\"\n    );\n    uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(_vaultConfig.liquidationFee);\n    uint256 maxLiquidationCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);\n    uint256 repayAmount;\n    if (_amount > maxLiquidationCost) {\n      _amount = maxLiquidationCost;\n      repayAmount = currentVaultDebt;\n    } else {\n      repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);\n    }\n    uint256 collateralValueToReceive = _amount.add(_amount.wadMul(_vaultConfig.liquidationBonus));\n    uint256 insuranceAmount = 0;\n    if (collateralValueToReceive >= collateralValue) {\n      // Not enough collateral for debt & liquidation bonus\n      collateralValueToReceive = collateralValue;\n      uint256 discountedCollateralValue = collateralValue.wadDiv(_vaultConfig.liquidationBonus.add(WadRayMath.wad()));\n      if (currentVaultDebt > discountedCollateralValue) {\n        // Not enough collateral for debt alone\n        insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);\n        require(_a.stablex().balanceOf(address(_adminInceptionVault)) >= insuranceAmount, \"IV104\");\n      }\n      repayAmount = currentVaultDebt.sub(insuranceAmount);\n      _amount = discountedCollateralValue;\n    }\n    // Reduce the vault debt by repayAmount\n    _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));\n    IERC20 stablex = IERC20(_a.stablex());\n    stablex.safeTransferFrom(msg.sender, address(this), _amount);\n    stablex.safeTransfer(address(_adminInceptionVault), _amount);\n    // Send the claimed collateral to the liquidator\n    uint256 collateralToReceive = _inceptionPriceFeed.convertTo(collateralValueToReceive);\n    _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));\n    _inceptionCollateral.safeTransfer(msg.sender, collateralToReceive);\n    emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);\n  }\n\n  function cumulativeRate() public view override returns (uint256) {\n    return _cumulativeRate;\n  }\n\n  function lastRefresh() public view override returns (uint256) {\n    return _lastRefresh;\n  }\n\n  function vaultConfig() public view override returns (VaultConfig memory) {\n    return _vaultConfig;\n  }\n\n  function a() public view override returns (IAddressProvider) {\n    return _a;\n  }\n\n  function inceptionCollateral() public view override returns (IERC20) {\n    return _inceptionCollateral;\n  }\n\n  function adminInceptionVault() public view override returns (IAdminInceptionVault) {\n    return _adminInceptionVault;\n  }\n\n  function inceptionVaultsData() public view override returns (IInceptionVaultsDataProvider) {\n    return _inceptionVaultsData;\n  }\n\n  function inceptionPriceFeed() public view override returns (IInceptionVaultPriceFeed) {\n    return _inceptionPriceFeed;\n  }\n\n  function _addCollateralToVault(uint256 _amount) internal {\n    uint256 vaultId = _inceptionVaultsData.vaultId(msg.sender);\n    if (vaultId == 0) {\n      vaultId = _inceptionVaultsData.createVault(msg.sender);\n    }\n    _addCollateralToVaultById(vaultId, _amount);\n  }\n\n  function _removeCollateralFromVault(uint256 _vaultId, uint256 _amount) internal {\n    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);\n    require(_amount <= v.collateralBalance, \"IV101\");\n    uint256 newCollateralBalance = v.collateralBalance.sub(_amount);\n    _inceptionVaultsData.setCollateralBalance(_vaultId, newCollateralBalance);\n    if (v.baseDebt > 0) {\n      _refreshCumulativeRate();\n      uint256 newCollateralValue = _inceptionPriceFeed.convertFrom(newCollateralBalance);\n      require(\n        _a.liquidationManager().isHealthy(\n          newCollateralValue,\n          _inceptionVaultsData.vaults(_vaultId).baseDebt,\n          _vaultConfig.minCollateralRatio\n        ),\n        \"IV102\"\n      );\n    }\n\n    emit Withdrawn(_vaultId, _amount, msg.sender);\n  }\n\n  function _addCollateralToVaultById(uint256 _vaultId, uint256 _amount) internal {\n    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);\n    _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.add(_amount));\n    emit Deposited(_vaultId, _amount, msg.sender);\n  }\n\n  function _refreshCumulativeRate() internal {\n    uint256 timestamp = block.timestamp;\n    uint256 _timeElapsed = block.timestamp.sub(_lastRefresh);\n    _cumulativeRate = _a.ratesManager().calculateCumulativeRate(_vaultConfig.borrowRate, _cumulativeRate, _timeElapsed);\n    _lastRefresh = timestamp;\n    emit CumulativeRateUpdated(_timeElapsed, _cumulativeRate);\n  }\n\n  /**\n    Internal helper function to reduce the debt of a vault.\n    @dev assumes cumulative rates for the vault's collateral type are up to date.\n    please call `refreshCollateral()` before calling this function.\n    @param _vaultId the ID of the vault for which to reduce the debt.\n    @param _amount the amount of debt to be reduced.\n  **/\n  function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {\n    uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);\n    uint256 remainder = currentVaultDebt.sub(_amount);\n\n    if (remainder == 0) {\n      _inceptionVaultsData.setBaseDebt(_vaultId, 0);\n    } else {\n      uint256 newBaseDebt = _a.ratesManager().calculateBaseDebt(remainder, _cumulativeRate);\n      _inceptionVaultsData.setBaseDebt(_vaultId, newBaseDebt);\n    }\n  }\n}\ncontract PARMinerV2 is IGenericMinerV2 {\n  using ABDKMath64x64 for int128;\n  using ABDKMath64x64 for uint256;\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  IERC20 internal _par;\n  IGovernanceAddressProvider internal _a;\n  IDexAddressProvider internal immutable _dexAP;\n\n  BoostConfig internal _boostConfig;\n\n  mapping(address => UserInfo) internal _users;\n\n  uint256 internal _totalStake;\n  uint256 internal _totalStakeWithBoost;\n  uint256 internal _liquidateCallerReward;\n\n  uint256 internal _mimoBalanceTracker;\n  uint256 internal _accMimoAmountPerShare;\n\n  uint256 internal _parBalanceTracker;\n  uint256 internal _accParAmountPerShare;\n\n  modifier onlyManager {\n    require(_a.parallel().controller().hasRole(_a.parallel().controller().MANAGER_ROLE(), msg.sender), \"LM010\");\n    _;\n  }\n\n  constructor(\n    IGovernanceAddressProvider govAP,\n    IDexAddressProvider dexAP,\n    BoostConfig memory boostConfig\n  ) public {\n    require(address(govAP) != address(0), \"LM000\");\n    require(address(dexAP) != address(0), \"LM000\");\n    require(boostConfig.a >= 1 && boostConfig.d > 0 && boostConfig.maxBoost >= 1, \"LM004\");\n    _a = govAP;\n    _dexAP = dexAP;\n    _liquidateCallerReward = 200 ether;\n\n    _par = IERC20(govAP.parallel().stablex());\n    _par.approve(address(_a.parallel().core()), uint256(-1));\n\n    _boostConfig = boostConfig;\n\n    emit BoostConfigSet(boostConfig);\n  }\n\n  /**\n    Sets new boost config\n    @dev can only be called by protocol manager\n    @param newBoostConfig contains all boost multiplier parameters, see {IGenericMinerV2 - BoostConfig}\n   */\n  function setBoostConfig(BoostConfig memory newBoostConfig) external onlyManager {\n    require(newBoostConfig.a >= 1 && newBoostConfig.d > 0 && newBoostConfig.maxBoost >= 1, \"LM004\");\n    _boostConfig = newBoostConfig;\n\n    emit BoostConfigSet(_boostConfig);\n  }\n\n  /**\n    Sets liquidation call reward amount\n    @dev can only be called by protocol manager\n    @param amount the amount to reward liquidate method callers with\n   */\n  function setLiquidateCallerReward(uint256 amount) external onlyManager {\n    _liquidateCallerReward = amount;\n  }\n\n  /**\n    Deposit an ERC20 pool token for staking\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20\n    @param amount the amount of tokens to be deposited. Unit is in WEI\n  **/\n  function deposit(uint256 amount) public {\n    _par.safeTransferFrom(msg.sender, address(this), amount);\n    _increaseStake(msg.sender, amount);\n  }\n\n  /**\n    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked\n    @param amount the amount of tokens to be withdrawn. Unit is in WEI\n  **/\n  function withdraw(uint256 amount) public {\n    _par.safeTransfer(msg.sender, amount);\n    _decreaseStake(msg.sender, amount);\n  }\n\n  /**\n    Liquidate a vault with a specific amount, and sell collaterall back to PAR\n    @param vaultId the ID of the vault to be liquidated\n    @param amount the amount of debt+liquidationFee to repay\n    @param dexIndex the index of dex in dex address provider mapping\n    @param dexTxData the tx data used to sell collateral back to PAR\n  **/\n  function liquidate(\n    uint256 vaultId,\n    uint256 amount,\n    uint256 dexIndex,\n    bytes calldata dexTxData\n  ) public {\n    uint256 parBalanceBefore = _par.balanceOf(address(this));\n\n    IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);\n    IERC20 collateralToken = IERC20(vault.collateralType);\n    _a.parallel().core().liquidatePartial(vaultId, amount);\n\n    (address proxy, address router) = _dexAP.dexMapping(dexIndex);\n    collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));\n    router.call(dexTxData);\n    _par.safeTransfer(msg.sender, _liquidateCallerReward);\n    require(_par.balanceOf(address(this)) > parBalanceBefore, \"LM104\");\n    _refreshPAR(_totalStake);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function releaseRewards(address _user) public override {\n    UserInfo memory _userInfo = _users[_user];\n    _releaseRewards(_user, _userInfo, _totalStake, false);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n  }\n\n  /**\n    Restakes the outstanding PAR reward balance to the user. Instead of sending the PAR to the user, it will be added to their stake\n    @param _user the address of the user for which the PAR tokens will be restaked\n  */\n  function restakePAR(address _user) public {\n    UserInfo storage userInfo = _users[_user];\n    _refresh();\n    _refreshPAR(_totalStake);\n    uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\n    _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    _increaseStake(_user, pendingPAR);\n  }\n\n  /**\n    Reapplies the boost of the user, useful a whale's vMIMO has decreased but their boost is still the original value\n  */\n  function updateBoost(address _user) public {\n    UserInfo memory userInfo = _users[_user];\n    _updateBoost(_user, userInfo);\n  }\n\n  /**\n    Returns the number of tokens a user has staked\n    @param _user the address of the user\n    @return number of staked tokens\n  */\n  function stake(address _user) public view override returns (uint256) {\n    return _users[_user].stake;\n  }\n\n  /**\n    Returns the number of tokens a user has staked with the boost\n    @param _user the address of the user\n    @return number of staked tokens with boost\n  */\n  function stakeWithBoost(address _user) public view override returns (uint256) {\n    return _users[_user].stakeWithBoost;\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @param _user the address of the user\n    @return number of MIMO tokens that the user can claim\n  */\n  function pendingMIMO(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    return _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @param _user the address of the user\n    @return nnumber of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function pendingPAR(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    uint256 currentBalance = _par.balanceOf(address(this)).sub(_totalStake);\n    uint256 reward = currentBalance.sub(_parBalanceTracker);\n    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n\n    return _pendingPAR(accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n  }\n\n  function par() public view override returns (IERC20) {\n    return _par;\n  }\n\n  function a() public view override returns (IGovernanceAddressProvider) {\n    return _a;\n  }\n\n  function boostConfig() public view override returns (BoostConfig memory) {\n    return _boostConfig;\n  }\n\n  function totalStake() public view override returns (uint256) {\n    return _totalStake;\n  }\n\n  function totalStakeWithBoost() public view override returns (uint256) {\n    return _totalStakeWithBoost;\n  }\n\n  function liquidateCallerReward() public view returns (uint256) {\n    return _liquidateCallerReward;\n  }\n\n  /**\n    Returns the userInfo stored of a user\n    @param _user the address of the user\n    @return `struct UserInfo {\n      uint256 stake;\n      uint256 stakeWithBoost;\n      uint256 accAmountPerShare;\n      uint256 accParAmountPerShare;\n    }`\n  **/\n  function userInfo(address _user) public view override returns (UserInfo memory) {\n    return _users[_user];\n  }\n\n  /**\n    Refreshes the global state and subsequently increases a user's stake\n    This is an internal call and meant to be called within derivative contracts\n    @param _user the address of the user\n    @param _value the amount by which the stake will be increased\n  */\n  function _increaseStake(address _user, uint256 _value) internal {\n    require(_value > 0, \"LM101\");\n\n    UserInfo memory _userInfo = _users[_user];\n\n    uint256 newTotalStake = _totalStake.add(_value);\n\n    _releaseRewards(_user, _userInfo, newTotalStake, true);\n    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    _totalStake = newTotalStake;\n    _userInfo.stake = _userInfo.stake.add(_value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    if (pendingPAR > 0) {\n      _userInfo.stake = _userInfo.stake.add(pendingPAR);\n      _totalStake = _totalStake.add(pendingPAR);\n    }\n\n    _updateBoost(_user, _userInfo);\n\n    emit StakeIncreased(_user, _value.add(pendingPAR));\n  }\n\n  /**\n    Refreshes the global state and subsequently decreases the stake a user has\n    This is an internal call and meant to be called within derivative contracts\n    @param _user the address of the user\n    @param _value the amount by which the stake will be reduced\n  */\n  function _decreaseStake(address _user, uint256 _value) internal {\n    require(_value > 0, \"LM101\");\n    UserInfo memory _userInfo = _users[_user];\n    require(_userInfo.stake >= _value, \"LM102\");\n\n    uint256 newTotalStake = _totalStake.sub(_value);\n\n    _releaseRewards(_user, _userInfo, newTotalStake, false);\n    _totalStake = newTotalStake;\n    _userInfo.stake = _userInfo.stake.sub(_value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n\n    emit StakeDecreased(_user, _value);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function _releaseRewards(\n    address _user,\n    UserInfo memory _userInfo,\n    uint256 _newTotalStake,\n    bool _restakePAR\n  ) internal {\n    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n    _refresh();\n    _refreshPAR(_newTotalStake);\n    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    if (_userInfo.stakeWithBoost > 0) {\n      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);\n      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    }\n\n    if (pendingPAR > 0 && !_restakePAR) {\n      require(_par.transfer(_user, pendingPAR), \"LM100\");\n    }\n    if (pendingMIMO > 0) {\n      require(_a.mimo().transfer(_user, pendingMIMO), \"LM100\");\n    }\n  }\n\n  /**\n    Updates the internal state variables based on user's veMIMO hodlings\n    @param _user the address of the user\n   */\n  function _updateBoost(address _user, UserInfo memory _userInfo) internal {\n    // if user had a boost already, first remove it from the totalStakeWithBoost\n    if (_userInfo.stakeWithBoost > 0) {\n      _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);\n    }\n    uint256 multiplier = _getBoostMultiplier(_user);\n    _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);\n    _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);\n    _users[_user] = _userInfo;\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received MIMO tokens\n  */\n  function _refresh() internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));\n    uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);\n    _mimoBalanceTracker = currentMimoBalance;\n    _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received PAR tokens\n    @dev need to pass updated stake as arg because reward token and stake token are the same\n    @param newTotalStake updated total stake in PAR tokens\n  */\n  function _refreshPAR(uint256 newTotalStake) internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);\n    uint256 parReward = currentParBalance.sub(_parBalanceTracker);\n\n    _parBalanceTracker = currentParBalance;\n    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @return number of MIMO tokens that the user can claim\n  */\n  function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    uint256 currentBalance = _a.mimo().balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_mimoBalanceTracker);\n    uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n    return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @return number of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function _pendingPAR(\n    uint256 accParAmountPerShare,\n    uint256 _userStakeWithBoost,\n    uint256 _userAccParAmountPerShare\n  ) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));\n  }\n\n  /**\n    Returns the boost multiplier the user is eligible for\n    @param _user the address of the user\n    @return the boost multuplie based on the user's veMIMO per the boost formula : a + b / (c + e^-((veMIMO / d) - e))\n   */\n  function _getBoostMultiplier(address _user) internal view returns (uint256) {\n    uint256 veMIMO = _a.votingEscrow().balanceOf(_user);\n\n    if (veMIMO == 0) return 1e18;\n\n    // Convert boostConfig variables to signed 64.64-bit fixed point numbers\n    int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);\n    int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);\n    int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);\n    int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);\n    int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);\n\n    int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000\n    int128 e2 = e1.sub(e); // x/25000 - 6\n    int128 e3 = e2.neg(); // -(x/25000 - 6)\n    int128 e4 = e3.exp(); // e^-(x/25000 - 6)\n    int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)\n    int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))\n    uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64\n    uint256 multiplier = uint256(e7); // convert to uint256\n\n    require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, \"LM103\");\n\n    return multiplier;\n  }\n}\ncontract BoringOwnable is BoringOwnableData {\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /// @notice `owner` defaults to msg.sender on construction.\n  constructor() public {\n    owner = msg.sender;\n    emit OwnershipTransferred(address(0), msg.sender);\n  }\n\n  /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n  /// Can only be invoked by the current `owner`.\n  /// @param newOwner Address of the new owner.\n  /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n  /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n  function transferOwnership(\n    address newOwner,\n    bool direct,\n    bool renounce\n  ) public onlyOwner {\n    if (direct) {\n      // Checks\n      require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n      // Effects\n      emit OwnershipTransferred(owner, newOwner);\n      owner = newOwner;\n      pendingOwner = address(0);\n    } else {\n      // Effects\n      pendingOwner = newOwner;\n    }\n  }\n\n  /// @notice Needs to be called by `pendingOwner` to claim ownership.\n  function claimOwnership() public {\n    address _pendingOwner = pendingOwner;\n\n    // Checks\n    require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n    // Effects\n    emit OwnershipTransferred(owner, _pendingOwner);\n    owner = _pendingOwner;\n    pendingOwner = address(0);\n  }\n\n  /// @notice Only allows the `owner` to execute the function.\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Ownable: caller is not the owner\");\n    _;\n  }\n}\ncontract ChainlinkInceptionPriceFeed is IInceptionVaultPriceFeed, Initializable {\n  using SafeMath for uint256;\n  using SafeMath for uint8;\n  using WadRayMath for uint256;\n\n  uint256 private constant _PRICE_ORACLE_STALE_THRESHOLD = 1 days;\n\n  IAddressProvider private _a;\n\n  ERC20 private _inceptionCollateral;\n\n  AggregatorV3Interface private _assetOracle;\n\n  AggregatorV3Interface private _eurOracle;\n\n  function initialize(\n    IAddressProvider _addresses,\n    address inceptionCollateral,\n    address assetOracle,\n    AggregatorV3Interface eurOracle\n  ) external override initializer {\n    _a = _addresses;\n    _inceptionCollateral = ERC20(inceptionCollateral);\n    _assetOracle = AggregatorV3Interface(assetOracle);\n    _eurOracle = eurOracle;\n  }\n\n  /**\n   * @notice Converts asset balance into stablecoin balance at current price\n   * @param _amount amount of collateral\n   */\n  function convertFrom(uint256 _amount) external view override returns (uint256) {\n    uint256 price = getAssetPrice();\n    uint8 collateralDecimals = ERC20(_inceptionCollateral).decimals();\n    uint8 parDecimals = ERC20(address(_a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()\n    uint8 oracleDecimals = _assetOracle.decimals();\n    uint256 parAccuracy = MathPow.pow(10, parDecimals);\n    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));\n    return _amount.mul(price).mul(parAccuracy).div(collateralAccuracy);\n  }\n\n  /**\n   * @notice Converts stablecoin balance into collateral balance at current price\n   * @param _amount amount of stablecoin\n   */\n  function convertTo(uint256 _amount) external view override returns (uint256) {\n    uint256 price = getAssetPrice();\n    uint8 collateralDecimals = ERC20(_inceptionCollateral).decimals();\n    uint8 parDecimals = ERC20(address(_a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()\n    uint8 oracleDecimals = _assetOracle.decimals();\n    uint256 parAccuracy = MathPow.pow(10, parDecimals);\n    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));\n    return _amount.mul(collateralAccuracy).div(price).div(parAccuracy);\n  }\n\n  /**\n   * Gets the asset price in EUR (PAR)\n   * @dev returned value has matching decimals to the asset oracle (not the EUR oracle)\n   */\n  function getAssetPrice() public view override returns (uint256 price) {\n    (, int256 eurAnswer, , uint256 eurUpdatedAt, ) = _eurOracle.latestRoundData();\n    require(eurAnswer > 0, \"EUR price data not valid\");\n    require(block.timestamp - eurUpdatedAt < _PRICE_ORACLE_STALE_THRESHOLD, \"EUR price data is stale\");\n\n    (, int256 answer, , uint256 assetUpdatedAt, ) = _assetOracle.latestRoundData();\n    require(answer > 0, \"Price data not valid\");\n    require(block.timestamp - assetUpdatedAt < _PRICE_ORACLE_STALE_THRESHOLD, \"Price data is stale\");\n\n    uint8 eurDecimals = _eurOracle.decimals();\n    uint256 eurAccuracy = MathPow.pow(10, eurDecimals);\n    return uint256(answer).mul(eurAccuracy).div(uint256(eurAnswer));\n  }\n\n  function a() public view override returns (IAddressProvider) {\n    return _a;\n  }\n\n  function inceptionCollateral() public view override returns (ERC20) {\n    return _inceptionCollateral;\n  }\n\n  function assetOracle() public view override returns (AggregatorV3Interface) {\n    return _assetOracle;\n  }\n\n  function eurOracle() public view override returns (AggregatorV3Interface) {\n    return _eurOracle;\n  }\n}\ncontract DemandMinerV2 is IDemandMinerV2, GenericMinerV2 {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  address private _feeCollector;\n  IERC20 private immutable _token;\n\n  FeeConfig private _feeConfig;\n\n  constructor(\n    IGovernanceAddressProvider _addresses,\n    IERC20 token,\n    address feeCollector,\n    BoostConfig memory _boostConfig,\n    FeeConfig memory feeConfig\n  ) public GenericMinerV2(_addresses, _boostConfig) {\n    require(address(token) != address(0), \"LM000\");\n    require(address(token) != address(_addresses.mimo()), \"LM001\");\n    require(feeCollector != address(0), \"LM000\");\n    _token = token;\n    _feeCollector = feeCollector;\n    _feeConfig = feeConfig;\n    emit FeeCollectorSet(feeCollector);\n    emit FeeConfigSet(feeConfig);\n  }\n\n  /**\n    Sets new _feeCollector\n    @dev can only be called by protocol manager\n    @param feeCollector new feeCollector address\n   */\n  function setFeeCollector(address feeCollector) external override onlyManager {\n    _feeCollector = feeCollector;\n    emit FeeCollectorSet(feeCollector);\n  }\n\n  /**\n    Sets new _feeConfig\n    @dev can only be called by protocol manager\n    @param newFeeConfig new FeeConfig struct see {IDemandMinerV2.FeeConfig}\n   */\n  function setFeeConfig(FeeConfig memory newFeeConfig) external override onlyManager {\n    _feeConfig = newFeeConfig;\n    emit FeeConfigSet(newFeeConfig);\n  }\n\n  /**\n    Deposit an ERC20 pool token for staking\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20\n    @param amount the amount of tokens to be deposited. Unit is in WEI\n  **/\n  function deposit(uint256 amount) public override {\n    _token.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 depositAmount = amount;\n    if (_feeConfig.depositFee > 0) {\n      uint256 fee = amount.wadMul(_feeConfig.depositFee);\n      depositAmount = depositAmount.sub(fee);\n      _token.safeTransfer(_feeCollector, fee);\n      emit DepositFeeReleased(fee);\n    }\n    _increaseStake(msg.sender, depositAmount);\n  }\n\n  /**\n    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked\n    @param amount the amount of tokens to be withdrawn. Unit is in WEI\n  **/\n  function withdraw(uint256 amount) public override {\n    uint256 withdrawAmount = amount;\n    if (_feeConfig.withdrawFee > 0) {\n      uint256 fee = amount.wadMul(_feeConfig.withdrawFee);\n      withdrawAmount = withdrawAmount.sub(fee);\n      _token.safeTransfer(_feeCollector, fee);\n      emit WithdrawFeeReleased(fee);\n    }\n    _token.safeTransfer(msg.sender, withdrawAmount);\n    _decreaseStake(msg.sender, amount);\n  }\n\n  function token() public view override returns (IERC20) {\n    return _token;\n  }\n\n  function feeCollector() public view override returns (address) {\n    return _feeCollector;\n  }\n\n  function feeConfig() public view override returns (FeeConfig memory) {\n    return _feeConfig;\n  }\n}\ncontract BNum is BConst {\n  function btoi(uint256 a) internal pure returns (uint256) {\n    return a / BONE;\n  }\n\n  function bfloor(uint256 a) internal pure returns (uint256) {\n    return btoi(a) * BONE;\n  }\n\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"ERR_ADD_OVERFLOW\");\n    return c;\n  }\n\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n    (uint256 c, bool flag) = bsubSign(a, b);\n    require(!flag, \"ERR_SUB_UNDERFLOW\");\n    return c;\n  }\n\n  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n    if (a >= b) {\n      return (a - b, false);\n    } else {\n      return (b - a, true);\n    }\n  }\n\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c0 = a * b;\n    require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n    uint256 c1 = c0 + (BONE / 2);\n    require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n    uint256 c2 = c1 / BONE;\n    return c2;\n  }\n\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"ERR_DIV_ZERO\");\n    uint256 c0 = a * BONE;\n    require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n    uint256 c1 = c0 + (b / 2);\n    require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n    uint256 c2 = c1 / b;\n    return c2;\n  }\n\n  // DSMath.wpow\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n    uint256 z = n % 2 != 0 ? a : BONE;\n\n    for (n /= 2; n != 0; n /= 2) {\n      a = bmul(a, a);\n\n      if (n % 2 != 0) {\n        z = bmul(z, a);\n      }\n    }\n    return z;\n  }\n\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\n  // of approximation of b^0.w\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n    require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n    require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n    uint256 whole = bfloor(exp);\n    uint256 remain = bsub(exp, whole);\n\n    uint256 wholePow = bpowi(base, btoi(whole));\n\n    if (remain == 0) {\n      return wholePow;\n    }\n\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n    return bmul(wholePow, partialResult);\n  }\n\n  function bpowApprox(\n    uint256 base,\n    uint256 exp,\n    uint256 precision\n  ) internal pure returns (uint256) {\n    // term 0:\n    uint256 a = exp;\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\n    uint256 term = BONE;\n    uint256 sum = term;\n    bool negative = false;\n\n    // term(k) = numer / denom\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\n    // continue until term is less than precision\n    for (uint256 i = 1; term >= precision; i++) {\n      uint256 bigK = i * BONE;\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n      term = bmul(term, bmul(c, x));\n      term = bdiv(term, bigK);\n      if (term == 0) break;\n\n      if (xneg) negative = !negative;\n      if (cneg) negative = !negative;\n      if (negative) {\n        sum = bsub(sum, term);\n      } else {\n        sum = badd(sum, term);\n      }\n    }\n\n    return sum;\n  }\n}\n",
    "bin": []
}