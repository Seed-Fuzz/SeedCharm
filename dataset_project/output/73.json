{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/73/arbitrum-lpt-bridge",
    "external_functions": [
        [
            "ControlledGateway"
        ],
        [
            "ApproveLike"
        ],
        [
            "L1Escrow",
            "ApproveLike"
        ],
        [
            "IL1LPTGateway"
        ],
        [
            "L1ArbitrumMessenger",
            "IInbox"
        ],
        [
            "TotalSupplyLike"
        ],
        [
            "IL2LPTDataCache"
        ],
        [
            "L1LPTDataCache",
            "IInbox",
            "TotalSupplyLike"
        ],
        [
            "TokenLike"
        ],
        [
            "IMinter"
        ],
        [
            "L1LPTGateway",
            "IInbox",
            "TokenLike",
            "IMinter"
        ],
        [
            "IBondingManager"
        ],
        [
            "ITicketBroker"
        ],
        [
            "IBridgeMinter"
        ],
        [
            "IL2Migrator"
        ],
        [
            "L1Migrator",
            "IInbox",
            "IBridgeMinter",
            "IL1LPTGateway",
            "ApproveLike",
            "IBondingManager",
            "ITicketBroker"
        ],
        [
            "IL2LPTGateway"
        ],
        [
            "L2ArbitrumMessenger",
            "IArbSys"
        ],
        [
            "L2LPTDataCache",
            "IArbSys"
        ],
        [
            "Mintable"
        ],
        [
            "L2LPTGateway",
            "IArbSys",
            "IL2LPTDataCache",
            "Mintable"
        ],
        [
            "IMerkleSnapshot"
        ],
        [
            "IDelegatorPool"
        ],
        [
            "L2Migrator",
            "IArbSys",
            "IDelegatorPool",
            "ITicketBroker",
            "IMerkleSnapshot",
            "IBondingManager"
        ],
        [
            "DelegatorPool",
            "IBondingManager"
        ],
        [
            "ILivepeerToken"
        ],
        [
            "LivepeerToken"
        ],
        [
            "IMigrator"
        ]
    ],
    "new_contract": "contract L1LPTDataCache is L1ArbitrumMessenger {\n    address public immutable tokenAddr;\n    address public immutable l2LPTDataCacheAddr;\n\n    event CacheTotalSupplyInitiated(uint256 seqNo, uint256 totalSupply);\n\n    constructor(\n        address _inbox,\n        address _tokenAddr,\n        address _l2LPTDataCacheAddr\n    ) L1ArbitrumMessenger(_inbox) {\n        tokenAddr = _tokenAddr;\n        l2LPTDataCacheAddr = _l2LPTDataCacheAddr;\n    }\n\n    /**\n     * @notice Executes a L2 call to cache L1 LPT total supply in L2LPTDataCache\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function cacheTotalSupply(\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable {\n        (bytes memory data, uint256 totalSupply) = getCacheTotalSupplyData();\n\n        uint256 seqNo = sendTxToL2(\n            l2LPTDataCacheAddr,\n            msg.sender, // Refund to caller\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            data\n        );\n\n        emit CacheTotalSupplyInitiated(seqNo, totalSupply);\n    }\n\n    /**\n     * @notice Return L2 calldata and total supply to use for a L2 call on L2LPTDataCache\n     * @return data L2 calldata for L2LPTDataCache\n     * @return totalSupply L1 LPT total supply\n     */\n    function getCacheTotalSupplyData()\n        public\n        view\n        returns (bytes memory data, uint256 totalSupply)\n    {\n        totalSupply = TotalSupplyLike(tokenAddr).totalSupply();\n\n        data = abi.encodeWithSelector(\n            IL2LPTDataCache.finalizeCacheTotalSupply.selector,\n            totalSupply\n        );\n    }\n}\ncontract DelegatorPool is Initializable {\n    uint256 public initialStake;\n    uint256 public claimedInitialStake;\n\n    address public bondingManager;\n    address public migrator;\n\n    event Claimed(address indexed _delegator, uint256 _stake, uint256 _fees);\n\n    modifier onlyMigrator() {\n        require(msg.sender == migrator, \"DelegatorPool#claim: NOT_MIGRATOR\");\n        _;\n    }\n\n    /**\n     * @notice Initialize state\n     * @param _bondingManager Address of L2 BondingManager\n     */\n    function initialize(address _bondingManager) public initializer {\n        bondingManager = _bondingManager;\n        migrator = msg.sender;\n        initialStake = pendingStake();\n    }\n\n    /**\n     * @notice Called by L2Migrator to credit stake and fees held by this contract to a delegator\n     * @param _delegator Address of delegator\n     * @param _stake Stake of delegator\n     */\n    function claim(address _delegator, uint256 _stake) external onlyMigrator {\n        require(\n            claimedInitialStake < initialStake,\n            \"DelegatorPool#claim: FULLY_CLAIMED\"\n        );\n\n        // _stake is the delegator's original stake\n        // This contract started off with initalStake\n        // We can calculate how much of the contract's current stake and fees\n        // are owed to the delegator proportional to _stake / (initialStake - claimedInitialStake)\n        // where claimedInitialStake is the stake of the contract that has already been claimed\n\n        // Calculate stake owed to delegator\n        uint256 currTotalStake = pendingStake();\n        uint256 owedStake = (currTotalStake * _stake) /\n            (initialStake - claimedInitialStake);\n\n        // Calculate fees owed to delegator\n        uint256 currTotalFees = pendingFees();\n        uint256 owedFees = (currTotalFees * _stake) /\n            (initialStake - claimedInitialStake);\n\n        // update claimed balance\n        claimedInitialStake += _stake;\n\n        // Transfer owed stake to the delegator\n        transferBond(_delegator, owedStake);\n\n        // Transfer owed fees to the delegator\n        IBondingManager(bondingManager).withdrawFees(\n            payable(_delegator),\n            owedFees\n        );\n\n        emit Claimed(_delegator, owedStake, owedFees);\n    }\n\n    function transferBond(address _delegator, uint256 _stake) internal {\n        IBondingManager(bondingManager).transferBond(\n            _delegator,\n            _stake,\n            address(0),\n            address(0),\n            address(0),\n            address(0)\n        );\n    }\n\n    function pendingStake() internal view returns (uint256) {\n        return IBondingManager(bondingManager).pendingStake(address(this), 0);\n    }\n\n    function pendingFees() internal view returns (uint256) {\n        return IBondingManager(bondingManager).pendingFees(address(this), 0);\n    }\n}\ncontract L2LPTGateway is IL2LPTGateway, ControlledGateway, L2ArbitrumMessenger {\n    address public immutable l2Router;\n    address public immutable l2LPTDataCache;\n\n    address public l1Counterpart;\n\n    constructor(\n        address _l2Router,\n        address _l1Lpt,\n        address _l2Lpt,\n        address _l2LPTDataCache\n    ) ControlledGateway(_l1Lpt, _l2Lpt) {\n        l2Router = _l2Router;\n        l2LPTDataCache = _l2LPTDataCache;\n    }\n\n    /**\n     * @notice Sets address of companion L1LPTGateway\n     * @dev Only address with the governor role is allowed to change the value of l1Counterpart\n     * @param _l1Counterpart L1 Address of the counterpart\n     */\n    function setCounterpart(address _l1Counterpart)\n        external\n        onlyRole(GOVERNOR_ROLE)\n    {\n        l1Counterpart = _l1Counterpart;\n    }\n\n    /**\n     * @notice Burns L2 tokens and sends a message to L1\n     * The tokens will be received on L1 only after the wait period (7 days) is over\n     * @dev no additional callhook data is allowed\n     * @param _l1Token L1 Address of LPT\n     * @param _to Recepient address on L1\n     * @param _amount Amount of tokens to burn\n     * @param _data Contains sender and additional data to send to L1\n     * @return res ID of the withdraw tx\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override whenNotPaused returns (bytes memory res) {\n        require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n        (address from, bytes memory extraData) = parseOutboundData(_data);\n        require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n        Mintable(l2Lpt).burn(from, _amount);\n        IL2LPTDataCache(l2LPTDataCache).decreaseL2SupplyFromL1(_amount);\n\n        uint256 id = sendTxToL1(\n            from,\n            l1Counterpart,\n            getOutboundCalldata(_l1Token, from, _to, _amount, extraData)\n        );\n\n        // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n        emit WithdrawalInitiated(_l1Token, from, _to, id, 0, _amount);\n\n        return abi.encode(id);\n    }\n\n    /**\n     * @notice Receives token amount from L1 and mints the equivalent tokens to the receiving address\n     * @dev can only accept txs coming directly from L1 LPT Gateway\n     * data param is unused because no additional data is allowed from L1\n     * @param _l1Token L1 Address of LPT\n     * @param _from Address of the sender on L1\n     * @param _to Recepient address on L2\n     * @param _amount Amount of tokens transferred\n     */\n    function finalizeInboundTransfer(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata // data -- unused\n    ) external override onlyL1Counterpart(l1Counterpart) {\n        require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n        Mintable(l2Lpt).mint(_to, _amount);\n        IL2LPTDataCache(l2LPTDataCache).increaseL2SupplyFromL1(_amount);\n\n        emit DepositFinalized(_l1Token, _from, _to, _amount);\n    }\n\n    /**\n     * @notice Decodes calldata required for migration of tokens\n     * @dev extraData can be left empty\n     * @param data Encoded callhook data\n     * @return from Sender of the tx\n     * @return extraData Any other data sent to L1\n     */\n    function parseOutboundData(bytes memory data)\n        internal\n        view\n        returns (address from, bytes memory extraData)\n    {\n        if (msg.sender == l2Router) {\n            (from, extraData) = abi.decode(data, (address, bytes));\n        } else {\n            from = msg.sender;\n            extraData = data;\n        }\n    }\n\n    /**\n     * @notice returns address of L1 LPT Gateway\n     */\n    function counterpartGateway() external view override returns (address) {\n        return l1Counterpart;\n    }\n\n    /**\n     * @notice returns address of L2 version of LPT\n     */\n    function calculateL2TokenAddress(address l1Token)\n        external\n        view\n        override\n        returns (address)\n    {\n        if (l1Token != l1Lpt) {\n            return address(0);\n        }\n\n        return l2Lpt;\n    }\n\n    /**\n     * @notice Creates calldata required to send tx to L1\n     * @dev encodes the target function with its params which\n     * will be called on L1 when the message is received on L1\n     */\n    function getOutboundCalldata(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data\n    ) public pure returns (bytes memory outboundCalldata) {\n        outboundCalldata = abi.encodeWithSelector(\n            IL1LPTGateway.finalizeInboundTransfer.selector,\n            token,\n            from,\n            to,\n            amount,\n            abi.encode(0, data) // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n        );\n\n        return outboundCalldata;\n    }\n}\ncontract L2Migrator is L2ArbitrumMessenger, IMigrator, AccessControl {\n    address public immutable bondingManagerAddr;\n    address public immutable ticketBrokerAddr;\n    address public immutable merkleSnapshotAddr;\n\n    address public l1Migrator;\n    address public delegatorPoolImpl;\n    bool public claimStakeEnabled;\n\n    mapping(address => bool) public migratedDelegators;\n    mapping(address => address) public delegatorPools;\n    mapping(address => uint256) public claimedDelegatedStake;\n    mapping(address => mapping(uint256 => bool)) public migratedUnbondingLocks;\n    mapping(address => bool) public migratedSenders;\n\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n    event MigrateDelegatorFinalized(MigrateDelegatorParams params);\n\n    event MigrateUnbondingLocksFinalized(MigrateUnbondingLocksParams params);\n\n    event MigrateSenderFinalized(MigrateSenderParams params);\n\n    event DelegatorPoolCreated(address indexed l1Addr, address delegatorPool);\n\n    event StakeClaimed(\n        address indexed delegator,\n        address delegate,\n        uint256 stake,\n        uint256 fees\n    );\n\n    constructor(\n        address _l1Migrator,\n        address _delegatorPoolImpl,\n        address _bondingManagerAddr,\n        address _ticketBrokerAddr,\n        address _merkleSnapshotAddr\n    ) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setRoleAdmin(GOVERNOR_ROLE, DEFAULT_ADMIN_ROLE);\n\n        l1Migrator = _l1Migrator;\n        delegatorPoolImpl = _delegatorPoolImpl;\n        bondingManagerAddr = _bondingManagerAddr;\n        ticketBrokerAddr = _ticketBrokerAddr;\n        merkleSnapshotAddr = _merkleSnapshotAddr;\n    }\n\n    /**\n     * @notice Sets L1Migrator\n     * @param _l1Migrator L1Migrator address\n     */\n    function setL1Migrator(address _l1Migrator)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        l1Migrator = _l1Migrator;\n    }\n\n    /**\n     * @notice Sets DelegatorPool implementation contract\n     * @param _delegatorPoolImpl DelegatorPool implementation contract\n     */\n    function setDelegatorPoolImpl(address _delegatorPoolImpl)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        delegatorPoolImpl = _delegatorPoolImpl;\n    }\n\n    /**\n     * @notice Enable/disable claimStake()\n     * @param _enabled True/false indicating claimStake() enabled/disabled\n     */\n    function setClaimStakeEnabled(bool _enabled)\n        external\n        onlyRole(GOVERNOR_ROLE)\n    {\n        claimStakeEnabled = _enabled;\n    }\n\n    /**\n     * @notice Called by L1Migrator to complete transcoder/delegator state migration\n     * @param _params L1 state relevant for migration\n     */\n    function finalizeMigrateDelegator(MigrateDelegatorParams memory _params)\n        external\n        onlyL1Counterpart(l1Migrator)\n    {\n        require(\n            !migratedDelegators[_params.l1Addr],\n            \"L2Migrator#finalizeMigrateDelegator: ALREADY_MIGRATED\"\n        );\n\n        migratedDelegators[_params.l1Addr] = true;\n\n        if (_params.l1Addr == _params.delegate) {\n            // l1Addr is an orchestrator on L1:\n            // 1. Stake _params.stake on behalf of _params.l2Addr\n            // 2. Create delegator pool\n            // 3. Stake _params.delegatedStake on behalf of the delegator pool\n            bondFor(_params.stake, _params.l2Addr, _params.delegate);\n\n            address poolAddr = Clones.clone(delegatorPoolImpl);\n\n            delegatorPools[_params.l1Addr] = poolAddr;\n\n            bondFor(\n                _params.delegatedStake - claimedDelegatedStake[_params.l1Addr],\n                poolAddr,\n                _params.delegate\n            );\n\n            IDelegatorPool(poolAddr).initialize(bondingManagerAddr);\n\n            emit DelegatorPoolCreated(_params.l1Addr, poolAddr);\n        } else {\n            // l1Addr is a delegator on L1:\n            // If a delegator pool exists for _params.delegate claim stake which\n            // was already migrated by delegate on behalf of _params.l2Addr.\n            // Otherwise, stake _params.stake on behalf of _params.l2Addr.\n            address pool = delegatorPools[_params.delegate];\n\n            if (pool != address(0)) {\n                // Claim stake that is held by the delegator pool\n                IDelegatorPool(pool).claim(_params.l2Addr, _params.stake);\n            } else {\n                bondFor(_params.stake, _params.l2Addr, _params.delegate);\n            }\n        }\n\n        claimedDelegatedStake[_params.delegate] += _params.stake;\n\n        // Use .call() since l2Addr could be a contract that needs more gas than\n        // the stipend provided by .transfer()\n        // The .call() is safe without a re-entrancy guard because this function cannot be re-entered\n        // by _params.l2Addr since the function can only be called by the L1Migrator via a cross-chain retryable ticket\n        if (_params.fees > 0) {\n            (bool ok, ) = _params.l2Addr.call{value: _params.fees}(\"\");\n            require(ok, \"L2Migrator#finalizeMigrateDelegator: FAIL_FEE\");\n        }\n\n        emit MigrateDelegatorFinalized(_params);\n    }\n\n    /**\n     * @notice Called by L1Migrator to complete unbonding locks migration\n     * @param _params L1 state relevant for migration\n     */\n    function finalizeMigrateUnbondingLocks(\n        MigrateUnbondingLocksParams memory _params\n    ) external onlyL1Counterpart(l1Migrator) {\n        for (uint256 i = 0; i < _params.unbondingLockIds.length; i++) {\n            uint256 id = _params.unbondingLockIds[i];\n            require(\n                !migratedUnbondingLocks[_params.l1Addr][id],\n                \"L2Migrator#finalizeMigrateUnbondingLocks: ALREADY_MIGRATED\"\n            );\n            migratedUnbondingLocks[_params.l1Addr][id] = true;\n        }\n\n        bondFor(_params.total, _params.l2Addr, _params.delegate);\n\n        emit MigrateUnbondingLocksFinalized(_params);\n    }\n\n    /**\n     * @notice Called by L1Migrator to complete sender deposit/reserve migration\n     * @param _params L1 state relevant for migration\n     */\n    function finalizeMigrateSender(MigrateSenderParams memory _params)\n        external\n        onlyL1Counterpart(l1Migrator)\n    {\n        require(\n            !migratedSenders[_params.l1Addr],\n            \"L2Migrator#finalizeMigrateSender: ALREADY_MIGRATED\"\n        );\n\n        migratedSenders[_params.l1Addr] = true;\n\n        ITicketBroker(ticketBrokerAddr).fundDepositAndReserveFor(\n            _params.l2Addr,\n            _params.deposit,\n            _params.reserve\n        );\n\n        emit MigrateSenderFinalized(_params);\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Completes delegator migration using a Merkle proof that a delegator's state was included in a state\n     * snapshot represented by a Merkle tree root\n     * @dev Assume that only EOAs are included in the snapshot\n     * Regardless of the caller of this function, the EOA from L1 will be able to access its stake on L2\n     * @param _delegate Address that is migrating\n     * @param _stake Stake of delegator on L1\n     * @param _fees Fees of delegator on L1\n     * @param _proof Merkle proof of inclusion in Merkle tree state snapshot\n     * @param _newDelegate Optional address of a new delegate on L2\n     */\n    function claimStake(\n        address _delegate,\n        uint256 _stake,\n        uint256 _fees,\n        bytes32[] calldata _proof,\n        address _newDelegate\n    ) external {\n        require(\n            claimStakeEnabled,\n            \"L2Migrator#claimStake: CLAIM_STAKE_DISABLED\"\n        );\n\n        IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);\n\n        address delegator = msg.sender;\n        bytes32 leaf = keccak256(\n            abi.encodePacked(delegator, _delegate, _stake, _fees)\n        );\n\n        require(\n            merkleSnapshot.verify(keccak256(\"LIP-73\"), _proof, leaf),\n            \"L2Migrator#claimStake: INVALID_PROOF\"\n        );\n\n        require(\n            !migratedDelegators[delegator],\n            \"L2Migrator#claimStake: ALREADY_MIGRATED\"\n        );\n\n        migratedDelegators[delegator] = true;\n        claimedDelegatedStake[_delegate] += _stake;\n\n        address pool = delegatorPools[_delegate];\n\n        address delegate = _delegate;\n        if (_newDelegate != address(0)) {\n            delegate = _newDelegate;\n        }\n\n        if (pool != address(0)) {\n            // Claim stake that is held by the delegator pool\n            IDelegatorPool(pool).claim(delegator, _stake);\n        } else {\n            bondFor(_stake, delegator, delegate);\n        }\n\n        // Only EOAs are included in the snapshot so we do not need to worry about\n        // the insufficeint gas stipend with transfer()\n        if (_fees > 0) {\n            payable(delegator).transfer(_fees);\n        }\n\n        emit StakeClaimed(delegator, delegate, _stake, _fees);\n    }\n\n    function bondFor(\n        uint256 _amount,\n        address _owner,\n        address _to\n    ) internal {\n        IBondingManager bondingManager = IBondingManager(bondingManagerAddr);\n\n        bondingManager.bondForWithHint(\n            _amount,\n            _owner,\n            _to,\n            address(0),\n            address(0),\n            address(0),\n            address(0)\n        );\n    }\n}\ncontract L1LPTGateway is IL1LPTGateway, ControlledGateway, L1ArbitrumMessenger {\n    address public immutable l1Router;\n    address public immutable l1LPTEscrow;\n    address public l2Counterpart;\n    address public minter;\n\n    constructor(\n        address _l1Router,\n        address _l1LPTEscrow,\n        address _l1Lpt,\n        address _l2Lpt,\n        address _inbox\n    ) ControlledGateway(_l1Lpt, _l2Lpt) L1ArbitrumMessenger(_inbox) {\n        l1Router = _l1Router;\n        l1LPTEscrow = _l1LPTEscrow;\n    }\n\n    /**\n     * @notice Sets address of companion L2LPTGateway\n     * @dev Only address with the governor role is allowed to change the value of l2Counterpart\n     * @param _l2Counterpart L2 Address of the counterpart\n     */\n    function setCounterpart(address _l2Counterpart)\n        external\n        onlyRole(GOVERNOR_ROLE)\n    {\n        l2Counterpart = _l2Counterpart;\n    }\n\n    /**\n     * @notice Sets address of Minter\n     * @dev Only address with the governor role is allowed to change the value of minter\n     * @param _minter L1 Address of minter\n     */\n    function setMinter(address _minter) external onlyRole(GOVERNOR_ROLE) {\n        minter = _minter;\n    }\n\n    /**\n     * @notice Creates and sends a retryable ticket to migrate LPT to L2 using arbitrum Inbox.\n     * The tokens are sent to the Escrow contract for safekeeping until they are withdrawn\n     * The ticket must be redeemed on L2 to receive tokens at the specified address.\n     * @dev maxGas and gasPriceBid must be set using arbitrum's Inbox.estimateRetryableTicket method.\n     * @param _l1Token L1 Address of LPT\n     * @param _to Recepient address on L2\n     * @param _amount Amount of tokens to tranfer\n     * @param _maxGas Gas limit for L2 execution of the ticket\n     * @param _gasPriceBid Price per gas on L2\n     * @param _data Encoded maxSubmission cost and sender address along with additional calldata\n     * @return seqNum Sequence number of the retryable ticket created by Inbox\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable override whenNotPaused returns (bytes memory) {\n        require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n        // nested scope to avoid stack too deep errors\n        address from;\n        uint256 seqNum;\n        bytes memory extraData;\n        {\n            uint256 maxSubmissionCost;\n            (from, maxSubmissionCost, extraData) = parseOutboundData(_data);\n            require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n            // transfer tokens to escrow\n            TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);\n\n            bytes memory outboundCalldata = getOutboundCalldata(\n                _l1Token,\n                from,\n                _to,\n                _amount,\n                extraData\n            );\n\n            seqNum = sendTxToL2(\n                l2Counterpart,\n                from,\n                maxSubmissionCost,\n                _maxGas,\n                _gasPriceBid,\n                outboundCalldata\n            );\n        }\n\n        emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);\n\n        return abi.encode(seqNum);\n    }\n\n    /**\n     * @notice Receives withdrawn token amount from L2\n     * The equivalent tokens are released from the Escrow contract and sent to the destination\n     * In case the escrow doesn't have enough balance, new tokens are minted\n     * @dev can only accept txs coming directly from L2 LPT Gateway\n     * @param l1Token L1 Address of LPT\n     * @param from Address of the sender\n     * @param to Recepient address on L1\n     * @param amount Amount of tokens transferred\n     * @param data Contains exitNum which is always set to 0\n     */\n    function finalizeInboundTransfer(\n        address l1Token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external override onlyL2Counterpart(l2Counterpart) {\n        require(l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n        (uint256 exitNum, ) = abi.decode(data, (uint256, bytes));\n\n        uint256 escrowBalance = TokenLike(l1Token).balanceOf(l1LPTEscrow);\n\n        // mint additional tokens if requested amount exceeds escrowed amount\n        if (amount <= escrowBalance) {\n            TokenLike(l1Token).transferFrom(l1LPTEscrow, to, amount);\n        } else {\n            if (escrowBalance > 0) {\n                TokenLike(l1Token).transferFrom(l1LPTEscrow, to, escrowBalance);\n            }\n            IMinter(minter).bridgeMint(to, amount - escrowBalance);\n        }\n\n        emit WithdrawalFinalized(l1Token, from, to, exitNum, amount);\n    }\n\n    /**\n     * @notice decodes calldata required for migration of tokens\n     * @dev data must include maxSubmissionCost, extraData can be left empty\n     * @param data encoded callhook data\n     * @return from sender of the tx\n     * @return maxSubmissionCost base ether value required to keep retyrable ticket alive\n     * @return extraData any other data sent to L2\n     */\n    function parseOutboundData(bytes memory data)\n        internal\n        view\n        returns (\n            address from,\n            uint256 maxSubmissionCost,\n            bytes memory extraData\n        )\n    {\n        if (msg.sender == l1Router) {\n            // router encoded\n            (from, extraData) = abi.decode(data, (address, bytes));\n        } else {\n            from = msg.sender;\n            extraData = data;\n        }\n        // user encoded\n        (maxSubmissionCost, extraData) = abi.decode(\n            extraData,\n            (uint256, bytes)\n        );\n    }\n\n    /**\n     * @notice returns address of L2 LPT Gateway\n     */\n    function counterpartGateway() external view override returns (address) {\n        return l2Counterpart;\n    }\n\n    /**\n     * @notice returns address of L2 version of LPT\n     */\n    function calculateL2TokenAddress(address l1Token)\n        external\n        view\n        override\n        returns (address)\n    {\n        if (l1Token != l1Lpt) {\n            return address(0);\n        }\n\n        return l2Lpt;\n    }\n\n    /**\n     * @notice Creates calldata required to create a retryable ticket\n     * @dev encodes the target function with its params which\n     * will be called on L2 when the retryable ticket is redeemed\n     */\n    function getOutboundCalldata(\n        address l1Token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data\n    ) public pure returns (bytes memory outboundCalldata) {\n        bytes memory emptyBytes = \"\";\n\n        outboundCalldata = abi.encodeWithSelector(\n            IL2LPTGateway.finalizeInboundTransfer.selector,\n            l1Token,\n            from,\n            to,\n            amount,\n            abi.encode(emptyBytes, data)\n        );\n\n        return outboundCalldata;\n    }\n}\ncontract ControlledGateway is AccessControl, Pausable {\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n    address public immutable l1Lpt;\n    address public immutable l2Lpt;\n\n    constructor(address _l1Lpt, address _l2Lpt) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setRoleAdmin(GOVERNOR_ROLE, DEFAULT_ADMIN_ROLE);\n\n        l1Lpt = _l1Lpt;\n        l2Lpt = _l2Lpt;\n    }\n\n    function pause() external onlyRole(GOVERNOR_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(GOVERNOR_ROLE) {\n        _unpause();\n    }\n}\nabstract contract L1ArbitrumMessenger {\n    IInbox public immutable inbox;\n\n    event TxToL2(\n        address indexed from,\n        address indexed to,\n        uint256 indexed seqNum,\n        bytes data\n    );\n\n    constructor(address _inbox) {\n        inbox = IInbox(_inbox);\n    }\n\n    modifier onlyL2Counterpart(address l2Counterpart) {\n        // a message coming from the counterpart gateway was executed by the bridge\n        address bridge = inbox.bridge();\n        require(msg.sender == bridge, \"NOT_FROM_BRIDGE\");\n\n        // and the outbox reports that the L2 address of the sender is the counterpart gateway\n        address l2ToL1Sender = IOutbox(IBridge(bridge).activeOutbox())\n            .l2ToL1Sender();\n        require(l2ToL1Sender == l2Counterpart, \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    function sendTxToL2(\n        address target,\n        address from,\n        uint256 maxSubmissionCost,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes memory data\n    ) internal returns (uint256) {\n        return\n            sendTxToL2(\n                target,\n                from,\n                msg.value,\n                0, // we always assume that l2CallValue = 0\n                maxSubmissionCost,\n                maxGas,\n                gasPriceBid,\n                data\n            );\n    }\n\n    function sendTxToL2(\n        address target,\n        address from,\n        uint256 _l1CallValue,\n        uint256 _l2CallValue,\n        uint256 maxSubmissionCost,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes memory data\n    ) internal returns (uint256) {\n        uint256 seqNum = inbox.createRetryableTicket{value: _l1CallValue}(\n            target,\n            _l2CallValue,\n            maxSubmissionCost,\n            from,\n            from,\n            maxGas,\n            gasPriceBid,\n            data\n        );\n        emit TxToL2(from, target, seqNum, data);\n        return seqNum;\n    }\n}\ncontract L1Escrow is AccessControl {\n    event Approve(\n        address indexed _token,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    function approve(\n        address _token,\n        address _spender,\n        uint256 _value\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        ApproveLike(_token).approve(_spender, _value);\n        emit Approve(_token, _spender, _value);\n    }\n}\ncontract L2LPTDataCache is Ownable, L2ArbitrumMessenger {\n    address public l1LPTDataCache;\n    address public l2LPTGateway;\n\n    // Total supply of LPT on L1\n    // Updates are initiated by a call from the L1LPTDataCache on L1\n    uint256 public l1TotalSupply;\n    // Amount of L2 LPT transferred from L1 via the LPT bridge\n    uint256 public l2SupplyFromL1;\n\n    event CacheTotalSupplyFinalized(uint256 totalSupply);\n\n    modifier onlyL2LPTGateway() {\n        require(msg.sender == l2LPTGateway, \"NOT_L2_LPT_GATEWAY\");\n        _;\n    }\n\n    /**\n     * @notice Sets the L1LPTDataCache\n     * @param _l1LPTDataCache L1 address of L1LPTDataCache\n     */\n    function setL1LPTDataCache(address _l1LPTDataCache) external onlyOwner {\n        l1LPTDataCache = _l1LPTDataCache;\n    }\n\n    /**\n     * @notice Sets the L2LPTGateway\n     * @param _l2LPTGateway L2 address of L2LPTGateway\n     */\n    function setL2LPTGateway(address _l2LPTGateway) external onlyOwner {\n        l2LPTGateway = _l2LPTGateway;\n    }\n\n    /**\n     * @notice Called by L2LPTGateway to increase l2SupplyFromL1\n     * @dev Should be called when L2LPTGateway mints LPT to ensure that L2 total supply and l2SupplyFromL1 increase by the same amount\n     * @param _amount Amount to increase l2SupplyFromL1\n     */\n    function increaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway {\n        l2SupplyFromL1 += _amount;\n\n        // No event because the L2LPTGateway events are sufficient\n    }\n\n    /**\n     * @notice Called by L2LPTGateway to decrease l2SupplyFromL1\n     * @dev Should be called when L2LPTGateway burns LPT ensure L2 total supply and l2SupplyFromL1 decrease by the same amount\n     * @param _amount Amount to decrease l2SupplyFromL1\n     */\n    function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway {\n        // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1.\n        // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2\n        // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was\n        // never from L1 in the first place.\n        if (_amount > l2SupplyFromL1) {\n            l2SupplyFromL1 = 0;\n        } else {\n            l2SupplyFromL1 -= _amount;\n        }\n\n        // No event because the L2LPTGateway events are sufficient\n    }\n\n    /**\n     * @notice Called by L1LPTDataCache from L1 to cache L1 LPT total supply\n     * @param _totalSupply L1 LPT total supply\n     */\n    function finalizeCacheTotalSupply(uint256 _totalSupply)\n        external\n        onlyL1Counterpart(l1LPTDataCache)\n    {\n        l1TotalSupply = _totalSupply;\n\n        emit CacheTotalSupplyFinalized(_totalSupply);\n    }\n\n    /**\n     * @notice Calculate and return L1 LPT circulating supply\n     * @return L1 LPT circulating supply\n     */\n    function l1CirculatingSupply() public view returns (uint256) {\n        // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1\n        // The below check is defensive to avoid reverting if this invariant for some reason violated\n        return\n            l1TotalSupply >= l2SupplyFromL1\n                ? l1TotalSupply - l2SupplyFromL1\n                : 0;\n    }\n}\ncontract LivepeerToken is ILivepeerToken, AccessControl, ERC20Permit {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    constructor() ERC20(\"Livepeer Token\", \"LPT\") ERC20Permit(\"Livepeer Token\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE);\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount)\n        external\n        override\n        onlyRole(MINTER_ROLE)\n    {\n        _mint(_to, _amount);\n        emit Mint(_to, _amount);\n    }\n\n    /**\n     * @dev Burns a specific amount of the sender's tokens\n     * @param _amount The amount of tokens to be burned\n     */\n    function burn(address _from, uint256 _amount)\n        external\n        override\n        onlyRole(BURNER_ROLE)\n    {\n        _burn(_from, _amount);\n        emit Burn(_from, _amount);\n    }\n}\ncontract L1Migrator is\n    L1ArbitrumMessenger,\n    IMigrator,\n    EIP712,\n    AccessControl,\n    Pausable\n{\n    address public immutable bondingManagerAddr;\n    address public immutable ticketBrokerAddr;\n    address public immutable bridgeMinterAddr;\n    address public immutable tokenAddr;\n    address public immutable l1LPTGatewayAddr;\n    address public immutable l2MigratorAddr;\n\n    event MigrateDelegatorInitiated(\n        uint256 indexed seqNo,\n        MigrateDelegatorParams params\n    );\n\n    event MigrateUnbondingLocksInitiated(\n        uint256 indexed seqNo,\n        MigrateUnbondingLocksParams params\n    );\n\n    event MigrateSenderInitiated(\n        uint256 indexed seqNo,\n        MigrateSenderParams params\n    );\n\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n    bytes32 private constant MIGRATE_DELEGATOR_TYPE_HASH =\n        keccak256(\"MigrateDelegator(address l1Addr,address l2Addr)\");\n\n    bytes32 private constant MIGRATE_UNBONDING_LOCKS_TYPE_HASH =\n        keccak256(\n            \"MigrateUnbondingLocks(address l1Addr,address l2Addr,uint256[] unbondingLockIds)\"\n        );\n\n    bytes32 private constant MIGRATE_SENDER_TYPE_HASH =\n        keccak256(\"MigrateSender(address l1Addr,address l2Addr)\");\n\n    constructor(\n        address _inbox,\n        address _bondingManagerAddr,\n        address _ticketBrokerAddr,\n        address _bridgeMinterAddr,\n        address _tokenAddr,\n        address _l1LPTGatewayAddr,\n        address _l2MigratorAddr\n    ) L1ArbitrumMessenger(_inbox) EIP712(\"Livepeer L1Migrator\", \"1\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setRoleAdmin(GOVERNOR_ROLE, DEFAULT_ADMIN_ROLE);\n\n        bondingManagerAddr = _bondingManagerAddr;\n        ticketBrokerAddr = _ticketBrokerAddr;\n        bridgeMinterAddr = _bridgeMinterAddr;\n        tokenAddr = _tokenAddr;\n        l1LPTGatewayAddr = _l1LPTGatewayAddr;\n        l2MigratorAddr = _l2MigratorAddr;\n\n        _pause();\n    }\n\n    /**\n     * @notice Executes a L2 call to L2Migrator to migrate transcoder/delegator state from the L1 BondingManager.\n     * @dev The term \"delegator\" here can refer to both a transcoder (self-delegated delegator) and delegator.\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _sig Optional EIP-712 signature over a payload that includes _l1Addr and _l2Addr\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateDelegator(\n        address _l1Addr,\n        address _l2Addr,\n        bytes memory _sig,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        // Authorization\n        // Either msg.sender == _l1Addr OR signer for _sig == _l1Addr\n        requireValidMigration(\n            _l1Addr,\n            _l2Addr,\n            keccak256(\n                abi.encode(MIGRATE_DELEGATOR_TYPE_HASH, _l1Addr, _l2Addr)\n            ),\n            _sig\n        );\n\n        (\n            bytes memory data,\n            MigrateDelegatorParams memory params\n        ) = getMigrateDelegatorParams(_l1Addr, _l2Addr);\n\n        // We do not prevent migration replays here to minimize L1 gas costs\n        // The L2Migrator is responsible for rejecting migration replays\n\n        uint256 seqNo = sendTxToL2(\n            l2MigratorAddr,\n            _l2Addr, // Refunds to the L2 address\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            data\n        );\n\n        emit MigrateDelegatorInitiated(seqNo, params);\n    }\n\n    /**\n     * @notice Executes a L2 call to L2Migrator to migrate unbonding locks state from the L1 BondingManager.\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _unbondingLockIds IDs of unbonding locks in the L1 BondingManager to migrate\n     * @param _sig Optional EIP-712 signature over a payload that includes _l1Addr, _l2Addr and _unbondingLockIds\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateUnbondingLocks(\n        address _l1Addr,\n        address _l2Addr,\n        uint256[] calldata _unbondingLockIds,\n        bytes memory _sig,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        // Authorization\n        // Either msg.sender == _l1Addr OR signer for _sig == _l1Addr\n        requireValidMigration(\n            _l1Addr,\n            _l2Addr,\n            keccak256(\n                abi.encode(\n                    MIGRATE_UNBONDING_LOCKS_TYPE_HASH,\n                    _l1Addr,\n                    _l2Addr,\n                    keccak256(abi.encodePacked(_unbondingLockIds))\n                )\n            ),\n            _sig\n        );\n\n        (\n            bytes memory data,\n            MigrateUnbondingLocksParams memory params\n        ) = getMigrateUnbondingLocksParams(_l1Addr, _l2Addr, _unbondingLockIds);\n\n        // We do not prevent migration replays here to minimize L1 gas costs\n        // The L2Migrator is responsible for rejecting migration replays\n\n        uint256 seqNo = sendTxToL2(\n            l2MigratorAddr,\n            _l2Addr, // Refund to the L2 address\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            data\n        );\n\n        emit MigrateUnbondingLocksInitiated(seqNo, params);\n    }\n\n    /**\n     * @notice Executes a L2 call to L2Migrator to migrate sender deposit/reserve state from the L1 TicketBroker.\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _sig Optional EIP-712 signature over a payload that includes _l1Addr and _l2Addr\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateSender(\n        address _l1Addr,\n        address _l2Addr,\n        bytes memory _sig,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        // Authorization\n        // Either msg.sender == _l1Addr OR signer for _sig == _l1Addr\n        requireValidMigration(\n            _l1Addr,\n            _l2Addr,\n            keccak256(abi.encode(MIGRATE_SENDER_TYPE_HASH, _l1Addr, _l2Addr)),\n            _sig\n        );\n\n        (\n            bytes memory data,\n            MigrateSenderParams memory params\n        ) = getMigrateSenderParams(_l1Addr, _l2Addr);\n\n        // We do not prevent migration replays here to minimize L1 gas costs\n        // The L2Migrator is responsible for rejecting migration replays\n\n        uint256 seqNo = sendTxToL2(\n            l2MigratorAddr,\n            _l2Addr, // Refund to the L2 address\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            data\n        );\n\n        emit MigrateSenderInitiated(seqNo, params);\n    }\n\n    /**\n     * @notice Executes a L2 call to send ETH from the L1BridgeMinter to the L2Migrator.\n     * @dev Anyone can call this function.\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateETH(\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        uint256 amount = IBridgeMinter(bridgeMinterAddr)\n            .withdrawETHToL1Migrator();\n\n        // Any ETH refunded to the L2 alias of this contract can be used for\n        // other cross-chain txs sent by this contract.\n        // The retryable ticket created will not be cancellable since this contract\n        // currently does not support cross-chain txs to call ArbRetryableTx.cancel().\n        // Regarding the comment below on this contract receiving refunds:\n        // msg.sender also cannot be the address to receive refunds as beneficiary because otherwise\n        // msg.sender could cancel the ticket before it is executed on L2 to receive the L2 call value.\n        sendTxToL2(\n            l2MigratorAddr,\n            address(this), // L2 alias of this contract will receive refunds\n            msg.value,\n            amount,\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Executes a L2 call to send LPT from the L1BridgeMinter to the L2Migrator.\n     * @dev Anyone can call this function.\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateLPT(\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        uint256 amount = IBridgeMinter(bridgeMinterAddr)\n            .withdrawLPTToL1Migrator();\n\n        // Approve L1LPTGateway to pull tokens\n        ApproveLike(tokenAddr).approve(l1LPTGatewayAddr, amount);\n        // Trigger cross-chain transfer with L1LPTGateway which will pull and escrow tokens\n        // Forward msg.value to outboundTransfer() to be used for cross-chain tx\n        IL1LPTGateway(l1LPTGatewayAddr).outboundTransfer{value: msg.value}(\n            tokenAddr,\n            l2MigratorAddr,\n            amount,\n            _maxGas,\n            _gasPriceBid,\n            abi.encode(_maxSubmissionCost, \"\")\n        );\n    }\n\n    /**\n     * @notice Pause the contract\n     * @dev Only callable by addresses with governor role\n     */\n    function pause() external onlyRole(GOVERNOR_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the contract\n     * @dev Only callable by addresses with governor role\n     */\n    function unpause() external onlyRole(GOVERNOR_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Return L2 calldata and MigrateDelegatorParams to use for a L2 call on L2Migrator\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @return data L2 calldata for finalizeMigrateDelegator() in L2Migrator\n     * @return params MigrateDelegatorParams to use for finalizeMigrateDelegator() in L2Migrator\n     */\n    function getMigrateDelegatorParams(address _l1Addr, address _l2Addr)\n        public\n        view\n        returns (bytes memory data, MigrateDelegatorParams memory params)\n    {\n        IBondingManager bondingManager = IBondingManager(bondingManagerAddr);\n\n        // pendingStake() ignores the _endRound arg\n        uint256 stake = bondingManager.pendingStake(_l1Addr, 0);\n        // pendingFees() ignores the _endRound arg\n        uint256 fees = bondingManager.pendingFees(_l1Addr, 0);\n        (\n            ,\n            ,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            ,\n            ,\n\n        ) = bondingManager.getDelegator(_l1Addr);\n\n        // Construct params and L2 calldata for finalizeMigrateDelegator() on L2Migrator\n        params = MigrateDelegatorParams({\n            l1Addr: _l1Addr,\n            l2Addr: _l2Addr,\n            stake: stake,\n            delegatedStake: delegatedAmount,\n            fees: fees,\n            delegate: delegateAddress\n        });\n\n        data = abi.encodeWithSelector(\n            IL2Migrator.finalizeMigrateDelegator.selector,\n            params\n        );\n    }\n\n    /**\n     * @notice Return L2 calldata and MigrateSenderParams to use for a L2 call on L2Migrator\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @return data L2 calldata for finalizeMigrateSender() in L2Migrator\n     * @return params MigrateSenderParams to use for finalizeMigrateSender() in L2Migrator\n     */\n    function getMigrateSenderParams(address _l1Addr, address _l2Addr)\n        public\n        view\n        returns (bytes memory data, MigrateSenderParams memory params)\n    {\n        ITicketBroker ticketBroker = ITicketBroker(ticketBrokerAddr);\n\n        (\n            ITicketBroker.Sender memory sender,\n            ITicketBroker.ReserveInfo memory reserveInfo\n        ) = ticketBroker.getSenderInfo(_l1Addr);\n\n        // Construct params and L2 calldata for finalizeMigrateSender() on L2Migrator\n        params = MigrateSenderParams({\n            l1Addr: _l1Addr,\n            l2Addr: _l2Addr,\n            deposit: sender.deposit,\n            reserve: reserveInfo.fundsRemaining\n        });\n\n        data = abi.encodeWithSelector(\n            IL2Migrator.finalizeMigrateSender.selector,\n            params\n        );\n    }\n\n    /**\n     * @notice Return L2 calldata and MigrateUnbondingLocksParams to use for a L2 call on L2Migrator\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _unbondingLockIds IDs of unbonding locks in L1 BondingManager to migrate\n     * @return data L2 calldata for finalizeMigrateUnbondingLocks() in L2Migrator\n     * @return params MigrateUnbondingLocksParams to use for finalizeMigrateUnbondingLocks() in L2Migrator\n     */\n    function getMigrateUnbondingLocksParams(\n        address _l1Addr,\n        address _l2Addr,\n        uint256[] memory _unbondingLockIds\n    )\n        public\n        view\n        returns (bytes memory data, MigrateUnbondingLocksParams memory params)\n    {\n        IBondingManager bondingManager = IBondingManager(bondingManagerAddr);\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < _unbondingLockIds.length; i++) {\n            (uint256 amount, ) = bondingManager.getDelegatorUnbondingLock(\n                _l1Addr,\n                _unbondingLockIds[i]\n            );\n\n            total += amount;\n        }\n\n        (, , address delegateAddress, , , , ) = bondingManager.getDelegator(\n            _l1Addr\n        );\n\n        // Construct params and L2 calldata for finalizeMigrateUnbondingLocks() on L2Migrator\n        params = MigrateUnbondingLocksParams({\n            l1Addr: _l1Addr,\n            l2Addr: _l2Addr,\n            total: total,\n            unbondingLockIds: _unbondingLockIds,\n            delegate: delegateAddress\n        });\n\n        data = abi.encodeWithSelector(\n            IL2Migrator.finalizeMigrateUnbondingLocks.selector,\n            params\n        );\n    }\n\n    function requireValidMigration(\n        address _l1Addr,\n        address _l2Addr,\n        bytes32 _structHash,\n        bytes memory _sig\n    ) internal view {\n        require(\n            _l2Addr != address(0),\n            \"L1Migrator#requireValidMigration: INVALID_L2_ADDR\"\n        );\n        require(\n            msg.sender == _l1Addr ||\n                recoverSigner(_structHash, _sig) == _l1Addr,\n            \"L1Migrator#requireValidMigration: FAIL_AUTH\"\n        );\n    }\n\n    function recoverSigner(bytes32 _structHash, bytes memory _sig)\n        internal\n        view\n        returns (address)\n    {\n        if (_sig.length == 0) {\n            return address(0);\n        }\n\n        bytes32 hash = _hashTypedDataV4(_structHash);\n        return ECDSA.recover(hash, _sig);\n    }\n}\nabstract contract L2ArbitrumMessenger {\n    event TxToL1(\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _id,\n        bytes _data\n    );\n\n    function sendTxToL1(\n        address user,\n        address to,\n        bytes memory data\n    ) internal returns (uint256) {\n        // note: this method doesn't support sending ether to L1 together with a call\n        uint256 id = IArbSys(address(100)).sendTxToL1(to, data);\n        emit TxToL1(user, to, id, data);\n        return id;\n    }\n\n    modifier onlyL1Counterpart(address l1Counterpart) {\n        require(\n            msg.sender == applyL1ToL2Alias(l1Counterpart),\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n\n    uint160 internal constant OFFSET =\n        uint160(0x1111000000000000000000000000000000001111);\n\n    // l1 addresses are transformed durng l1->l2 calls\n    function applyL1ToL2Alias(address l1Address)\n        internal\n        pure\n        returns (address l2Address)\n    {\n        l2Address = address(uint160(l1Address) + OFFSET);\n    }\n}\n",
    "bin": []
}