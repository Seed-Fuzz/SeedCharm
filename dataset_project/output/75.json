{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/75/xdefi-distribution",
    "external_functions": [
        [
            "XDEFIDistribution",
            "IERC721Receiver",
            "IEIP2612",
            "IERC20"
        ],
        [
            "XDEFIDistributionHelper",
            "IXDEFIDistribution"
        ]
    ],
    "new_contract": "contract XDEFIDistributionHelper is IXDEFIDistributionHelper {\n\n    function getAllTokensForAccount(address xdefiDistribution_, address account_) public view returns (uint256[] memory tokenIds_) {\n        uint256 count = IXDEFIDistribution(xdefiDistribution_).balanceOf(account_);\n        tokenIds_ = new uint256[](count);\n\n        for (uint256 i; i < count; ++i) {\n            tokenIds_[i] = IXDEFIDistribution(xdefiDistribution_).tokenOfOwnerByIndex(account_, i);\n        }\n    }\n\n    function getAllLockedPositionsForAccount(address xdefiDistribution_, address account_) public view returns (uint256[] memory tokenIds_, IXDEFIDistribution.Position[] memory positions_, uint256[] memory withdrawables_) {\n        uint256[] memory tokenIds = getAllTokensForAccount(xdefiDistribution_, account_);\n\n        uint256 allTokenCount = tokenIds.length;\n\n        IXDEFIDistribution.Position[] memory positions = new IXDEFIDistribution.Position[](allTokenCount);\n\n        uint256 validPositionCount;\n\n        for (uint256 i; i < allTokenCount; ++i) {\n            (uint96 units, uint88 depositedXDEFI, uint32 expiry, uint32 created, uint8 bonusMultiplier, int256 pointsCorrection) = IXDEFIDistribution(xdefiDistribution_).positionOf(tokenIds[i]);\n\n            if (expiry == uint32(0)) continue;\n\n            tokenIds[validPositionCount] = tokenIds[i];\n            positions[validPositionCount++] = IXDEFIDistribution.Position(units, depositedXDEFI, expiry, created, bonusMultiplier, pointsCorrection);\n        }\n\n        tokenIds_ = new uint256[](validPositionCount);\n        positions_ = new IXDEFIDistribution.Position[](validPositionCount);\n        withdrawables_ = new uint256[](validPositionCount);\n\n        for (uint256 i; i < validPositionCount; ++i) {\n            positions_[i] = positions[i];\n            withdrawables_[i] = IXDEFIDistribution(xdefiDistribution_).withdrawableOf(tokenIds_[i] = tokenIds[i]);\n        }\n    }\n\n}\ncontract XDEFIDistribution is IXDEFIDistribution, ERC721Enumerable {\n\n    uint88 internal MAX_TOTAL_XDEFI_SUPPLY = uint88(240_000_000_000_000_000_000_000_000);\n\n    // See https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n    uint256 internal constant _pointsMultiplier = uint256(2**128);\n    uint256 internal _pointsPerUnit;\n\n    address public immutable XDEFI;\n\n    uint256 public distributableXDEFI;\n    uint256 public totalDepositedXDEFI;\n    uint256 public totalUnits;\n\n    mapping(uint256 => Position) public positionOf;\n\n    mapping(uint256 => uint8) public bonusMultiplierOf;  // Scaled by 100 (i.e. 1.1x is 110, 2.55x is 255).\n\n    uint256 internal immutable _zeroDurationPointBase;\n\n    string public baseURI;\n\n    address public owner;\n    address public pendingOwner;\n\n    uint256 internal _locked;\n\n    constructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(\"Locked XDEFI\", \"lXDEFI\") {\n        require((XDEFI = XDEFI_) != address(0), \"INVALID_TOKEN\");\n        owner = msg.sender;\n        baseURI = baseURI_;\n        _zeroDurationPointBase = zeroDurationPointBase_;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"NOT_OWNER\");\n        _;\n    }\n\n    modifier noReenter() {\n        require(_locked == 0, \"LOCKED\");\n        _locked = uint256(1);\n        _;\n        _locked = uint256(0);\n    }\n\n    /*******************/\n    /* Admin Functions */\n    /*******************/\n\n    function acceptOwnership() external {\n        require(pendingOwner == msg.sender, \"NOT_PENDING_OWNER\");\n        emit OwnershipAccepted(owner, msg.sender);\n        owner = msg.sender;\n        pendingOwner = address(0);\n    }\n\n    function proposeOwnership(address newOwner_) external onlyOwner {\n        emit OwnershipProposed(owner, pendingOwner = newOwner_);\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyOwner {\n        baseURI = baseURI_;\n    }\n\n    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {\n        uint256 count = durations_.length;\n\n        for (uint256 i; i < count; ++i) {\n            uint256 duration = durations_[i];\n            require(duration <= uint256(18250 days), \"INVALID_DURATION\");\n            emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);\n        }\n    }\n\n    /**********************/\n    /* Position Functions */\n    /**********************/\n\n    function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {\n        // Lock the XDEFI in the contract.\n        SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);\n\n        // Handle the lock position creation and get the tokenId of the locked position.\n        return _lock(amount_, duration_, destination_);\n    }\n\n    function lockWithPermit(uint256 amount_, uint256 duration_, address destination_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external noReenter returns (uint256 tokenId_) {\n        // Approve this contract for the amount, using the provided signature.\n        IEIP2612(XDEFI).permit(msg.sender, address(this), amount_, deadline_, v_, r_, s_);\n\n        // Lock the XDEFI in the contract.\n        SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);\n\n        // Handle the lock position creation and get the tokenId of the locked position.\n        return _lock(amount_, duration_, destination_);\n    }\n\n    function relock(uint256 tokenId_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256 newTokenId_) {\n        // Handle the unlock and get the amount of XDEFI eligible to withdraw.\n        amountUnlocked_ = _unlock(msg.sender, tokenId_);\n\n        // Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway.\n        require(lockAmount_ <= amountUnlocked_, \"INSUFFICIENT_AMOUNT_UNLOCKED\");\n\n        // Handle the lock position creation and get the tokenId of the locked position.\n        newTokenId_ = _lock(lockAmount_, duration_, destination_);\n\n        uint256 withdrawAmount = amountUnlocked_ - lockAmount_;\n\n        if (withdrawAmount != uint256(0)) {\n            // Send the excess XDEFI to the destination, if needed.\n            SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount);\n        }\n\n        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.\n        _updateXDEFIBalance();\n    }\n\n    function unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {\n        // Handle the unlock and get the amount of XDEFI eligible to withdraw.\n        amountUnlocked_ = _unlock(msg.sender, tokenId_);\n\n        // Send the the unlocked XDEFI to the destination.\n        SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);\n\n        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.\n        _updateXDEFIBalance();\n    }\n\n    function updateDistribution() external {\n        uint256 totalUnitsCached = totalUnits;\n\n        require(totalUnitsCached > uint256(0), \"NO_UNIT_SUPPLY\");\n\n        uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());\n\n        if (newXDEFI == uint256(0)) return;\n\n        _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n\n        emit DistributionUpdated(msg.sender, newXDEFI);\n    }\n\n    function withdrawableOf(uint256 tokenId_) public view returns (uint256 withdrawableXDEFI_) {\n        Position storage position = positionOf[tokenId_];\n        return _withdrawableGiven(position.units, position.depositedXDEFI, position.pointsCorrection);\n    }\n\n    /****************************/\n    /* Batch Position Functions */\n    /****************************/\n\n    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256 newTokenId_) {\n        // Handle the unlocks and get the amount of XDEFI eligible to withdraw.\n        amountUnlocked_ = _unlockBatch(msg.sender, tokenIds_);\n\n        // Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway.\n        require(lockAmount_ <= amountUnlocked_, \"INSUFFICIENT_AMOUNT_UNLOCKED\");\n\n        // Handle the lock position creation and get the tokenId of the locked position.\n        newTokenId_ = _lock(lockAmount_, duration_, destination_);\n\n        uint256 withdrawAmount = amountUnlocked_ - lockAmount_;\n\n        if (withdrawAmount != uint256(0)) {\n            // Send the excess XDEFI to the destination, if needed.\n            SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount);\n        }\n\n        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlockBatch`) and transferring out.\n        _updateXDEFIBalance();\n    }\n\n    function unlockBatch(uint256[] memory tokenIds_, address destination_) external noReenter returns (uint256 amountUnlocked_) {\n        // Handle the unlocks and get the amount of XDEFI eligible to withdraw.\n        amountUnlocked_ = _unlockBatch(msg.sender, tokenIds_);\n\n        // Send the the unlocked XDEFI to the destination.\n        SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);\n\n        // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlockBatch`) and transferring out.\n        _updateXDEFIBalance();\n    }\n\n    /*****************/\n    /* NFT Functions */\n    /*****************/\n\n    function getPoints(uint256 amount_, uint256 duration_) external view returns (uint256 points_) {\n        return _getPoints(amount_, duration_);\n    }\n\n    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {\n        uint256 count = tokenIds_.length;\n        require(count > uint256(1), \"MIN_2_TO_MERGE\");\n\n        uint256 points;\n\n        // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.\n        for (uint256 i; i < count; ++i) {\n            uint256 tokenId = tokenIds_[i];\n            require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\");\n            require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");\n\n            _burn(tokenId);\n\n            points += _getPointsFromTokenId(tokenId);\n        }\n\n        // Mine a new NFT to the destinations, based on the accumulated points.\n        _safeMint(destination_, tokenId_ = _generateNewTokenId(points));\n    }\n\n    function pointsOf(uint256 tokenId_) external view returns (uint256 points_) {\n        require(_exists(tokenId_), \"NO_TOKEN\");\n        return _getPointsFromTokenId(tokenId_);\n    }\n\n    function tokenURI(uint256 tokenId_) public view override(IXDEFIDistribution, ERC721) returns (string memory tokenURI_) {\n        require(_exists(tokenId_), \"NO_TOKEN\");\n        return string(abi.encodePacked(baseURI, Strings.toString(tokenId_)));\n    }\n\n    /**********************/\n    /* Internal Functions */\n    /**********************/\n\n    function _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {\n        // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.\n        return (points_ << uint256(128)) + uint128(totalSupply() + 1);\n    }\n\n    function _getPoints(uint256 amount_, uint256 duration_) internal view returns (uint256 points_) {\n        return amount_ * (duration_ + _zeroDurationPointBase);\n    }\n\n    function _getPointsFromTokenId(uint256 tokenId_) internal pure returns (uint256 points_) {\n        return tokenId_ >> uint256(128);\n    }\n\n    function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n        // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n        require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n        // Get bonus multiplier and check that it is not zero (which validates the duration).\n        uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n        require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n        // Mint a locked staked position NFT to the destination.\n        _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n        // Track deposits.\n        totalDepositedXDEFI += amount_;\n\n        // Create Position.\n        uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));\n        totalUnits += units;\n        positionOf[tokenId_] =\n            Position({\n                units: units,\n                depositedXDEFI: uint88(amount_),\n                expiry: uint32(block.timestamp + duration_),\n                created: uint32(block.timestamp),\n                bonusMultiplier: bonusMultiplier,\n                pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)\n            });\n\n        emit LockPositionCreated(tokenId_, destination_, amount_, duration_);\n    }\n\n    function _toInt256Safe(uint256 x_) internal pure returns (int256 y_) {\n        y_ = int256(x_);\n        assert(y_ >= int256(0));\n    }\n\n    function _toUint256Safe(int256 x_) internal pure returns (uint256 y_) {\n        assert(x_ >= int256(0));\n        return uint256(x_);\n    }\n\n    function _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {\n        // Check that the account is the position NFT owner.\n        require(ownerOf(tokenId_) == account_, \"NOT_OWNER\");\n\n        // Fetch position.\n        Position storage position = positionOf[tokenId_];\n        uint96 units = position.units;\n        uint88 depositedXDEFI = position.depositedXDEFI;\n        uint32 expiry = position.expiry;\n\n        // Check that enough time has elapsed in order to unlock.\n        require(expiry != uint32(0), \"NO_LOCKED_POSITION\");\n        require(block.timestamp >= uint256(expiry), \"CANNOT_UNLOCK\");\n\n        // Get the withdrawable amount of XDEFI for the position.\n        amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);\n\n        // Track deposits.\n        totalDepositedXDEFI -= uint256(depositedXDEFI);\n\n        // Burn FDT Position.\n        totalUnits -= units;\n        delete positionOf[tokenId_];\n\n        emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);\n    }\n\n    function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {\n        uint256 count = tokenIds_.length;\n        require(count > uint256(1), \"USE_UNLOCK\");\n\n        // Handle the unlock for each position and accumulate the unlocked amount.\n        for (uint256 i; i < count; ++i) {\n            amountUnlocked_ += _unlock(account_, tokenIds_[i]);\n        }\n    }\n\n    function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {\n        uint256 previousDistributableXDEFI = distributableXDEFI;\n        uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;\n\n        return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI);\n    }\n\n    function _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {\n        return\n            (\n                _toUint256Safe(\n                    _toInt256Safe(_pointsPerUnit * uint256(units_)) +\n                    pointsCorrection_\n                ) / _pointsMultiplier\n            ) + uint256(depositedXDEFI_);\n    }\n\n}\n",
    "bin": []
}